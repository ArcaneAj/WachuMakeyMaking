<?xml version="1.0"?>
<doc>
    <assembly>
        "SonnetWrapperNET4"
    </assembly>
    <members>
        <member name="M:COIN.CoinLpIO.passInMessageHandler(COIN.CoinMessageHandler)">
Pass in Message handler

		Supply a custom message handler. It will not be destroyed when the
		CoinMpsIO object is destroyed.

</member>
        <member name="M:COIN.CoinLpIO.columnName(System.Int32)">
Return the column name for the specified index.
Return 0 if the index is out of range or if column names are not 
defined.
</member>
        <member name="M:COIN.CoinLpIO.rowName(System.Int32)">
Return the row name for the specified index.
Return the objective function name if index = getNumRows().
Return 0 if the index is out of range or if row names are not defined.
</member>
        <member name="M:COIN.CoinLpIO.isInteger(System.Int32)">
Return true if a column is an integer (binary or general 
integer) variable
</member>
        <member name="M:COIN.CoinLpIO.getColUpper">
Get pointer to array[getNumCols()] of column upper bounds
</member>
        <member name="M:COIN.CoinLpIO.getColLower">
Get pointer to array[getNumCols()] of column lower bounds
</member>
        <member name="M:COIN.CoinLpIO.getNumElements">
Get number of nonzero elements
</member>
        <member name="M:COIN.CoinLpIO.getNumRows">
Get number of rows
</member>
        <member name="M:COIN.CoinLpIO.getNumCols">
Get number of columns
</member>
        <member name="M:COIN.CoinLpIO.getObjName">
Return the objective name
</member>
        <member name="M:COIN.CoinLpIO.getProblemName">
Return the problem name
</member>
        <member name="M:COIN.CoinLpIO.getObjCoefficients">
Get pointer to array[getNumCols()] of objective function coefficients
</member>
        <member name="M:COIN.CoinLpIO.getRowUpper">
Get pointer to array[getNumRows()] of row upper bounds
</member>
        <member name="M:COIN.CoinLpIO.getRowLower">
Get pointer to array[getNumRows()] of row lower bounds
</member>
        <member name="M:COIN.CoinLpIO.getInfinity">
Get infinity
</member>
        <member name="M:COIN.CoinLpIO.setInfinity(System.Double)">
Set infinity
</member>
        <member name="M:COIN.NativeTests.RunOsiClpUnitTest(System.String)">
            <summary>
Runs the Clp test osiUnitTest.exe and 'Sample' dataset with exmip1 etc.
</summary>
            <returns>Return value of main</returns>
        </member>
        <member name="M:COIN.NativeTests.RunOsiCbcUnitTest(System.String)">
            <summary>
Runs the Cbc test osiUnitTest.exe and 'Sample' dataset with exmip1 etc.
</summary>
            <returns>Return value of main</returns>
        </member>
        <member name="M:COIN.NativeTests.RunGamsTest">
            <summary>
Runs the Cbc test using gamsTest.exe
</summary>
            <returns>Return value of main</returns>
        </member>
        <member name="M:COIN.NativeTests.RunCbc(System.String,System.String)">
            <summary>
Runs the Cbc test using cbc.exe and Sample and miplib3 dataset.
This method does not use SonnetWrapper classes
</summary>
            <param name="dirSample">The relative or absolute path to the coin-or Sample files. Example: ..\\..\\..\\Data-sample</param>
            <param name="dirMipLib">The relative or absolute path to the miplib3 files. Example: ..\\..\\..\\Data-miplib</param>
            <returns>Return value of main</returns>
        </member>
        <member name="F:ClpPlusMinusOneMatrix.columnOrdered_">
True if column ordered
</member>
        <member name="F:ClpPlusMinusOneMatrix.numberColumns_">
Number of columns
</member>
        <member name="F:ClpPlusMinusOneMatrix.numberRows_">
Number of rows
</member>
        <member name="F:ClpPlusMinusOneMatrix.indices_">
Data -1, then +1 rows in pairs (row==-1 if one entry)
</member>
        <member name="F:ClpPlusMinusOneMatrix.startNegative_">
Start of -1's for each
</member>
        <member name="F:ClpPlusMinusOneMatrix.startPositive_">
Start of +1's for each
</member>
        <member name="F:ClpPlusMinusOneMatrix.matrix_">
@name Data members
        The data members are protected to allow access for derived classes. 
For fake CoinPackedMatrix
</member>
        <member name="M:ClpPlusMinusOneMatrix.partialPricing(ClpSimplex*,System.Double,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Partial pricing
</member>
        <member name="M:ClpPlusMinusOneMatrix.canDoPartialPricing">
Says whether it can do partial pricing
</member>
        <member name="M:ClpPlusMinusOneMatrix.passInCopy(System.Int32,System.Int32,System.Boolean,System.Int32*,System.Int32*,System.Int32*)">
pass in copy (object takes ownership)
</member>
        <member name="M:ClpPlusMinusOneMatrix.subsetClone(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset clone (without gaps).  Duplicates are allowed
         and order is as given 
</member>
        <member name="M:ClpPlusMinusOneMatrix.clone">
Clone
</member>
        <member name="M:ClpPlusMinusOneMatrix.#ctor(ClpPlusMinusOneMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset constructor (without gaps).  Duplicates are allowed
         and order is as given 
</member>
        <member name="M:ClpPlusMinusOneMatrix.#ctor(System.Int32,System.Int32,System.Boolean,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Constructor from arrays
</member>
        <member name="M:ClpPlusMinusOneMatrix.#ctor(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The copy constructor from an CoinPlusMinusOneMatrix.
         If not a valid matrix then getIndices will be NULL and
         startPositive[0] will have number of +1,
         startPositive[1] will have number of -1,
         startPositive[2] will have number of others,

</member>
        <member name="M:ClpPlusMinusOneMatrix.#ctor(ClpPlusMinusOneMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.Dispose">
Destructor 
</member>
        <member name="M:ClpPlusMinusOneMatrix.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.startNegative">
Return starts of -1s
</member>
        <member name="M:ClpPlusMinusOneMatrix.startPositive">
@name Other 
Return starts of +1s
</member>
        <member name="M:ClpPlusMinusOneMatrix.subsetTimes2(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Double,System.Double,System.UInt32*,System.Double*,System.Double)">
Updates second array for steepest and does devex weights
</member>
        <member name="M:ClpPlusMinusOneMatrix.transposeTimes2(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Double*,System.Double*,System.Double,System.Double,System.UInt32*,System.Double*,System.Double)">
Updates two arrays for steepest and does devex weights 
	 Returns nonzero if updates reduced cost and infeas -
	 new infeas in dj1 
</member>
        <member name="M:ClpPlusMinusOneMatrix.canCombine(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*)">
Returns true if can combine transposeTimes and subsetTransposeTimes
         and if it would be faster 
</member>
        <member name="M:ClpPlusMinusOneMatrix.subsetTransposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)">
Return <code>x *A</code> in <code>z</code> but
     just for indices in y.
     Note - z always packed mode 
</member>
        <member name="M:ClpPlusMinusOneMatrix.transposeTimesByRow(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)">
Return <code>x * scalar * A + y</code> in <code>z</code>.
     Can use y as temporary array (will be empty at end)
     Note - If x packed mode - then z packed mode
     Squashes small elements and knows about ClpSimplex.
     This version uses row copy
</member>
        <member name="M:ClpPlusMinusOneMatrix.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)">
Return <code>x * scalar * A + y</code> in <code>z</code>.
     Can use y as temporary array (will be empty at end)
     Note - If x packed mode - then z packed mode
     Squashes small elements and knows about ClpSimplex 
</member>
        <member name="M:ClpPlusMinusOneMatrix.transposeTimes(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
And for scaling
</member>
        <member name="M:ClpPlusMinusOneMatrix.transposeTimes(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
Return <code>y + x * scalar * A</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numRows()</code>
         @pre <code>y</code> must be of size <code>numColumns()</code></member>
        <member name="M:ClpPlusMinusOneMatrix.times(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
And for scaling
</member>
        <member name="M:ClpPlusMinusOneMatrix.times(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
@name Matrix times vector methods 
Return <code>y + A * scalar *x</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numColumns()</code>
         @pre <code>y</code> must be of size <code>numRows()</code></member>
        <member name="M:ClpPlusMinusOneMatrix.checkValid(System.Boolean)">
Just checks matrix valid - will say if dimensions not quite right if detail
</member>
        <member name="M:ClpPlusMinusOneMatrix.setDimensions(System.Int32,System.Int32)">
Set the dimensions of the matrix. In effect, append new empty
         columns/rows to the matrix. A negative number for either dimension
         means that that dimension doesn't change. Otherwise the new dimensions
         MUST be at least as large as the current ones otherwise an exception
         is thrown. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.releasePackedMatrix">
Allow any parts of a created CoinMatrix to be deleted
</member>
        <member name="M:ClpPlusMinusOneMatrix.add(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Int32,System.Double)">
Adds multiple of a column into an array 
</member>
        <member name="M:ClpPlusMinusOneMatrix.add(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Int32,System.Double)">
Adds multiple of a column into an CoinIndexedvector
         You can use quickAdd to add to vector 
</member>
        <member name="M:ClpPlusMinusOneMatrix.unpackPacked(ClpSimplex*,CoinIndexedVector*,System.Int32)">
Unpacks a column into an CoinIndexedvector
      ** in packed foramt
         Note that model is NOT const.  Bounds and objective could
         be modified if doing column generation (just for this variable) 
</member>
        <member name="M:ClpPlusMinusOneMatrix.unpack(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Int32)">
Unpacks a column into an CoinIndexedvector

</member>
        <member name="M:ClpPlusMinusOneMatrix.rangeOfElements(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns largest and smallest elements of both signs.
         Largest refers to largest absolute value.

</member>
        <member name="M:ClpPlusMinusOneMatrix.dubiousWeights(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Int32*)">
Given positive integer weights for each row fills in sum of weights
         for each column (and slack).
         Returns weights vector

</member>
        <member name="M:ClpPlusMinusOneMatrix.fillBasis(ClpSimplex*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Double*)">
Fills in column part of basis
</member>
        <member name="M:ClpPlusMinusOneMatrix.countBasis(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns number of elements in column part of basis
</member>
        <member name="M:ClpPlusMinusOneMatrix.reverseOrderedCopy">
Returns a new matrix in reverse order without gaps 
</member>
        <member name="M:ClpPlusMinusOneMatrix.appendMatrix(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Append a set of rows/columns to the end of the matrix. Returns number of errors
         i.e. if any of the new rows/columns contain an index that's larger than the
         number of columns-1/rows-1 (if numberOther&gt;0) or duplicates
         If 0 then rows, 1 if columns 
</member>
        <member name="M:ClpPlusMinusOneMatrix.appendRows(System.Int32,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append Rows
</member>
        <member name="M:ClpPlusMinusOneMatrix.appendCols(System.Int32,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append Columns
</member>
        <member name="M:ClpPlusMinusOneMatrix.deleteRows(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the rows whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.deleteCols(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the columns whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.getVectorLengths">
The lengths of the major-dimension vectors. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.getIndices">
A vector containing the minor indices of the elements in the packed
          matrix. Note that there might be gaps in this list, entries that do not
          belong to any major-dimension vector. To get the actual elements one
          should look at this vector together with vectorStarts and
          vectorLengths. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.getElements">
A vector containing the elements in the packed matrix. Note that there
      might be gaps in this list, entries that do not belong to any
      major-dimension vector. To get the actual elements one should look at
      this vector together with vectorStarts and vectorLengths. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.getNumRows">
Number of rows. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.getNumCols">
Number of columns. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.getNumElements">
Number of entries in the packed matrix. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.isColOrdered">
Whether the packed matrix is column major ordered or not. 
</member>
        <member name="M:ClpPlusMinusOneMatrix.getPackedMatrix">
@name Useful methods 
Return a complete CoinPackedMatrix
</member>
        <member name="T:ClpPlusMinusOneMatrix">
This implements a simple +- one matrix as derived from ClpMatrixBase.


</member>
        <member name="F:ClpFactorization.doStatistics_">
To switch statistics on or off
</member>
        <member name="F:ClpFactorization.shortestAverage_">
For guessing when to re-factorize
</member>
        <member name="F:ClpFactorization.forceB_">
If nonzero force use of 1,dense 2,small 3,osl
</member>
        <member name="F:ClpFactorization.coinFactorizationB_">
Pointer to CoinOtherFactorization
</member>
        <member name="F:ClpFactorization.coinFactorizationA_">
Pointer to CoinFactorization
</member>
        <member name="F:ClpFactorization.networkBasis_">
@name data 
Pointer to network basis
</member>
        <member name="M:ClpFactorization.getWeights(System.Int32*)">
Fills weighted row list
</member>
        <member name="M:ClpFactorization.networkBasis">
Says if a network basis
</member>
        <member name="M:ClpFactorization.doStatistics(System.Boolean)">
To switch statistics on or off
</member>
        <member name="M:ClpFactorization.needToReorder">
Says whether to redo pivot order
</member>
        <member name="M:ClpFactorization.cleanUp">
Cleans up i.e. gets rid of network basis
</member>
        <member name="M:ClpFactorization.goSparse">
@name other stuff 
makes a row copy of L for speed and to allow very sparse problems 
</member>
        <member name="M:ClpFactorization.coinFactorization">
Return coinFactorizationA_
</member>
        <member name="M:ClpFactorization.isDenseOrSmall">
Return 1 if dense code
</member>
        <member name="M:ClpFactorization.setFactorization(ClpFactorization*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets factorization
</member>
        <member name="M:ClpFactorization.goDenseOrSmall(System.Int32)">
Go over to dense or small code if small enough
</member>
        <member name="M:ClpFactorization.forceOtherFactorization(System.Int32)">
If nonzero force use of 1,dense 2,small 3,osl
</member>
        <member name="M:ClpFactorization.setDefaultValues">
Sets default values
</member>
        <member name="M:ClpFactorization.setForrestTomlin(System.Boolean)">
true if Forrest Tomlin update, false if PFI
</member>
        <member name="M:ClpFactorization.adjustedAreaFactor">
Returns areaFactor but adjusted for dense
</member>
        <member name="M:ClpFactorization.almostDestructor">
Delete all stuff (leaves as after CoinFactorization())
</member>
        <member name="M:ClpFactorization.persistenceFlag">
Array persistence flag
         If 0 then as now (delete/new)
         1 then only do arrays if bigger needed
         2 as 1 but give a bit extra if bigger needed

</member>
        <member name="M:ClpFactorization.relaxAccuracyCheck(System.Double)">
Allows change of pivot accuracy check 1.0 == none &gt;1.0 relaxed
</member>
        <member name="M:ClpFactorization.pivotTolerance(System.Double)">
Set pivot tolerance
</member>
        <member name="M:ClpFactorization.pivotTolerance">
Pivot tolerance
</member>
        <member name="M:ClpFactorization.setDenseThreshold(System.Int32)">
Sets dense threshold
</member>
        <member name="M:ClpFactorization.denseThreshold">
Gets dense threshold
</member>
        <member name="M:ClpFactorization.numberRows">
Number of Rows after factorization
</member>
        <member name="M:ClpFactorization.clearArrays">
Get rid of all memory
</member>
        <member name="M:ClpFactorization.messageLevel(System.Int32)">
Set level of detail of messages
</member>
        <member name="M:ClpFactorization.messageLevel">
Level of detail of messages
</member>
        <member name="M:ClpFactorization.numberElementsR">
Returns number in R area
</member>
        <member name="M:ClpFactorization.numberElementsL">
Returns number in L area
</member>
        <member name="M:ClpFactorization.numberElementsU">
Returns number in U area
</member>
        <member name="M:ClpFactorization.numberDense">
Returns number of dense rows
</member>
        <member name="M:ClpFactorization.setStatus(System.Int32)">
Sets status
</member>
        <member name="M:ClpFactorization.status">
Returns status
</member>
        <member name="M:ClpFactorization.sparseThreshold(System.Int32)">
Set sparse threshold 
</member>
        <member name="M:ClpFactorization.sparseThreshold">
get sparse threshold 
</member>
        <member name="M:ClpFactorization.saferTolerances(System.Double,System.Double)">
Set tolerances to safer of existing and given
</member>
        <member name="M:ClpFactorization.zeroTolerance(System.Double)">
Set zero tolerance
</member>
        <member name="M:ClpFactorization.zeroTolerance">
Zero tolerance
</member>
        <member name="M:ClpFactorization.areaFactor(System.Double)">
Set whether larger areas needed
</member>
        <member name="M:ClpFactorization.areaFactor">
Whether larger areas needed
</member>
        <member name="M:ClpFactorization.pivots">
Returns number of pivots since factorization
</member>
        <member name="M:ClpFactorization.maximumPivots(System.Int32)">
Set maximum number of pivots between factorizations
</member>
        <member name="M:ClpFactorization.maximumPivots">
Maximum number of pivots between factorizations
</member>
        <member name="M:ClpFactorization.pivotColumn">
Returns address of pivotColumn region (also used for permuting)
</member>
        <member name="M:ClpFactorization.permute">
Returns address of permute region
</member>
        <member name="M:ClpFactorization.numberElements">
@name Lifted from CoinFactorization 
Total number of elements in factorization
</member>
        <member name="M:ClpFactorization.updateTwoColumnsTranspose(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Updates two columns (BTRAN) from regionSparse2 and 3
	 regionSparse starts as zero and is zero at end 
	 Note - if regionSparse2 packed on input - will be packed on output - same for 3

</member>
        <member name="M:ClpFactorization.updateColumnTranspose(CoinIndexedVector*,CoinIndexedVector*)">
Updates one column (BTRAN) from region2
         region1 starts as zero and is zero at end 
</member>
        <member name="M:ClpFactorization.updateColumnForDebug(CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
For debug (no statistics update)
</member>
        <member name="M:ClpFactorization.updateTwoColumnsFT(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
Updates one column (FTRAN) from region2
         Tries to do FT update
         number returned is negative if no room.
         Also updates region3
         region1 starts as zero and is zero at end 
</member>
        <member name="M:ClpFactorization.updateColumn(CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
Updates one column (FTRAN) from region2
         region1 starts as zero and is zero at end 
</member>
        <member name="M:ClpFactorization.updateColumnFT(CoinIndexedVector*,CoinIndexedVector*)">
@name various uses of factorization (return code number elements)
      which user may want to know about 
Updates one column (FTRAN) from region2
         Tries to do FT update
         number returned is negative if no room
         region1 starts as zero and is zero at end 
</member>
        <member name="M:ClpFactorization.replaceColumn(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*,System.Int32,System.Double,System.Boolean,System.Double)">
@name rank one updates which do exist 
Replaces one Column to basis,
      returns 0=OK, 1=Probably OK, 2=singular, 3=no room
         If checkBeforeModifying is true will do all accuracy checks
         before modifying factorization.  Whether to set this depends on
         speed considerations.  You could just do this on first iteration
         after factorization and thereafter re-factorize
      partial update already in U 
</member>
        <member name="M:ClpFactorization.#ctor(CoinOtherFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The copy constructor from an CoinOtherFactorization. 
</member>
        <member name="M:ClpFactorization.#ctor(ClpFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
The copy constructor. 
</member>
        <member name="M:ClpFactorization.#ctor(CoinFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor from an CoinFactorization. 
</member>
        <member name="M:ClpFactorization.Dispose">
Destructor 
</member>
        <member name="M:ClpFactorization.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpFactorization.factorize(ClpSimplex*,System.Int32,System.Boolean)">
@name factorization 
When part of LP - given by basic variables.
     Actually does factorization.
     Arrays passed in have non negative value to say basic.
     If status is okay, basic variables have pivot row - this is only needed
     if increasingRows_ &gt;1.
     Allows scaling
     If status is singular, then basic variables have pivot row
     and ones thrown out have -1
     returns 0 -okay, -1 singular, -2 too many in basis, -99 memory 
</member>
        <member name="M:CoinDenseFactorization.checkPivot(System.Double,System.Double)">
Returns accuracy status of replaceColumn
      returns 0=OK, 1=Probably OK, 2=singular 
</member>
        <member name="M:CoinDenseFactorization.gutsOfCopy(CoinDenseFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The real work of copy
</member>
        <member name="M:CoinDenseFactorization.gutsOfInitialize">
The real work of constructor
</member>
        <member name="M:CoinDenseFactorization.gutsOfDestructor">
The real work of desstructor
</member>
        <member name="M:CoinDenseFactorization.permute">
Returns permute in
</member>
        <member name="M:CoinDenseFactorization.indices">
Returns array to put basis indices in
</member>
        <member name="M:CoinDenseFactorization.clearArrays">
*** Below this user may not want to know about
@name various uses of factorization
   which user may not want to know about (left over from my LP code) 
Get rid of all memory
</member>
        <member name="M:CoinDenseFactorization.updateColumnTranspose(CoinIndexedVector*,CoinIndexedVector*)">
Updates one column (BTRAN) from regionSparse2
      regionSparse starts as zero and is zero at end 
      Note - if regionSparse2 packed on input - will be packed on output

</member>
        <member name="M:CoinDenseFactorization.updateTwoColumnsFT(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
does FTRAN on two columns
</member>
        <member name="M:CoinDenseFactorization.updateColumn(CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
This version has same effect as above with FTUpdate==false
      so number returned is always &gt;=0 
</member>
        <member name="M:CoinDenseFactorization.updateColumnFT(CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
@name various uses of factorization (return code number elements) 
   which user may want to know about 
Updates one column (FTRAN) from regionSparse2
      Tries to do FT update
      number returned is negative if no room
      regionSparse starts as zero and is zero at end.
      Note - if regionSparse2 packed on input - will be packed on output

</member>
        <member name="M:CoinDenseFactorization.replaceColumn(CoinIndexedVector*,System.Int32,System.Double,System.Boolean,System.Double)">
@name rank one updates which do exist 
Replaces one Column to basis,
   returns 0=OK, 1=Probably OK, 2=singular, 3=no room
      If checkBeforeModifying is true will do all accuracy checks
      before modifying factorization.  Whether to set this depends on
      speed considerations.  You could just do this on first iteration
      after factorization and thereafter re-factorize
   partial update already in U 
</member>
        <member name="M:CoinDenseFactorization.maximumCoefficient">
Returns maximum absolute value in factorization
</member>
        <member name="M:CoinDenseFactorization.numberElements">
@name general stuff such as number of elements 
Total number of elements in factorization
</member>
        <member name="M:CoinDenseFactorization.makeNonSingular(System.Int32*,System.Int32)">
Makes a non-singular basis by replacing variables
</member>
        <member name="M:CoinDenseFactorization.postProcess(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*)">
Does post processing on valid factorization - putting variables on correct rows
</member>
        <member name="M:CoinDenseFactorization.factor">
Does most of factorization returning status
      0 - OK
      -99 - needs more memory
      -1 - singular - use numberGoodColumns and redo

</member>
        <member name="M:CoinDenseFactorization.preProcess">
PreProcesses column ordered copy of basis
</member>
        <member name="M:CoinDenseFactorization.getAreas(System.Int32,System.Int32,System.Int32,System.Int32)">
@name Do factorization - public 
Gets space for a factorization
</member>
        <member name="M:CoinDenseFactorization.clone">
Clone
</member>
        <member name="M:CoinDenseFactorization.op_Assign(CoinDenseFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
= copy
</member>
        <member name="M:CoinDenseFactorization.Dispose">
Destructor
</member>
        <member name="M:CoinDenseFactorization.#ctor(CoinDenseFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CoinDenseFactorization.#ctor">
@name Constructors and destructor and copy 
Default constructor
</member>
        <member name="T:CoinDenseFactorization">
This deals with Factorization and Updates
    This is a simple dense version so other people can write a better one

    I am assuming that 32 bits is enough for number of rows or columns, but CoinBigIndex
    may be redefined to get 64 bits.

</member>
        <member name="F:CoinOtherFactorization.solveMode_">
Solve mode e.g. 0 C++ code, 1 Lapack, 2 choose
      If 4 set then values pass
      if 8 set then has iterated

</member>
        <member name="F:CoinOtherFactorization.workArea_">
Work area of numberRows_
</member>
        <member name="F:CoinOtherFactorization.elements_">
Elements of factorization and updates
      length is maxR*maxR+maxSpace
      will always be long enough so can have nR*nR ints in maxSpace 

</member>
        <member name="F:CoinOtherFactorization.pivotRow_">
Pivot row
</member>
        <member name="F:CoinOtherFactorization.maximumSpace_">
Maximum length of iterating area
</member>
        <member name="F:CoinOtherFactorization.maximumRows_">
Maximum rows ever (i.e. use to copy arrays etc)
</member>
        <member name="F:CoinOtherFactorization.status_">
Status of factorization
</member>
        <member name="F:CoinOtherFactorization.numberPivots_">
Number pivots since last factorization
</member>
        <member name="F:CoinOtherFactorization.maximumPivots_">
Maximum number of pivots before factorization
</member>
        <member name="F:CoinOtherFactorization.numberGoodU_">
Number factorized in U (not row singletons)
</member>
        <member name="F:CoinOtherFactorization.numberColumns_">
Number of Columns in factorization
</member>
        <member name="F:CoinOtherFactorization.numberRows_">
Number of Rows in factorization
</member>
        <member name="F:CoinOtherFactorization.factorElements_">
Number of elements after factorization
</member>
        <member name="F:CoinOtherFactorization.relaxCheck_">
Relax check on accuracy in replaceColumn
</member>
        <member name="F:CoinOtherFactorization.slackValue_">
Whether slack value is  +1 or -1
</member>
        <member name="F:CoinOtherFactorization.zeroTolerance_">
Zero tolerance
</member>
        <member name="F:CoinOtherFactorization.pivotTolerance_">
@name data 
Pivot tolerance
</member>
        <member name="M:CoinOtherFactorization.updateColumnTranspose(CoinIndexedVector*,CoinIndexedVector*)">
Updates one column (BTRAN) from regionSparse2
      regionSparse starts as zero and is zero at end 
      Note - if regionSparse2 packed on input - will be packed on output

</member>
        <member name="M:CoinOtherFactorization.updateTwoColumnsFT(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
does FTRAN on two columns
</member>
        <member name="M:CoinOtherFactorization.updateColumn(CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
This version has same effect as above with FTUpdate==false
      so number returned is always &gt;=0 
</member>
        <member name="M:CoinOtherFactorization.updateColumnFT(CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
@name various uses of factorization (return code number elements) 
   which user may want to know about 
Updates one column (FTRAN) from regionSparse2
      Tries to do FT update
      number returned is negative if no room
      regionSparse starts as zero and is zero at end.
      Note - if regionSparse2 packed on input - will be packed on output

</member>
        <member name="M:CoinOtherFactorization.replaceColumn(CoinIndexedVector*,System.Int32,System.Double,System.Boolean,System.Double)">
@name rank one updates which do exist 
Replaces one Column to basis,
   returns 0=OK, 1=Probably OK, 2=singular, 3=no room
      If checkBeforeModifying is true will do all accuracy checks
      before modifying factorization.  Whether to set this depends on
      speed considerations.  You could just do this on first iteration
      after factorization and thereafter re-factorize
   partial update already in U 
</member>
        <member name="M:CoinOtherFactorization.makeNonSingular(System.Int32*,System.Int32)">
Makes a non-singular basis by replacing variables
</member>
        <member name="M:CoinOtherFactorization.postProcess(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*)">
Does post processing on valid factorization - putting variables on correct rows
</member>
        <member name="M:CoinOtherFactorization.factor">
Does most of factorization returning status
      0 - OK
      -99 - needs more memory
      -1 - singular - use numberGoodColumns and redo

</member>
        <member name="M:CoinOtherFactorization.preProcess">
PreProcesses column ordered copy of basis
</member>
        <member name="M:CoinOtherFactorization.getAreas(System.Int32,System.Int32,System.Int32,System.Int32)">
@name Do factorization - public 
Gets space for a factorization
</member>
        <member name="M:CoinOtherFactorization.numberElements">
Total number of elements in factorization
</member>
        <member name="M:CoinOtherFactorization.permute">
Returns permute in
</member>
        <member name="M:CoinOtherFactorization.indices">
@name virtual general stuff such as permutation 
Returns array to put basis indices in
</member>
        <member name="M:CoinOtherFactorization.clearArrays">
Get rid of all memory
</member>
        <member name="M:CoinOtherFactorization.setUsefulInformation(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Useful information for factorization
      0 - iteration number
      whereFrom is 0 for factorize and 1 for replaceColumn

</member>
        <member name="M:CoinOtherFactorization.wantsTableauColumn">
Returns true if wants tableauColumn in replaceColumn
</member>
        <member name="M:CoinOtherFactorization.setSolveMode(System.Int32)">
Set solve mode e.g. 0 C++ code, 1 Lapack, 2 choose
      If 4 set then values pass
      if 8 set then has iterated

</member>
        <member name="M:CoinOtherFactorization.solveMode">
Get solve mode e.g. 0 C++ code, 1 Lapack, 2 choose
      If 4 set then values pass
      if 8 set then has iterated

</member>
        <member name="M:CoinOtherFactorization.permuteBack">
Returns permute back
</member>
        <member name="M:CoinOtherFactorization.starts">
Returns array to put basis starts in
</member>
        <member name="M:CoinOtherFactorization.numberInColumn">
Number of entries in each column
</member>
        <member name="M:CoinOtherFactorization.numberInRow">
Number of entries in each row
</member>
        <member name="M:CoinOtherFactorization.intWorkArea">
Returns int work area
</member>
        <member name="M:CoinOtherFactorization.workArea">
Returns work area
</member>
        <member name="M:CoinOtherFactorization.pivotRow">
Returns pivot row
</member>
        <member name="M:CoinOtherFactorization.elements">
Returns array to put basis elements in
</member>
        <member name="M:CoinOtherFactorization.slackValue">
Whether slack value is +1 or -1
</member>
        <member name="M:CoinOtherFactorization.zeroTolerance">
Zero tolerance
</member>
        <member name="M:CoinOtherFactorization.pivotTolerance">
Pivot tolerance
</member>
        <member name="M:CoinOtherFactorization.maximumPivots(System.Int32)">
Set maximum pivots
</member>
        <member name="M:CoinOtherFactorization.maximumPivots">
Maximum number of pivots between factorizations
</member>
        <member name="M:CoinOtherFactorization.relaxAccuracyCheck(System.Double)">
Allows change of pivot accuracy check 1.0 == none &gt;1.0 relaxed
</member>
        <member name="M:CoinOtherFactorization.numberGoodColumns">
Number of good columns in factorization
</member>
        <member name="M:CoinOtherFactorization.numberColumns">
Total number of columns in factorization
</member>
        <member name="M:CoinOtherFactorization.numberRows">
Number of Rows after factorization
</member>
        <member name="M:CoinOtherFactorization.setNumberRows(System.Int32)">
Set number of Rows after factorization
</member>
        <member name="M:CoinOtherFactorization.setPivots(System.Int32)">
Sets number of pivots since factorization
</member>
        <member name="M:CoinOtherFactorization.pivots">
Returns number of pivots since factorization
</member>
        <member name="M:CoinOtherFactorization.setStatus(System.Int32)">
Sets status
</member>
        <member name="M:CoinOtherFactorization.status">
@name general stuff such as status 
Returns status
</member>
        <member name="M:CoinOtherFactorization.clone">
Clone
</member>
        <member name="M:CoinOtherFactorization.op_Assign(CoinOtherFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
= copy
</member>
        <member name="M:CoinOtherFactorization.Dispose">
Destructor
</member>
        <member name="M:CoinOtherFactorization.#ctor(CoinOtherFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CoinOtherFactorization.#ctor">
@name Constructors and destructor and copy 
Default constructor
</member>
        <member name="T:CoinOtherFactorization">
Abstract base class which also has some scalars so can be used from Dense or Simp
</member>
        <member name="F:CoinFactorization.persistenceFlag_">
Array persistence flag
      If 0 then as now (delete/new)
      1 then only do arrays if bigger needed
      2 as 1 but give a bit extra if bigger needed

</member>
        <member name="F:CoinFactorization.biasLU_">
L to U bias
      0 - U bias, 1 - some U bias, 2 some L bias, 3 L bias

</member>
        <member name="F:CoinFactorization.sparse_">
Sparse regions
</member>
        <member name="F:CoinFactorization.elementByRowL_">
Elements in L (row copy)
</member>
        <member name="F:CoinFactorization.indexColumnL_">
Index of column in row for L
</member>
        <member name="F:CoinFactorization.startRowL_">
Start of each row in L
</member>
        <member name="F:CoinFactorization.sparseThreshold2_">
And one for "sparsish"
</member>
        <member name="F:CoinFactorization.sparseThreshold_">
For statistics
Below this use sparse technology - if 0 then no L row copy
</member>
        <member name="F:CoinFactorization.ftranAverageAfterL_">
While these are average ratios collected over last period
</member>
        <member name="F:CoinFactorization.numberFtranCounts_">
We can roll over factorizations
</member>
        <member name="F:CoinFactorization.ftranCountInput_">
Below are all to collect
</member>
        <member name="F:CoinFactorization.numberCompressions_">
Number of compressions done
</member>
        <member name="F:CoinFactorization.workArea2_">
Second work area
</member>
        <member name="F:CoinFactorization.workArea_">
First work area
</member>
        <member name="F:CoinFactorization.denseThreshold_">
Dense threshold
</member>
        <member name="F:CoinFactorization.numberDense_">
Number of dense rows
</member>
        <member name="F:CoinFactorization.densePermute_">
Dense permutation
</member>
        <member name="F:CoinFactorization.denseAreaAddress_">
Dense area - actually used (for alignment etc)
</member>
        <member name="F:CoinFactorization.denseArea_">
Dense area
</member>
        <member name="F:CoinFactorization.startColumnR_">
Start of columns for R
</member>
        <member name="F:CoinFactorization.indexRowR_">
Row indices for R
</member>
        <member name="F:CoinFactorization.elementR_">
Elements of R
</member>
        <member name="F:CoinFactorization.lengthAreaR_">
length of area reserved for R
</member>
        <member name="F:CoinFactorization.lengthR_">
Length of R stuff
</member>
        <member name="F:CoinFactorization.numberR_">
Number in R
</member>
        <member name="F:CoinFactorization.doForrestTomlin_">
true if Forrest Tomlin update, false if PFI
</member>
        <member name="F:CoinFactorization.startColumnL_">
Start of each column in L
</member>
        <member name="F:CoinFactorization.indexRowL_">
Row indices of L
</member>
        <member name="F:CoinFactorization.elementL_">
Elements of L
</member>
        <member name="F:CoinFactorization.lengthAreaL_">
Length of area reserved for L
</member>
        <member name="F:CoinFactorization.lengthL_">
Length of L
</member>
        <member name="F:CoinFactorization.baseL_">
Base of L
</member>
        <member name="F:CoinFactorization.numberL_">
Number in L
</member>
        <member name="F:CoinFactorization.convertRowToColumnU_">
Converts rows to columns in U
</member>
        <member name="F:CoinFactorization.startColumnU_">
Start of each column in U
</member>
        <member name="F:CoinFactorization.indexRowU_">
Row indices of U
</member>
        <member name="F:CoinFactorization.elementU_">
Elements of U
</member>
        <member name="F:CoinFactorization.lengthAreaU_">
Length of area reserved for U
</member>
        <member name="F:CoinFactorization.lengthU_">
Base of U is always 0
Length of U
</member>
        <member name="F:CoinFactorization.maximumU_">
Maximum space used in U
</member>
        <member name="F:CoinFactorization.numberU_">
Number in U
</member>
        <member name="F:CoinFactorization.numberSlacks_">
Number of slacks at beginning of U
</member>
        <member name="F:CoinFactorization.pivotRegion_">
Inverses of pivot values
</member>
        <member name="F:CoinFactorization.pivotRowL_">
Pivots for L
</member>
        <member name="F:CoinFactorization.indexColumnU_">
Base address for U (may change)
</member>
        <member name="F:CoinFactorization.biggerDimension_">
Larger of row and column size
</member>
        <member name="F:CoinFactorization.messageLevel_">
Detail in messages
</member>
        <member name="F:CoinFactorization.markRow_">
Marks rows to be updated
</member>
        <member name="F:CoinFactorization.saveColumn_">
Columns left to do in a single pivot
</member>
        <member name="F:CoinFactorization.lastRow_">
Previous Row in memory order
</member>
        <member name="F:CoinFactorization.nextRow_">
Next Row in memory order
</member>
        <member name="F:CoinFactorization.lastColumn_">
Previous Column in memory order
</member>
        <member name="F:CoinFactorization.nextColumn_">
Next Column in memory order
</member>
        <member name="F:CoinFactorization.lastCount_">
Previous Row/Column with count
</member>
        <member name="F:CoinFactorization.nextCount_">
Next Row/Column with count
</member>
        <member name="F:CoinFactorization.firstCount_">
First Row/Column with count of k,
      can tell which by offset - Rows then Columns 
</member>
        <member name="F:CoinFactorization.numberInColumnPlus_">
Number in each Column including pivoted
</member>
        <member name="F:CoinFactorization.numberInColumn_">
Number in each Column
</member>
        <member name="F:CoinFactorization.numberInRow_">
Number in each Row
</member>
        <member name="F:CoinFactorization.startRowU_">
Start of each Row as pointer
</member>
        <member name="F:CoinFactorization.numberTrials_">
0 - no increasing rows - no permutations,
   1 - no increasing rows but permutations 
   2 - increasing rows 
     - taken out as always 2 
Number of trials before rejection
</member>
        <member name="F:CoinFactorization.status_">
Status of factorization
</member>
        <member name="F:CoinFactorization.pivotColumnBack_">
Inverse Pivot order for each Column
</member>
        <member name="F:CoinFactorization.permuteBack_">
DePermutation vector for pivot row order
</member>
        <member name="F:CoinFactorization.permute_">
Permutation vector for pivot row order
</member>
        <member name="F:CoinFactorization.pivotColumn_">
Pivot order for each Column
</member>
        <member name="F:CoinFactorization.factorElements_">
Number of elements after factorization
</member>
        <member name="F:CoinFactorization.totalElements_">
Number of elements in U (to go)
      or while iterating total overall
</member>
        <member name="F:CoinFactorization.numberPivots_">
Number pivots since last factorization
</member>
        <member name="F:CoinFactorization.maximumPivots_">
Maximum number of pivots before factorization
</member>
        <member name="F:CoinFactorization.numberGoodL_">
Number factorized in L
</member>
        <member name="F:CoinFactorization.numberGoodU_">
Number factorized in U (not row singletons)
</member>
        <member name="F:CoinFactorization.maximumColumnsExtra_">
Maximum number of Columns after iterating
</member>
        <member name="F:CoinFactorization.numberColumnsExtra_">
Number of Columns after iterating
</member>
        <member name="F:CoinFactorization.numberColumns_">
Number of Columns in factorization
</member>
        <member name="F:CoinFactorization.maximumRowsExtra_">
Maximum number of Rows after iterating
</member>
        <member name="F:CoinFactorization.numberRowsExtra_">
Number of Rows after iterating
</member>
        <member name="F:CoinFactorization.numberRows_">
Number of Rows in factorization
</member>
        <member name="F:CoinFactorization.relaxCheck_">
Relax check on accuracy in replaceColumn
</member>
        <member name="F:CoinFactorization.areaFactor_">
How much to multiply areas by
</member>
        <member name="F:CoinFactorization.slackValue_">
Whether slack value is  +1 or -1
</member>
        <member name="F:CoinFactorization.zeroTolerance_">
Zero tolerance
</member>
        <member name="F:CoinFactorization.pivotTolerance_">
@name data 
Pivot tolerance
</member>
        <member name="M:CoinFactorization.checkPivot(System.Double,System.Double)">
Returns accuracy status of replaceColumn
      returns 0=OK, 1=Probably OK, 2=singular 
</member>
        <member name="M:CoinFactorization.replaceColumnPFI(CoinIndexedVector*,System.Int32,System.Double)">
Replaces one Column to basis for PFI
   returns 0=OK, 1=Probably OK, 2=singular, 3=no room.
   In this case region is not empty - it is incoming variable (updated)

</member>
        <member name="M:CoinFactorization.updateColumnTransposeLSparse(CoinIndexedVector*)">
Updates part of column transpose (BTRANL) when sparse (by Row)
</member>
        <member name="M:CoinFactorization.updateColumnTransposeLSparsish(CoinIndexedVector*)">
Updates part of column transpose (BTRANL) when sparsish by row
</member>
        <member name="M:CoinFactorization.updateColumnTransposeLByRow(CoinIndexedVector*)">
Updates part of column transpose (BTRANL) when densish by row
</member>
        <member name="M:CoinFactorization.updateColumnTransposeLDensish(CoinIndexedVector*)">
Updates part of column transpose (BTRANL) when densish by column
</member>
        <member name="M:CoinFactorization.updateColumnTransposeL(CoinIndexedVector*)">
Updates part of column transpose (BTRANL)
</member>
        <member name="M:CoinFactorization.updateColumnTransposeRSparse(CoinIndexedVector*)">
Updates part of column transpose (BTRANR) when sparse
</member>
        <member name="M:CoinFactorization.updateColumnTransposeRDensish(CoinIndexedVector*)">
Updates part of column transpose (BTRANR) when dense
</member>
        <member name="M:CoinFactorization.updateColumnTransposeR(CoinIndexedVector*)">
Updates part of column transpose (BTRANR)
</member>
        <member name="M:CoinFactorization.updateColumnTransposeUByColumn(CoinIndexedVector*,System.Int32)">
Updates part of column transpose (BTRANU) by column
      assumes index is sorted i.e. region is correct 
</member>
        <member name="M:CoinFactorization.updateColumnTransposeUSparse(CoinIndexedVector*)">
Updates part of column transpose (BTRANU) when sparse,
      assumes index is sorted i.e. region is correct 
</member>
        <member name="M:CoinFactorization.updateColumnTransposeUDensish(CoinIndexedVector*,System.Int32)">
Updates part of column transpose (BTRANU) when densish,
      assumes index is sorted i.e. region is correct 
</member>
        <member name="M:CoinFactorization.updateColumnTransposeUSparsish(CoinIndexedVector*,System.Int32)">
Updates part of column transpose (BTRANU) when sparsish,
      assumes index is sorted i.e. region is correct 
</member>
        <member name="M:CoinFactorization.updateColumnTransposeU(CoinIndexedVector*,System.Int32)">
Updates part of column transpose (BTRANU),
      assumes index is sorted i.e. region is correct 
</member>
        <member name="M:CoinFactorization.updateColumnTransposePFI(CoinIndexedVector*)">
Updates part of column transpose PFI (BTRAN) (before rest)
</member>
        <member name="M:CoinFactorization.permuteBack(CoinIndexedVector*,CoinIndexedVector*)">
Permutes back at end of updateColumn
</member>
        <member name="M:CoinFactorization.updateColumnPFI(CoinIndexedVector*)">
Updates part of column PFI (FTRAN) (after rest)
</member>
        <member name="M:CoinFactorization.updateTwoColumnsUDensish(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,System.Int32*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,System.Int32*)">
Updates part of 2 columns (FTRANU) real work
</member>
        <member name="M:CoinFactorization.updateColumnUDensish(System.Double*,System.Int32*)">
Updates part of column (FTRANU)
</member>
        <member name="M:CoinFactorization.updateColumnUSparsish(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANU) when sparsish
</member>
        <member name="M:CoinFactorization.updateColumnUSparse(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANU) when sparse
</member>
        <member name="M:CoinFactorization.updateColumnU(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANU)
</member>
        <member name="M:CoinFactorization.updateColumnRFT(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANR) with FT update.
      Also stores update after L and R 
</member>
        <member name="M:CoinFactorization.updateColumnR(CoinIndexedVector*)">
Updates part of column (FTRANR) without FT update
</member>
        <member name="M:CoinFactorization.updateColumnLSparsish(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANL) when sparsish
</member>
        <member name="M:CoinFactorization.updateColumnLSparse(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANL) when sparse
</member>
        <member name="M:CoinFactorization.updateColumnLDensish(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANL) when densish
</member>
        <member name="M:CoinFactorization.updateColumnL(CoinIndexedVector*,System.Int32*)">
Updates part of column (FTRANL)
</member>
        <member name="M:CoinFactorization.cleanup">
Cleans up at end of factorization
</member>
        <member name="M:CoinFactorization.separateLinks(System.Int32,System.Boolean)">
Separate out links with same row/column count
</member>
        <member name="M:CoinFactorization.deleteLink(System.Int32)">
Deletes a link in chain of equal counts
</member>
        <member name="M:CoinFactorization.addLink(System.Int32,System.Int32)">
Adds a link in chain of equal counts
</member>
        <member name="M:CoinFactorization.checkConsistency">
Checks that row and column copies look OK
</member>
        <member name="M:CoinFactorization.getRowSpaceIterate(System.Int32,System.Int32)">
Gets space for one Row with given length while iterating,
  may have to do compression  (returns True if successful),
  also moves existing vector 
</member>
        <member name="M:CoinFactorization.getRowSpace(System.Int32,System.Int32)">
Gets space for one Row with given length,
  may have to do compression  (returns True if successful),
  also moves existing vector 
</member>
        <member name="M:CoinFactorization.getColumnSpaceIterate(System.Int32,System.Double,System.Int32)">
getColumnSpaceIterate.  Gets space for one extra U element in Column
      may have to do compression  (returns true)
      also moves existing vector.
      Returns -1 if no memory or where element was put
      Used by replaceRow (turns off R version) 
</member>
        <member name="M:CoinFactorization.getColumnSpaceIterateR(System.Int32,System.Double,System.Int32)">
getColumnSpaceIterateR.  Gets space for one extra R element in Column
      may have to do compression  (returns true)
      also moves existing vector 
</member>
        <member name="M:CoinFactorization.reorderU">
Reorders U so contiguous and in order (if there is space)
      Returns true if it could 
</member>
        <member name="M:CoinFactorization.getColumnSpace(System.Int32,System.Int32)">
Gets space for one Column with given length,
   may have to do compression  (returns True if successful),
   also moves existing vector,
   extraNeeded is over and above present 
</member>
        <member name="M:CoinFactorization.pivotColumnSingleton(System.Int32,System.Int32)">
Does one pivot on Column Singleton in factorization
</member>
        <member name="M:CoinFactorization.pivotRowSingleton(System.Int32,System.Int32)">
Does one pivot on Row Singleton in factorization
</member>
        <member name="M:CoinFactorization.pivotOneOtherRow(System.Int32,System.Int32)">
Pivots when just one other row so faster?
</member>
        <member name="M:CoinFactorization.factor">
Does most of factorization
</member>
        <member name="M:CoinFactorization.preProcess(System.Int32,System.Int32)">
PreProcesses raw triplet data.
      state is 0 - triplets, 1 - some counts etc , 2 - .. 
</member>
        <member name="M:CoinFactorization.getAreas(System.Int32,System.Int32,System.Int32,System.Int32)">
@name used by factorization 
Gets space for a factorization, called by constructors
</member>
        <member name="M:CoinFactorization.resetStatistics">
Reset all sparsity etc statistics
</member>
        <member name="M:CoinFactorization.gutsOfInitialize(System.Int32)">
1 bit - tolerances etc, 2 more, 4 dummy arrays
</member>
        <member name="M:CoinFactorization.gutsOfDestructor(System.Int32)">
The real work of constructors etc 0 just scalars, 1 bit normal
</member>
        <member name="M:CoinFactorization.setCollectStatistics(System.Boolean)">
For statistics
</member>
        <member name="M:CoinFactorization.collectStatistics">
For statistics
</member>
        <member name="M:CoinFactorization.checkSparse">
@name used by ClpFactorization 
See if worth going sparse
</member>
        <member name="M:CoinFactorization.emptyRows(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Takes out all entries for given rows
</member>
        <member name="M:CoinFactorization.replaceRow(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Replaces one Row in basis,
      At present assumes just a singleton on row is in basis
      returns 0=OK, 1=Probably OK, 2=singular, 3 no space 
</member>
        <member name="M:CoinFactorization.deleteRow(System.Int32)">
Deletes one Row from basis, returns rank
</member>
        <member name="M:CoinFactorization.deleteColumn(System.Int32)">
Deletes one Column from basis, returns rank
</member>
        <member name="M:CoinFactorization.addRow(System.Int32,System.Int32*,System.Double*)">
Adds one Row to basis,
      can increase size of basis. Returns rank 
</member>
        <member name="M:CoinFactorization.addColumn(System.Int32,System.Int32*,System.Double*)">
Adds one Column to basis,
      can increase size of basis. Returns rank 
</member>
        <member name="M:CoinFactorization.add(System.Int32,System.Int32*,System.Int32*,System.Double*)">
@name various updates - none of which have been written! 
Adds given elements to Basis and updates factorization,
      can increase size of basis. Returns rank 
</member>
        <member name="M:CoinFactorization.clearArrays">
*** Below this user may not want to know about
@name various uses of factorization (return code number elements) 
   which user may not want to know about (left over from my LP code) 
Get rid of all memory
</member>
        <member name="M:CoinFactorization.sparseThreshold(System.Int32)">
set sparse threshold 
</member>
        <member name="M:CoinFactorization.sparseThreshold">
get sparse threshold 
</member>
        <member name="M:CoinFactorization.goSparse">
makes a row copy of L for speed and to allow very sparse problems 
</member>
        <member name="M:CoinFactorization.updateTwoColumnsTranspose(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,System.Int32)">
Updates two columns (BTRAN) from regionSparse2 and 3
      regionSparse starts as zero and is zero at end 
      Note - if regionSparse2 packed on input - will be packed on output - same for 3

</member>
        <member name="M:CoinFactorization.updateOneColumnTranspose(CoinIndexedVector*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Part of twocolumnsTranspose
</member>
        <member name="M:CoinFactorization.updateColumnTranspose(CoinIndexedVector*,CoinIndexedVector*)">
Updates one column (BTRAN) from regionSparse2
      regionSparse starts as zero and is zero at end 
      Note - if regionSparse2 packed on input - will be packed on output

</member>
        <member name="M:CoinFactorization.updateTwoColumnsFT(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
Updates one column (FTRAN) from region2
      Tries to do FT update
      number returned is negative if no room.
      Also updates region3
      region1 starts as zero and is zero at end 
</member>
        <member name="M:CoinFactorization.updateColumn(CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
This version has same effect as above with FTUpdate==false
      so number returned is always &gt;=0 
</member>
        <member name="M:CoinFactorization.updateColumnFT(CoinIndexedVector*,CoinIndexedVector*)">
@name various uses of factorization (return code number elements) 
   which user may want to know about 
Updates one column (FTRAN) from regionSparse2
      Tries to do FT update
      number returned is negative if no room
      regionSparse starts as zero and is zero at end.
      Note - if regionSparse2 packed on input - will be packed on output

</member>
        <member name="M:CoinFactorization.replaceColumnU(CoinIndexedVector*,System.Int32*,System.Int32)">
Combines BtranU and delete elements
      If deleted is NULL then delete elements
      otherwise store where elements are

</member>
        <member name="M:CoinFactorization.replaceColumn(CoinIndexedVector*,System.Int32,System.Double,System.Boolean,System.Double)">
@name rank one updates which do exist 
Replaces one Column to basis,
   returns 0=OK, 1=Probably OK, 2=singular, 3=no room
      If checkBeforeModifying is true will do all accuracy checks
      before modifying factorization.  Whether to set this depends on
      speed considerations.  You could just do this on first iteration
      after factorization and thereafter re-factorize
   partial update already in U 
</member>
        <member name="M:CoinFactorization.persistenceFlag">
Array persistence flag
      If 0 then as now (delete/new)
      1 then only do arrays if bigger needed
      2 as 1 but give a bit extra if bigger needed

</member>
        <member name="M:CoinFactorization.biasLU">
L to U bias
      0 - U bias, 1 - some U bias, 2 some L bias, 3 L bias

</member>
        <member name="M:CoinFactorization.maximumColumnsExtra">
Maximum number of Columns after iterating
</member>
        <member name="M:CoinFactorization.startColumnU">
Start of each column in U
</member>
        <member name="M:CoinFactorization.indexRowU">
Row indices of U
</member>
        <member name="M:CoinFactorization.elementU">
Elements of U
</member>
        <member name="M:CoinFactorization.numberInColumn">
Number of entries in each column
</member>
        <member name="M:CoinFactorization.numberInRow">
Number of entries in each row
</member>
        <member name="M:CoinFactorization.numberCompressions">
Number of compressions done
</member>
        <member name="M:CoinFactorization.numberElementsR">
Returns number in R area
</member>
        <member name="M:CoinFactorization.lengthAreaL">
Returns length of L area
</member>
        <member name="M:CoinFactorization.numberElementsL">
Returns number in L area
</member>
        <member name="M:CoinFactorization.lengthAreaU">
Returns length of U area
</member>
        <member name="M:CoinFactorization.setNumberElementsU(System.Int32)">
Setss number in U area
</member>
        <member name="M:CoinFactorization.numberElementsU">
Returns number in U area
</member>
        <member name="M:CoinFactorization.numberDense">
@name some simple stuff 
Returns number of dense rows
</member>
        <member name="M:CoinFactorization.spaceForForrestTomlin">
True if FT update and space
</member>
        <member name="M:CoinFactorization.forrestTomlin">
true if Forrest Tomlin update, false if PFI
</member>
        <member name="M:CoinFactorization.maximumCoefficient">
Returns maximum absolute value in factorization
</member>
        <member name="M:CoinFactorization.slackValue">
Whether slack value is +1 or -1
</member>
        <member name="M:CoinFactorization.zeroTolerance">
Zero tolerance
</member>
        <member name="M:CoinFactorization.pivotTolerance">
Pivot tolerance
</member>
        <member name="M:CoinFactorization.setDenseThreshold(System.Int32)">
Sets dense threshold
</member>
        <member name="M:CoinFactorization.denseThreshold">
Gets dense threshold
</member>
        <member name="M:CoinFactorization.maximumPivots">
Maximum number of pivots between factorizations
</member>
        <member name="M:CoinFactorization.messageLevel">
Level of detail of messages
</member>
        <member name="M:CoinFactorization.relaxAccuracyCheck(System.Double)">
Allows change of pivot accuracy check 1.0 == none &gt;1.0 relaxed
</member>
        <member name="M:CoinFactorization.adjustedAreaFactor">
Returns areaFactor but adjusted for dense
</member>
        <member name="M:CoinFactorization.areaFactor">
Whether larger areas needed
</member>
        <member name="M:CoinFactorization.numberGoodColumns">
Number of good columns in factorization
</member>
        <member name="M:CoinFactorization.numberForrestTomlin">
Length of FT vector
</member>
        <member name="M:CoinFactorization.numberElements">
Total number of elements in factorization
</member>
        <member name="M:CoinFactorization.numberColumns">
Total number of columns in factorization
</member>
        <member name="M:CoinFactorization.maximumRowsExtra">
Maximum of Rows after iterating
</member>
        <member name="M:CoinFactorization.baseL">
Base of L
</member>
        <member name="M:CoinFactorization.numberL">
Number in L
</member>
        <member name="M:CoinFactorization.numberRows">
Number of Rows after factorization
</member>
        <member name="M:CoinFactorization.setNumberRows(System.Int32)">
Set number of Rows after factorization
</member>
        <member name="M:CoinFactorization.numberRowsExtra">
Number of Rows after iterating
</member>
        <member name="M:CoinFactorization.elementByRowL">
Elements in L (row copy)
</member>
        <member name="M:CoinFactorization.indexRowL">
Row indices of L
</member>
        <member name="M:CoinFactorization.indexColumnL">
Index of column in row for L
</member>
        <member name="M:CoinFactorization.startColumnL">
Start of each column in L
</member>
        <member name="M:CoinFactorization.startRowL">
Start of each row in L
</member>
        <member name="M:CoinFactorization.pivotColumnBack">
Returns address of pivotColumnBack region (also used for permuting)
      Now uses firstCount to save memory allocation 
</member>
        <member name="M:CoinFactorization.lastRow">
Returns address of lastRow region
</member>
        <member name="M:CoinFactorization.permuteBack">
Returns address of permuteBack region
</member>
        <member name="M:CoinFactorization.pivotRegion">
Returns address of pivot region
</member>
        <member name="M:CoinFactorization.pivotColumn">
Returns address of pivotColumn region (also used for permuting)
</member>
        <member name="M:CoinFactorization.permute">
Returns address of permute region
</member>
        <member name="M:CoinFactorization.setPivots(System.Int32)">
Sets number of pivots since factorization
</member>
        <member name="M:CoinFactorization.pivots">
Returns number of pivots since factorization
</member>
        <member name="M:CoinFactorization.setStatus(System.Int32)">
Sets status
</member>
        <member name="M:CoinFactorization.status">
@name general stuff such as permutation or status 
Returns status
</member>
        <member name="M:CoinFactorization.conditionNumber">
Condition number - product of pivots after factorization
</member>
        <member name="M:CoinFactorization.factorizePart2(System.Int32*,System.Int32)">
This is part two of factorization
      Arrays belong to factorization and were returned by part 1
      If status okay, permutation has pivot rows - this is only needed
      If status is singular, then basic variables have pivot row
      and ones thrown out have -1
      returns 0 -okay, -1 singular, -99 memory 
</member>
        <member name="M:CoinFactorization.factorizePart1(System.Int32,System.Int32,System.Int32,System.Int32**,System.Int32**,System.Double**,System.Double)">
Two part version for maximum flexibility
      This part creates arrays for user to fill.
      estimateNumberElements is safe estimate of number
      returns 0 -okay, -99 memory 
</member>
        <member name="M:CoinFactorization.factorize(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double)">
When given as triplets.
  Actually does factorization.  maximumL is guessed maximum size of L part of
  final factorization, maximumU of U part.  These are multiplied by
  areaFactor which can be computed by user or internally.  
  Arrays are copied in.  I could add flag to delete arrays to save a 
  bit of memory.
  If status okay, permutation has pivot rows - this is only needed
  If status is singular, then basic variables have pivot row
  and ones thrown out have -1
  returns 0 -okay, -1 singular, -99 memory 
</member>
        <member name="M:CoinFactorization.factorize(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Int32*,System.Double)">
@name Do factorization 
When part of LP - given by basic variables.
  Actually does factorization.
  Arrays passed in have non negative value to say basic.
  If status is okay, basic variables have pivot row - this is only needed
  If status is singular, then basic variables have pivot row
  and ones thrown out have -1
  returns 0 -okay, -1 singular, -2 too many in basis, -99 memory 
</member>
        <member name="M:CoinFactorization.op_Assign(CoinFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
= copy
</member>
        <member name="M:CoinFactorization.sort">
Debug - sort so can compare
</member>
        <member name="M:CoinFactorization.restoreFactorization(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Debug - restore from file - 0 if no error on file.
      If factor true then factorizes as if called from ClpFactorization

</member>
        <member name="M:CoinFactorization.saveFactorization(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Debug - save on file - 0 if no error
</member>
        <member name="M:CoinFactorization.show_self">
Debug show object (shows one representation)
</member>
        <member name="M:CoinFactorization.almostDestructor">
Delete all stuff (leaves as after CoinFactorization())
</member>
        <member name="M:CoinFactorization.Dispose">
Destructor
</member>
        <member name="M:CoinFactorization.#ctor(CoinFactorization!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CoinFactorization.#ctor">
@name Constructors and destructor and copy 
Default constructor
</member>
        <member name="T:CoinFactorization">
This deals with Factorization and Updates

    This class started with a parallel simplex code I was writing in the
    mid 90's.  The need for parallelism led to many complications and
    I have simplified as much as I could to get back to this.

    I was aiming at problems where I might get speed-up so I was looking at dense
    problems or ones with structure.  This led to permuting input and output
    vectors and to increasing the number of rows each rank-one update.  This is 
    still in as a minor overhead.

    I have also put in handling for hyper-sparsity.  I have taken out
    all outer loop unrolling, dense matrix handling and most of the
    book-keeping for slacks.  Also I always use FTRAN approach to updating
    even if factorization fairly dense.  All these could improve performance.

    I blame some of the coding peculiarities on the history of the code
    but mostly it is just because I can't do elegant code (or useful
    comments).

    I am assuming that 32 bits is enough for number of rows or columns, but CoinBigIndex
    may be redefined to get 64 bits.

</member>
        <member name="M:ClpMessage.#ctor(CoinMessages.Language)">
@name Constructors etc 
Constructor 
</member>
        <member name="T:ClpMessage">
This deals with Clp messages (as against Osi messages etc)

</member>
        <member name="M:getDoubleFromString(CoinYacc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double)">
faster version
</member>
        <member name="M:getFunctionValueFromString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double)">
Just function of single variable x
</member>
        <member name="F:CoinModel.links_">
Links present (could be tested by sizes of objects)
      0 - none,
      1 - row links,
      2 - column links,
      3 - both

</member>
        <member name="F:CoinModel.noNames_">
True if no names EVER being used (for users who know what they are doing)
</member>
        <member name="F:CoinModel.type_">
Type of build -
      -1 unset,
      0 for row, 
      1 for column,
      2 linked.
      3 matrix is CoinPackedMatrix (and at present can't be modified);

</member>
        <member name="F:CoinModel.moreInfo_">
Pointer to more information
</member>
        <member name="F:CoinModel.cut_">
Nonzero if row is cut - done in one go e.g. from ampl
</member>
        <member name="F:CoinModel.priority_">
priorities (given for all columns (-1 if not integer)
</member>
        <member name="F:CoinModel.referenceSOS_">
SOS reference
</member>
        <member name="F:CoinModel.prioritySOS_">
SOS priority
</member>
        <member name="F:CoinModel.typeSOS_">
SOS type
</member>
        <member name="F:CoinModel.memberSOS_">
SOS members
</member>
        <member name="F:CoinModel.startSOS_">
SOS starts
</member>
        <member name="F:CoinModel.numberSOS_">
Number of SOS - all these are done in one go e.g. from ampl
</member>
        <member name="F:CoinModel.associated_">
Associated values
</member>
        <member name="F:CoinModel.sizeAssociated_">
Size of associated values
</member>
        <member name="F:CoinModel.quadraticColumnList_">
Linked list for quadratic columns
</member>
        <member name="F:CoinModel.quadraticRowList_">
Linked list for quadratic rows
</member>
        <member name="F:CoinModel.sortSize_">
Size of sort arrays
</member>
        <member name="F:CoinModel.sortElements_">
Array for sorting elements
</member>
        <member name="F:CoinModel.sortIndices_">
Array for sorting indices
</member>
        <member name="F:CoinModel.hashQuadraticElements_">
Hash for quadratic elements
</member>
        <member name="F:CoinModel.quadraticElements_">
Actual quadratic elements (always linked lists)
</member>
        <member name="F:CoinModel.columnList_">
Linked list for columns
</member>
        <member name="F:CoinModel.rowList_">
Linked list for rows
</member>
        <member name="F:CoinModel.hashElements_">
Hash for elements
</member>
        <member name="F:CoinModel.packedMatrix_">
Actual elements as CoinPackedMatrix
</member>
        <member name="F:CoinModel.elements_">
Actual elements
</member>
        <member name="F:CoinModel.start_">
If simple then start of each row/column
</member>
        <member name="F:CoinModel.columnType_">
Column types.
      Has information - at present
      bit 0 - columnLower is a string
      bit 1 - columnUpper is a string
      bit 2 - objective is a string
      bit 3 - integer setting is a string
      NOTE - if converted to CoinPackedMatrix - may be indices of 
      original columns (i.e. when decomposed)

</member>
        <member name="F:CoinModel.string_">
Strings
</member>
        <member name="F:CoinModel.integerType_">
Integer information
</member>
        <member name="F:CoinModel.columnName_">
Column names
</member>
        <member name="F:CoinModel.columnUpper_">
Column Upper
</member>
        <member name="F:CoinModel.columnLower_">
Column Lower
</member>
        <member name="F:CoinModel.objective_">
Objective
</member>
        <member name="F:CoinModel.rowType_">
Row types.
      Has information - at present
      bit 0 - rowLower is a string
      bit 1 - rowUpper is a string
      NOTE - if converted to CoinPackedMatrix - may be indices of 
      original rows (i.e. when decomposed)

</member>
        <member name="F:CoinModel.rowName_">
Row names
</member>
        <member name="F:CoinModel.rowUpper_">
Row upper
</member>
        <member name="F:CoinModel.rowLower_">
Row lower
</member>
        <member name="F:CoinModel.maximumQuadraticElements_">
Maximum number of quadratic elements
</member>
        <member name="F:CoinModel.numberQuadraticElements_">
Current number of quadratic elements
</member>
        <member name="F:CoinModel.maximumElements_">
Maximum number of elements
</member>
        <member name="F:CoinModel.numberElements_">
Current number of elements
</member>
        <member name="F:CoinModel.maximumColumns_">
Maximum number of columns
</member>
        <member name="F:CoinModel.maximumRows_">
@name Data members 
Maximum number of rows
</member>
        <member name="M:CoinModel.badType">
Aborts with message about packedMatrix
</member>
        <member name="M:CoinModel.decodeBit(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
returns jColumn (-2 if linear term, -1 if unknown) and coefficient
</member>
        <member name="M:CoinModel.gdb(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Read a problem from AMPL nl file
      so not constructor so gdb will work

</member>
        <member name="M:CoinModel.setOriginalIndices(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)">
For decomposition set original row and column indices
</member>
        <member name="M:CoinModel.priorities">
priorities (given for all columns (-1 if not integer)
</member>
        <member name="M:CoinModel.setPriorities(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Sets priority array
</member>
        <member name="M:CoinModel.setCutMarker(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Sets cut marker array
</member>
        <member name="M:CoinModel.expandKnapsack(System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*,System.Int32*,System.Int32*,System.Double*,System.Int32)">
Expands out all possible combinations for a knapsack
      If buildObj NULL then just computes space needed - returns number elements
      On entry numberOutput is maximum allowed, on exit it is number needed or
      -1 (as will be number elements) if maximum exceeded.  numberOutput will have at
      least space to return values which reconstruct input.
      Rows returned will be original rows but no entries will be returned for
      any rows all of whose entries are in knapsack.  So up to user to allow for this.
      If reConstruct &gt;=0 then returns number of entrie which make up item "reConstruct"
      in expanded knapsack.  Values in buildRow and buildElement;

</member>
        <member name="M:CoinModel.reorder(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
If possible return a model where if all variables marked nonzero are fixed
      the problem will be linear.  At present may only work if quadratic.
      Returns NULL if not possible

</member>
        <member name="M:CoinModel.replaceQuadraticRow(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*)">
Replaces a quadratic row
</member>
        <member name="M:CoinModel.quadraticRow(System.Int32,System.Double*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets correct form for a quadratic row - user to delete
      If row is not quadratic then returns which other variables are involved
      with tiny (1.0e-100) elements and count of total number of variables which could not
      be put in quadratic form

</member>
        <member name="M:CoinModel.computeAssociated(System.Double*)">
Fills in all associated - returning number of errors
</member>
        <member name="M:CoinModel.freeStringMemory(CoinYacc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Frees value memory
</member>
        <member name="M:CoinModel.getDoubleFromString(CoinYacc*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Gets a double from a string possibly containing named strings,
      returns unset if not found

</member>
        <member name="M:CoinModel.addString(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Adds one string, returns index
</member>
        <member name="M:CoinModel.createList(System.Int32)">
Create a linked list and synchronize free 
      type 1 for row 2 for column
      Marked as const as list is mutable 
</member>
        <member name="M:CoinModel.fillList(System.Int32,CoinModelLinkedList*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Fill in default linked list information (1= row, 2 = column)
      Marked as const as list is mutable 
</member>
        <member name="M:CoinModel.fillColumns(System.Int32,System.Boolean,System.Boolean)">
Fill in default column information
</member>
        <member name="M:CoinModel.fillRows(System.Int32,System.Boolean,System.Boolean)">
Fill in default row information
</member>
        <member name="M:CoinModel.resize(System.Int32,System.Int32,System.Int32)">
Resize
</member>
        <member name="M:CoinModel.validateLinks">
@name For debug 
Checks that links are consistent
</member>
        <member name="M:CoinModel.op_Assign(CoinModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
=
</member>
        <member name="M:CoinModel.#ctor(CoinModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:CoinModel.Dispose">
Destructor 
</member>
        <member name="M:CoinModel.clone">
Clone
</member>
        <member name="M:CoinModel.#ctor(System.Int32,System.Int32,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
From arrays
</member>
        <member name="M:CoinModel.#ctor(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Void!System.Runtime.CompilerServices.IsConst*)">
Read a problem from AMPL nl file
       NOTE - as I can't work out configure etc the source code is in Cbc_ampl.cpp!

</member>
        <member name="M:CoinModel.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Read a problem in MPS or GAMS format from the given filename.

</member>
        <member name="M:CoinModel.#ctor(System.Int32,System.Int32,System.Int32,System.Boolean)">
Constructor with sizes. 
</member>
        <member name="M:CoinModel.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:CoinModel.loadBlock(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
@name for block models - matrix will be CoinPackedMatrix 
</member>
        <member name="M:CoinModel.whatIsSet">
Returns which parts of model are set
      1 - matrix
      2 - rhs
      4 - row names
      8 - column bounds and/or objective
      16 - column names
      32 - integer types

</member>
        <member name="M:CoinModel.setMoreInfo(System.Void*)">
Set pointer to more information
</member>
        <member name="M:CoinModel.moreInfo">
Return pointer to more information
</member>
        <member name="M:CoinModel.setOptimizationDirection(System.Double)">
Set direction of optimization (1 - minimize, -1 - maximize, 0 - ignore
</member>
        <member name="M:CoinModel.optimizationDirection">
Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore
</member>
        <member name="M:CoinModel.cutMarker">
Returns array of 0 or nonzero if can be a cut (or returns NULL)
</member>
        <member name="M:CoinModel.zapColumnNames">
Reset column names
</member>
        <member name="M:CoinModel.zapRowNames">
Reset row names
</member>
        <member name="M:CoinModel.columnNames">
Return column names array
</member>
        <member name="M:CoinModel.rowNames">
Return row names array
</member>
        <member name="M:CoinModel.integerTypeArray">
Return integerType array
</member>
        <member name="M:CoinModel.objectiveArray">
Return objective array
</member>
        <member name="M:CoinModel.columnUpperArray">
Return columnUpper array
</member>
        <member name="M:CoinModel.columnLowerArray">
Return columnLower array
</member>
        <member name="M:CoinModel.rowUpperArray">
Return rowUpper array
</member>
        <member name="M:CoinModel.rowLowerArray">
Return rowLower array
</member>
        <member name="M:CoinModel.associatedArray">
Returns associated array
</member>
        <member name="M:CoinModel.stringArray">
Return string array
</member>
        <member name="M:CoinModel.stringsExist">
Says if strings exist
</member>
        <member name="M:CoinModel.createArrays(System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates copies of various arrays - return number of errors
</member>
        <member name="M:CoinModel.createPlusMinusOne(System.Int32*,System.Int32*,System.Int32*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Creates +-1 matrix given startPositive and startNegative counts for +-1 matrix.

</member>
        <member name="M:CoinModel.countPlusMinusOne(System.Int32*,System.Int32*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Fills in startPositive and startNegative with counts for +-1 matrix.
      If not +-1 then startPositive[0]==-1 otherwise counts and
      startPositive[numberColumns]== size
      - return number of errors

</member>
        <member name="M:CoinModel.createPackedMatrix(CoinPackedMatrix*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*)">
Creates a packed matrix - return number of errors
</member>
        <member name="M:CoinModel.unsetValue">
returns unset value
</member>
        <member name="M:CoinModel.type">
Returns type
</member>
        <member name="M:CoinModel.column(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Column index from column name (-1 if no names or no match)
</member>
        <member name="M:CoinModel.row(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Row index from row name (-1 if no names or no match)
</member>
        <member name="M:CoinModel.isIntegerAsString(System.Int32)">
Gets if integer (if column does not exist then false)

</member>
        <member name="M:CoinModel.columnIsIntegerAsString(System.Int32)">
Gets if integer (if column does not exist then false)

</member>
        <member name="M:CoinModel.objectiveAsString(System.Int32)">
Gets columnObjective (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.columnObjectiveAsString(System.Int32)">
Gets columnObjective (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.columnUpperAsString(System.Int32)">
Gets columnUpper (if column does not exist then COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.columnLowerAsString(System.Int32)">
Gets columnLower (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.getColumnIsIntegerAsString(System.Int32)">
Gets if integer (if column does not exist then false)

</member>
        <member name="M:CoinModel.getColumnObjectiveAsString(System.Int32)">
Gets columnObjective (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.getColumnUpperAsString(System.Int32)">
Gets columnUpper (if column does not exist then COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getColumnLowerAsString(System.Int32)">
Gets columnLower (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.rowUpperAsString(System.Int32)">
Gets rowUpper (if row does not exist then COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getRowUpperAsString(System.Int32)">
Gets rowUpper (if row does not exist then +COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getRowLowerAsString(System.Int32)">
Gets rowLower (if row does not exist then -COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getColIsInteger(System.Int32)">
Gets if integer (if column does not exist then false)

</member>
        <member name="M:CoinModel.getColName(System.Int32)">
Gets name (if column does not exist then NULL)

</member>
        <member name="M:CoinModel.getColObjective(System.Int32)">
Gets columnObjective (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.getColUpper(System.Int32)">
Gets columnUpper (if column does not exist then COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getColLower(System.Int32)">
Gets columnLower (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.isInteger(System.Int32)">
Gets if integer (if column does not exist then false)

</member>
        <member name="M:CoinModel.columnIsInteger(System.Int32)">
Gets if integer (if column does not exist then false)

</member>
        <member name="M:CoinModel.columnName(System.Int32)">
Gets name (if column does not exist then NULL)

</member>
        <member name="M:CoinModel.objective(System.Int32)">
Gets columnObjective (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.columnObjective(System.Int32)">
Gets columnObjective (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.columnUpper(System.Int32)">
Gets columnUpper (if column does not exist then COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.columnLower(System.Int32)">
Gets columnLower (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.getColumnIsInteger(System.Int32)">
Gets if integer (if column does not exist then false)

</member>
        <member name="M:CoinModel.getColumnName(System.Int32)">
Gets name (if column does not exist then NULL)

</member>
        <member name="M:CoinModel.getColumnObjective(System.Int32)">
Gets columnObjective (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.getColumnUpper(System.Int32)">
Gets columnUpper (if column does not exist then COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getColumnLower(System.Int32)">
Gets columnLower (if column does not exist then 0.0)

</member>
        <member name="M:CoinModel.rowName(System.Int32)">
Gets name (if row does not exist then NULL)

</member>
        <member name="M:CoinModel.rowUpper(System.Int32)">
Gets rowUpper (if row does not exist then COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getRowName(System.Int32)">
Gets name (if row does not exist then NULL)

</member>
        <member name="M:CoinModel.getRowUpper(System.Int32)">
Gets rowUpper (if row does not exist then +COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.getRowLower(System.Int32)">
Gets rowLower (if row does not exist then -COIN_DBL_MAX)

</member>
        <member name="M:CoinModel.lastInQuadraticColumn(System.Int32)">
Returns last element in given quadratic column - index is -1 if none.
      Index is given by .index and value by .value

</member>
        <member name="M:CoinModel.firstInQuadraticColumn(System.Int32)">
Returns first element in given quadratic column - index is -1 if none.
      Index is given by .index and value by .value
      May not be correct if matrix updated.

</member>
        <member name="M:CoinModel.previous(CoinModelLink*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns previous element in current row or column - index is -1 if none.
      Index is given by .index and value by .value.
      User could also tell because input.previous would be NULL
      May not be correct if matrix updated.

</member>
        <member name="M:CoinModel.next(CoinModelLink*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns next element in current row or column - index is -1 if none.
      Index is given by .index and value by .value.
      User could also tell because input.next would be NULL

</member>
        <member name="M:CoinModel.lastInColumn(System.Int32)">
Returns last element in given column - index is -1 if none.
      Index is given by .index and value by .value

</member>
        <member name="M:CoinModel.firstInColumn(System.Int32)">
Returns first element in given column - index is -1 if none.
      Index is given by .index and value by .value

</member>
        <member name="M:CoinModel.lastInRow(System.Int32)">
Returns last element in given row - index is -1 if none.
      Index is given by .index and value by .value

</member>
        <member name="M:CoinModel.firstInRow(System.Int32)">
Returns first element in given row - index is -1 if none.
      Index is given by .index and value by .value

</member>
        <member name="M:CoinModel.position(System.Int32,System.Int32)">
Returns position in elements for row i column j.
      Only valid until next modification. 
      -1 if element does not exist 
</member>
        <member name="M:CoinModel.pointer(System.Int32,System.Int32)">
Returns pointer to element for row i column j.
      Only valid until next modification. 
      NULL if element does not exist 
</member>
        <member name="M:CoinModel.getElementAsString(System.Int32,System.Int32)">
Returns value for row i and column j as string.
      Returns NULL if does not exist.
      Returns "Numeric" if not a string

</member>
        <member name="M:CoinModel.getQuadraticElement(System.Int32,System.Int32)">
Returns quadratic value for columns i and j
</member>
        <member name="M:CoinModel.getElement(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns value for row rowName and column columnName
</member>
        <member name="M:CoinModel.op_FunctionCall(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns value for row rowName and column columnName
</member>
        <member name="M:CoinModel.getElement(System.Int32,System.Int32)">
Returns value for row i and column j
</member>
        <member name="M:CoinModel.op_FunctionCall(System.Int32,System.Int32)">
Returns value for row i and column j
</member>
        <member name="M:CoinModel.elements">
Return  elements as triples
</member>
        <member name="M:CoinModel.numberElements">
@name For getting information 
Return number of elements
</member>
        <member name="M:CoinModel.originalColumns">
Return pointers to original columns (for decomposition)
</member>
        <member name="M:CoinModel.originalRows">
Return pointers to original rows (for decomposition)
</member>
        <member name="M:CoinModel.packedMatrix">
Return a pointer to CoinPackedMatrix (or NULL)
</member>
        <member name="M:CoinModel.convertMatrix">
Convert elements to CoinPackedMatrix (and switch off element updates).
      Returns number of errors 
</member>
        <member name="M:CoinModel.passInMatrix(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name For structured models 
Pass in CoinPackedMatrix (and switch off element updates)
</member>
        <member name="M:CoinModel.differentModel(CoinModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Check two models against each other.  Return nonzero if different.
      Ignore names if that set.
      May modify both models by cleaning up

</member>
        <member name="M:CoinModel.setRowUpper(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Sets rowUpper array

</member>
        <member name="M:CoinModel.setRowLower(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Sets rowLower array

</member>
        <member name="M:CoinModel.setColUpper(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Sets columnUpper array

</member>
        <member name="M:CoinModel.setColumnUpper(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Sets columnUpper array

</member>
        <member name="M:CoinModel.setColLower(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Sets columnLower array

</member>
        <member name="M:CoinModel.setColumnLower(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Sets columnLower array

</member>
        <member name="M:CoinModel.setObjective(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Sets columnObjective array

</member>
        <member name="M:CoinModel.pack">
Packs down all rows and columns.  i.e. removes empty rows and columns permanently.
      Empty rows have no elements and feasible bounds.
      Empty columns have no elements and no objective.
      returns number of rows+columns deleted. 
</member>
        <member name="M:CoinModel.packCols">
Packs down all columns i.e. removes empty columns permanently.  Empty columns
      have no elements and no objective. returns number of columns deleted. 
</member>
        <member name="M:CoinModel.packColumns">
Packs down all columns i.e. removes empty columns permanently.  Empty columns
      have no elements and no objective. returns number of columns deleted. 
</member>
        <member name="M:CoinModel.packRows">
Packs down all rows i.e. removes empty rows permanently.  Empty rows
      have no elements and feasible bounds. returns number of rows deleted. 
</member>
        <member name="M:CoinModel.deleteThisElement(System.Int32,System.Int32,System.Int32)">
Takes element out of matrix when position known
</member>
        <member name="M:CoinModel.deleteCol(System.Int32)">
Deletes all entries in column and bounds.  If last column the number of columns
      will be decremented and true returned.  
</member>
        <member name="M:CoinModel.deleteColumn(System.Int32)">
Deletes all entries in column and bounds and objective.  Will be ignored by
      writeMps etc and will be packed down if asked for. 
</member>
        <member name="M:CoinModel.deleteRow(System.Int32)">
Deletes all entries in row and bounds.  Will be ignored by
      writeMps etc and will be packed down if asked for. 
</member>
        <member name="M:CoinModel.setIsInteger(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets integer (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setObjective(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets columnObjective (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnIsInteger(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets integer (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnObjective(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets columnObjective (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnUpper(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets columnUpper (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnLower(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets columnLower (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setRowUpper(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets rowUpper (if row does not exist then
      all rows up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setRowLower(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets rowLower (if row does not exist then
      all rows up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColIsInteger(System.Int32,System.Boolean)">
Sets integer (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColName(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets name (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColObjective(System.Int32,System.Double)">
Sets columnObjective (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColBounds(System.Int32,System.Double,System.Double)">
Sets columnLower and columnUpper (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColUpper(System.Int32,System.Double)">
Sets columnUpper (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColLower(System.Int32,System.Double)">
Sets columnLower (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setContinuous(System.Int32)">
Sets continuous (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setInteger(System.Int32)">
Sets integer (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setIsInteger(System.Int32,System.Boolean)">
Sets integer state (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setObjective(System.Int32,System.Double)">
Sets columnObjective (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnIsInteger(System.Int32,System.Boolean)">
Sets integer state (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnName(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets name (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnObjective(System.Int32,System.Double)">
Sets columnObjective (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnBounds(System.Int32,System.Double,System.Double)">
Sets columnLower and columnUpper (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnUpper(System.Int32,System.Double)">
Sets columnUpper (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setColumnLower(System.Int32,System.Double)">
Sets columnLower (if column does not exist then
      all columns up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setRowName(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets name (if row does not exist then
      all rows up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setRowBounds(System.Int32,System.Double,System.Double)">
Sets rowLower and rowUpper (if row does not exist then
      all rows up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setRowUpper(System.Int32,System.Double)">
Sets rowUpper (if row does not exist then
      all rows up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.setRowLower(System.Int32,System.Double)">
Sets rowLower (if row does not exist then
      all rows up to this are defined with default values and no elements)

</member>
        <member name="M:CoinModel.associateElement(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double)">
Associates a string with a value.  Returns string id (or -1 if does not exist)
</member>
        <member name="M:CoinModel.setElement(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets value for row i and column j as string
</member>
        <member name="M:CoinModel.op_FunctionCall(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Sets value for row i and column j as string
</member>
        <member name="M:CoinModel.setQuadraticElement(System.Int32,System.Int32,System.Double)">
Sets quadratic value for column i and j
</member>
        <member name="M:CoinModel.getColumn(System.Int32,System.Int32*,System.Double*)">
Gets sorted column - user must provide enough space 
      (easiest is allocate number of rows).
      If row or element NULL then just returns number
      Returns number of elements

</member>
        <member name="M:CoinModel.getRow(System.Int32,System.Int32*,System.Double*)">
Gets sorted row - user must provide enough space 
      (easiest is allocate number of columns).
      If column or element NULL then just returns number
      Returns number of elements

</member>
        <member name="M:CoinModel.setElement(System.Int32,System.Int32,System.Double)">
Sets value for row i and column j
</member>
        <member name="M:CoinModel.op_FunctionCall(System.Int32,System.Int32,System.Double)">
Sets value for row i and column j
</member>
        <member name="M:CoinModel.addCol(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double,System.Double,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
add a column - numberInColumn may be zero */
</member>
        <member name="M:CoinModel.addColumn(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double,System.Double,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
add a column - numberInColumn may be zero */
</member>
        <member name="M:CoinModel.addRow(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@name Useful methods for building model 
add a row -  numberInRow may be zero 
</member>
        <member name="T:CoinModel">
    This is a simple minded model which is stored in a format which makes
    it easier to construct and modify but not efficient for algorithms.  It has
    to be passed across to ClpModel or OsiSolverInterface by addRows, addCol(umn)s
    or loadProblem.

    It may have up to four parts -
    1) A matrix of doubles (or strings - see note A)
    2) Column information including integer information and names
    3) Row information including names
    4) Quadratic objective (not implemented - but see A)

    This class is meant to make it more efficient to build a model.  It is at
    its most efficient when all additions are done as addRow or as addCol but
    not mixed.  If only 1 and 2 exist then solver.addColumns may be used to pass to solver,
    if only 1 and 3 exist then solver.addRows may be used.  Otherwise solver.loadProblem
    must be used.

    If addRows and addColumns are mixed or if individual elements are set then the
    speed will drop to some extent and more memory will be used.

    It is also possible to iterate over existing elements and to access columns and rows
    by name.  Again each of these use memory and cpu time.  However memory is unlikely
    to be critical as most algorithms will use much more.

    Notes:
    A)  Although this could be used to pass nonlinear information around the
        only use at present is to have named values e.g. value1 which can then be
        set to a value after model is created.  I have no idea whether that could
        be useful but I thought it might be fun.
	Quadratic terms are allowed in strings!  A solver could try and use this
	if so - the convention is that 0.5* quadratic is stored
	
    B)  This class could be useful for modeling.

</member>
        <member name="F:CoinBaseModel.logLevel_">
Print level.
      I could have gone for full message handling but this should normally
      be silent and lightweight.
      -1 - use passed in message handler
      0 - no output
      1 - on errors
      2 - more detailed

</member>
        <member name="F:CoinBaseModel.messages_">
Messages
</member>
        <member name="F:CoinBaseModel.handler_">
Message handler (Passed in)
</member>
        <member name="F:CoinBaseModel.columnBlockName_">
Columnblock name
</member>
        <member name="F:CoinBaseModel.rowBlockName_">
Rowblock name
</member>
        <member name="F:CoinBaseModel.problemName_">
Problem name
</member>
        <member name="F:CoinBaseModel.objectiveOffset_">
Objective offset to be passed on
</member>
        <member name="F:CoinBaseModel.optimizationDirection_">
Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore
</member>
        <member name="F:CoinBaseModel.numberColumns_">
Current number of columns
</member>
        <member name="F:CoinBaseModel.numberRows_">
@name Data members 
Current number of rows
</member>
        <member name="M:CoinBaseModel.setMessageHandler(CoinMessageHandler*)">
Pass in message handler
</member>
        <member name="M:CoinBaseModel.setColumnBlock(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set column block name
</member>
        <member name="M:CoinBaseModel.getColumnBlock">
Return the column block name
</member>
        <member name="M:CoinBaseModel.setRowBlock(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set row block name
</member>
        <member name="M:CoinBaseModel.getRowBlock">
Return the row block name
</member>
        <member name="M:CoinBaseModel.setProblemName(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set problem name
</member>
        <member name="M:CoinBaseModel.setProblemName(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Set problem name
</member>
        <member name="M:CoinBaseModel.getProblemName">
Return the problem name
</member>
        <member name="M:CoinBaseModel.setLogLevel(System.Int32)">
Set print level 0 - off, 1 - errors, 2 - more
</member>
        <member name="M:CoinBaseModel.logLevel">
Get print level 0 - off, 1 - errors, 2 - more
</member>
        <member name="M:CoinBaseModel.setOptimizationDirection(System.Double)">
Set direction of optimization (1 - minimize, -1 - maximize, 0 - ignore
</member>
        <member name="M:CoinBaseModel.optimizationDirection">
Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore
</member>
        <member name="M:CoinBaseModel.setObjectiveOffset(System.Double)">
Set objective offset
</member>
        <member name="M:CoinBaseModel.objectiveOffset">
Returns the (constant) objective offset
      This is the RHS entry for the objective row

</member>
        <member name="M:CoinBaseModel.numberElements">
Return number of elements
</member>
        <member name="M:CoinBaseModel.numberColumns">
Return number of columns
</member>
        <member name="M:CoinBaseModel.numberRows">
@name For getting information 
Return number of rows
</member>
        <member name="M:CoinBaseModel.Dispose">
Destructor
</member>
        <member name="M:CoinBaseModel.clone">
Clone
</member>
        <member name="M:CoinBaseModel.op_Assign(CoinBaseModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CoinBaseModel.#ctor(CoinBaseModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CoinBaseModel.#ctor">
@name Constructors, destructor 
Default Constructor
</member>
        <member name="F:CoinModelLinkedList.type_">
0 row list, 1 column list
</member>
        <member name="F:CoinModelLinkedList.maximumElements_">
Maximum number of elements
</member>
        <member name="F:CoinModelLinkedList.numberElements_">
Number of elements
</member>
        <member name="F:CoinModelLinkedList.maximumMajor_">
Maximum number of major items i.e. rows if just row links
</member>
        <member name="F:CoinModelLinkedList.numberMajor_">
Number of major items i.e. rows if just row links
</member>
        <member name="F:CoinModelLinkedList.last_">
Last - maximumMajor+1 long (last free element chain)
</member>
        <member name="F:CoinModelLinkedList.first_">
First - maximumMajor+1 long (last free element chain)
</member>
        <member name="F:CoinModelLinkedList.next_">
Next - maximumElements long
</member>
        <member name="F:CoinModelLinkedList.previous_">
@name Data members 
Previous - maximumElements long
</member>
        <member name="M:CoinModelLinkedList.validateLinks(CoinModelTriple!System.Runtime.CompilerServices.IsConst*)">
Checks that links are consistent
</member>
        <member name="M:CoinModelLinkedList.synchronize(CoinModelLinkedList*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Puts in free list from other list 
</member>
        <member name="M:CoinModelLinkedList.fill(System.Int32,System.Int32)">
Fills first,last with -1
</member>
        <member name="M:CoinModelLinkedList.updateDeletedOne(System.Int32,CoinModelTriple!System.Runtime.CompilerServices.IsConst*)">
Update column list for one element when
      one element deleted from row copy

</member>
        <member name="M:CoinModelLinkedList.deleteRowOne(System.Int32,CoinModelTriple*,CoinModelHash2*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Deletes one element from Row list

</member>
        <member name="M:CoinModelLinkedList.updateDeleted(System.Int32,CoinModelTriple*,CoinModelLinkedList*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Deletes from list - other case i.e. delete row from column list
      This is when elements have been deleted from other copy

</member>
        <member name="M:CoinModelLinkedList.deleteSame(System.Int32,CoinModelTriple*,CoinModelHash2*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Deletes from list - same case i.e. delete row from row list

</member>
        <member name="M:CoinModelLinkedList.addHard(System.Int32,CoinModelTriple!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Adds to list - hard case i.e. add row to column list
      This is when elements have been added to other copy

</member>
        <member name="M:CoinModelLinkedList.addHard(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinModelTriple*,CoinModelHash2*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds to list - hard case i.e. add row to column list

</member>
        <member name="M:CoinModelLinkedList.addEasy(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinModelTriple*,CoinModelHash2*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name does work 
Adds to list - easy case i.e. add row to row list
      Returns where chain starts

</member>
        <member name="M:CoinModelLinkedList.previous">
Previous array
</member>
        <member name="M:CoinModelLinkedList.next">
Next array
</member>
        <member name="M:CoinModelLinkedList.last(System.Int32)">
Last on  chain
</member>
        <member name="M:CoinModelLinkedList.first(System.Int32)">
First on  chain
</member>
        <member name="M:CoinModelLinkedList.lastFree">
Last on free chain
</member>
        <member name="M:CoinModelLinkedList.firstFree">
First on free chain
</member>
        <member name="M:CoinModelLinkedList.maximumElements">
Maximum number of elements
</member>
        <member name="M:CoinModelLinkedList.numberElements">
Number of elements
</member>
        <member name="M:CoinModelLinkedList.maximumMajor">
Maximum number of major items i.e. rows if just row links
</member>
        <member name="M:CoinModelLinkedList.numberMajor">
Number of major items i.e. rows if just row links
</member>
        <member name="M:CoinModelLinkedList.create(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,CoinModelTriple!System.Runtime.CompilerServices.IsConst*)">
Create list - for row list maxMajor is maximum rows.
      type 0 row list, 1 column list

</member>
        <member name="M:CoinModelLinkedList.resize(System.Int32,System.Int32)">
@name sizing (just increases) 
Resize list - for row list maxMajor is maximum rows.

</member>
        <member name="M:CoinModelLinkedList.op_Assign(CoinModelLinkedList!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
=
</member>
        <member name="M:CoinModelLinkedList.#ctor(CoinModelLinkedList!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:CoinModelLinkedList.Dispose">
Destructor 
</member>
        <member name="M:CoinModelLinkedList.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="F:CoinModelHash2.lastSlot_">
Last slot looked at
</member>
        <member name="F:CoinModelHash2.maximumItems_">
Maximum number of items
</member>
        <member name="F:CoinModelHash2.numberItems_">
Number of items
</member>
        <member name="F:CoinModelHash2.hash_">
@name Data members 
hash
</member>
        <member name="M:CoinModelHash2.hashValue(System.Int32,System.Int32)">
Returns a hash value
</member>
        <member name="M:CoinModelHash2.deleteHash(System.Int32,System.Int32,System.Int32)">
Deletes from hash
</member>
        <member name="M:CoinModelHash2.addHash(System.Int32,System.Int32,System.Int32,CoinModelTriple!System.Runtime.CompilerServices.IsConst*)">
Adds to hash
</member>
        <member name="M:CoinModelHash2.hash(System.Int32,System.Int32,CoinModelTriple!System.Runtime.CompilerServices.IsConst*)">
@name hashing 
Returns index or -1
</member>
        <member name="M:CoinModelHash2.maximumItems">
Maximum number of items
</member>
        <member name="M:CoinModelHash2.setNumberItems(System.Int32)">
Set number of items
</member>
        <member name="M:CoinModelHash2.numberItems">
Number of items
</member>
        <member name="M:CoinModelHash2.resize(System.Int32,CoinModelTriple!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
@name sizing (just increases) 
Resize hash (also re-hashs)
</member>
        <member name="M:CoinModelHash2.op_Assign(CoinModelHash2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
=
</member>
        <member name="M:CoinModelHash2.#ctor(CoinModelHash2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:CoinModelHash2.Dispose">
Destructor 
</member>
        <member name="M:CoinModelHash2.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="T:CoinModelHash2">
For int,int hashing
</member>
        <member name="F:CoinModelHash.lastSlot_">
Last slot looked at
</member>
        <member name="F:CoinModelHash.maximumItems_">
Maximum number of items
</member>
        <member name="F:CoinModelHash.numberItems_">
Number of items
</member>
        <member name="F:CoinModelHash.hash_">
hash
</member>
        <member name="F:CoinModelHash.names_">
@name Data members 
Names
</member>
        <member name="M:CoinModelHash.hashValue(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns a hash value
</member>
        <member name="M:CoinModelHash.validateHash">
Validates
</member>
        <member name="M:CoinModelHash.setName(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Sets name at position (does not create)
</member>
        <member name="M:CoinModelHash.getName(System.Int32)">
Returns non const name at position (or NULL)
</member>
        <member name="M:CoinModelHash.name(System.Int32)">
Returns name at position (or NULL)
</member>
        <member name="M:CoinModelHash.deleteHash(System.Int32)">
Deletes from hash
</member>
        <member name="M:CoinModelHash.addHash(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Adds to hash
</member>
        <member name="M:CoinModelHash.hash(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@name hashing 
Returns index or -1
</member>
        <member name="M:CoinModelHash.names">
Names
</member>
        <member name="M:CoinModelHash.maximumItems">
Maximum number of items
</member>
        <member name="M:CoinModelHash.setNumberItems(System.Int32)">
Set number of items
</member>
        <member name="M:CoinModelHash.numberItems">
Number of items i.e. rows if just row names
</member>
        <member name="M:CoinModelHash.resize(System.Int32,System.Boolean)">
@name sizing (just increases) 
Resize hash (also re-hashs)
</member>
        <member name="M:CoinModelHash.op_Assign(CoinModelHash!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
=
</member>
        <member name="M:CoinModelHash.#ctor(CoinModelHash!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:CoinModelHash.Dispose">
Destructor 
</member>
        <member name="M:CoinModelHash.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="T:symrec">
For string evaluation
</member>
        <member name="F:CoinModelLink.onRow_">
If on row chain
</member>
        <member name="F:CoinModelLink.position_">
Position in data
</member>
        <member name="F:CoinModelLink.value_">
Value as double
</member>
        <member name="F:CoinModelLink.column_">
Column
</member>
        <member name="F:CoinModelLink.row_">
@name Data members 
Row
</member>
        <member name="M:CoinModelLink.setOnRow(System.Boolean)">
Set onRow
</member>
        <member name="M:CoinModelLink.setPosition(System.Int32)">
Set position
</member>
        <member name="M:CoinModelLink.setElement(System.Double)">
Set value
</member>
        <member name="M:CoinModelLink.setValue(System.Double)">
Set value
</member>
        <member name="M:CoinModelLink.setColumn(System.Int32)">
Set column
</member>
        <member name="M:CoinModelLink.setRow(System.Int32)">
Set row
</member>
        <member name="M:CoinModelLink.onRow">
Get onRow
</member>
        <member name="M:CoinModelLink.position">
Get position
</member>
        <member name="M:CoinModelLink.element">
Get value
</member>
        <member name="M:CoinModelLink.value">
Get value
</member>
        <member name="M:CoinModelLink.column">
Get column
</member>
        <member name="M:CoinModelLink.row">
@name Sets and gets method 
Get row
</member>
        <member name="M:CoinModelLink.op_Assign(CoinModelLink!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
=
</member>
        <member name="M:CoinModelLink.#ctor(CoinModelLink!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:CoinModelLink.Dispose">
Destructor 
</member>
        <member name="M:CoinModelLink.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="T:CoinModelLink">
   This is for various structures/classes needed by CoinModel.

   CoinModelLink
   CoinModelLinkedList
   CoinModelHash

for going through row or column
</member>
        <member name="M:CoinMessage.#ctor(CoinMessages.Language)">
@name Constructors etc 
</member>
        <member name="M:OsiCbcSolverInterfaceUnitTest(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A function that tests the methods in the OsiCbcSolverInterface class. 
</member>
        <member name="F:OsiCbcSolverInterface.modelPtr_">
@name Protected member data 
Cbc model represented by this class instance
</member>
        <member name="M:OsiCbcSolverInterface.applyColCut(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply a column cut (adjust one or more bounds). 
</member>
        <member name="M:OsiCbcSolverInterface.applyRowCut(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Protected methods
Apply a row cut (append to constraint matrix). 
</member>
        <member name="M:OsiCbcSolverInterface.Dispose">
Destructor
</member>
        <member name="M:OsiCbcSolverInterface.op_Assign(OsiCbcSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiCbcSolverInterface.#ctor(OsiCbcSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiCbcSolverInterface.clone(System.Boolean)">
Clone
</member>
        <member name="M:OsiCbcSolverInterface.#ctor(OsiSolverInterface*,CbcStrategy*)">
@name Constructors and destructors 
Default Constructor
</member>
        <member name="M:OsiCbcSolverInterface.passInMessageHandler(CoinMessageHandler*)">
Pass in a message handler
  
    It is the client's responsibility to destroy a message handler installed
    by this routine; it will not be destroyed when the solver interface is
    destroyed. 

</member>
        <member name="M:OsiCbcSolverInterface.status">
Final status of problem - 0 finished, 1 stopped, 2 difficulties
</member>
        <member name="M:OsiCbcSolverInterface.getNodeCount">
Get how many Nodes it took to solve the problem.
</member>
        <member name="M:OsiCbcSolverInterface.isSolutionLimitReached">
Solution limit reached?
</member>
        <member name="M:OsiCbcSolverInterface.isNodeLimitReached">
Node limit reached?
</member>
        <member name="M:OsiCbcSolverInterface.getMaximumSeconds">
Get the CbcModel::CbcMaximumSeconds maximum number of seconds
</member>
        <member name="M:OsiCbcSolverInterface.setMaximumSeconds(System.Double)">
Set the CbcModel::CbcMaximumSeconds maximum number of seconds
</member>
        <member name="M:OsiCbcSolverInterface.getMaximumSolutions">
Get the CbcModel::CbcMaxNumSol maximum number of solutions
</member>
        <member name="M:OsiCbcSolverInterface.setMaximumSolutions(System.Int32)">
Set the CbcModel::CbcMaxNumSol maximum number of solutions
</member>
        <member name="M:OsiCbcSolverInterface.getMaximumNodes">
Get the CbcModel::CbcMaxNumNode maximum node limit
</member>
        <member name="M:OsiCbcSolverInterface.setMaximumNodes(System.Int32)">
Set the CbcModel::CbcMaxNumNode maximum node limit
</member>
        <member name="M:OsiCbcSolverInterface.getCutoff">
Get the cutoff bound on the objective function - always as minimize
</member>
        <member name="M:OsiCbcSolverInterface.setCutoff(System.Double)">
Set cutoff bound on the objective function.
</member>
        <member name="M:OsiCbcSolverInterface.getRealSolverPtr">
Get pointer to underlying solver
</member>
        <member name="M:OsiCbcSolverInterface.getModelPtr">
@name Cbc specific public interfaces 
Get pointer to Cbc model
</member>
        <member name="M:OsiCbcSolverInterface.newLanguage(CoinMessages.Language)">
@name Message handling (extra for Cbc messages).
     Normally I presume you would want the same language.
     If not then you could use underlying model pointer 
Set language
</member>
        <member name="M:OsiCbcSolverInterface.writeMpsNative(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.Int32,System.Int32,System.Double)">
Write the problem into an mps file of the given filename,
      names may be null.  formatType is
      0 - normal
      1 - extra accuracy 
      2 - IEEE hex (later)
      
      Returns non-zero on I/O error

</member>
        <member name="M:OsiCbcSolverInterface.writeMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double)">
Write the problem into an mps file of the given filename.
      If objSense is non zero then -1.0 forces the code to write a
      maximization objective and +1.0 to write a minimization one.
      If 0.0 then solver can do what it wants 
</member>
        <member name="M:OsiCbcSolverInterface.readMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Read an mps file from the given filename (defaults to Osi reader) - returns
      number of errors (see OsiMpsReader class) 
</member>
        <member name="M:OsiCbcSolverInterface.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Just like the other loadProblem() methods except that the matrix is
      given in a standard column major ordered format (without gaps). 
</member>
        <member name="M:OsiCbcSolverInterface.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Just like the other loadProblem() methods except that the matrix is
      given in a standard column major ordered format (without gaps). 
</member>
        <member name="M:OsiCbcSolverInterface.applyRowCuts(System.Int32,OsiRowCut!System.Runtime.CompilerServices.IsConst**)">
Apply a collection of row cuts which are all effective.
      applyCuts seems to do one at a time which seems inefficient.
      This uses array of pointers

</member>
        <member name="M:OsiCbcSolverInterface.applyRowCuts(System.Int32,OsiRowCut!System.Runtime.CompilerServices.IsConst*)">
Apply a collection of row cuts which are all effective.
      applyCuts seems to do one at a time which seems inefficient.

</member>
        <member name="M:OsiCbcSolverInterface.addCol(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Add a column (primal variable) to the problem. 
</member>
        <member name="M:OsiCbcSolverInterface.setRowPrice(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set dual solution vector
      
  rowprice[numrows()] is an array of values of the problem row
  dual variables. These values are copied to memory owned by the
  solver object or the solver.  They will be returned as the
  result of rowprice() until changed by another call to
  setRowprice() or by a call to any solver routine.  Whether the
  solver makes use of the solution in any way is
  solver-dependent. 

</member>
        <member name="M:OsiCbcSolverInterface.setColSolution(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the primal solution column values
      
  colsol[numcols()] is an array of values of the problem column
  variables. These values are copied to memory owned by the
  solver object or the solver.  They will be returned as the
  result of colsol() until changed by another call to
  setColsol() or by a call to any solver routine.  Whether the
  solver makes use of the solution in any way is
  solver-dependent. 

</member>
        <member name="M:OsiCbcSolverInterface.setObjSense(System.Double)">
Set objective function sense (1 for min (default), -1 for max,)
</member>
        <member name="M:OsiCbcSolverInterface.setInteger(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Set the variables listed in indices (which is of length len) to be
      integer variables 
</member>
        <member name="M:OsiCbcSolverInterface.setContinuous(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Set the variables listed in indices (which is of length len) to be
      continuous variables 
</member>
        <member name="M:OsiCbcSolverInterface.setInteger(System.Int32)">
Set the index-th variable to be an integer variable 
</member>
        <member name="M:OsiCbcSolverInterface.setContinuous(System.Int32)">
@name Integrality related changing methods 
Set the index-th variable to be a continuous variable 
</member>
        <member name="M:OsiCbcSolverInterface.setRowBounds(System.Int32,System.Double,System.Double)">
Set a single row lower and upper bound 
</member>
        <member name="M:OsiCbcSolverInterface.setColBounds(System.Int32,System.Double,System.Double)">
Set a single column lower and upper bound 
</member>
        <member name="M:OsiCbcSolverInterface.setObjCoeff(System.Int32,System.Double)">
@name Problem modifying methods 
@name Changing bounds on variables and constraints 
Set an objective function coefficient 
</member>
        <member name="M:OsiCbcSolverInterface.getIterationCount">
Get how many iterations it took to solve the problem (whatever
      "iteration" mean to the solver. 
</member>
        <member name="M:OsiCbcSolverInterface.getObjValue">
Get objective function value
</member>
        <member name="M:OsiCbcSolverInterface.getRowActivity">
Get pointer to array[getNumRows()] of row activity levels (constraint
      matrix times the solution vector 
</member>
        <member name="M:OsiCbcSolverInterface.getReducedCost">
Get a pointer to array[getNumCols()] of reduced costs
</member>
        <member name="M:OsiCbcSolverInterface.getRowPrice">
Get pointer to array[getNumRows()] of dual prices
</member>
        <member name="M:OsiCbcSolverInterface.getColSolution">
@name Methods related to querying the solution 
Get pointer to array[getNumCols()] of primal solution vector
</member>
        <member name="M:OsiCbcSolverInterface.getInfinity">
Get solver's value for infinity
</member>
        <member name="M:OsiCbcSolverInterface.getMatrixByCol">
Get pointer to column-wise copy of matrix
</member>
        <member name="M:OsiCbcSolverInterface.getMatrixByRow">
Get pointer to row-wise copy of matrix
</member>
        <member name="M:OsiCbcSolverInterface.isContinuous(System.Int32)">
Return true if column is continuous
</member>
        <member name="M:OsiCbcSolverInterface.getObjSense">
Get objective function sense (1 for min (default), -1 for max)
</member>
        <member name="M:OsiCbcSolverInterface.getObjCoefficients">
Get pointer to array[getNumCols()] of objective function coefficients
</member>
        <member name="M:OsiCbcSolverInterface.getRowUpper">
Get pointer to array[getNumRows()] of row upper bounds
</member>
        <member name="M:OsiCbcSolverInterface.getRowLower">
Get pointer to array[getNumRows()] of row lower bounds
</member>
        <member name="M:OsiCbcSolverInterface.getColUpper">
Get pointer to array[getNumCols()] of column upper bounds
</member>
        <member name="M:OsiCbcSolverInterface.getColLower">
Get pointer to array[getNumCols()] of column lower bounds
</member>
        <member name="M:OsiCbcSolverInterface.getNumElements">
Get number of nonzero elements
</member>
        <member name="M:OsiCbcSolverInterface.getNumRows">
Get number of rows
</member>
        <member name="M:OsiCbcSolverInterface.getNumCols">
@name Problem information methods
     
  These methods call the solver's query routines to return
  information about the problem referred to by the current object.
  Querying a problem that has no data associated with it result in
  zeros for the number of rows and columns, and NULL pointers from
  the methods that return vectors.
  
  Const pointers returned from any data-query method are valid as
  long as the data is unchanged and the solver is not called.

@name Methods related to querying the input data 
Get number of columns
</member>
        <member name="M:OsiCbcSolverInterface.unmarkHotStart">
Delete the snapshot
</member>
        <member name="M:OsiCbcSolverInterface.solveFromHotStart">
Optimize starting from the hotstart
</member>
        <member name="M:OsiCbcSolverInterface.setWarmStart(CoinWarmStart!System.Runtime.CompilerServices.IsConst*)">
Set warmstarting information. Return true/false depending on whether
      the warmstart information was accepted or not. 
</member>
        <member name="M:OsiCbcSolverInterface.getWarmStart">
Get warmstarting information
</member>
        <member name="M:OsiCbcSolverInterface.getEmptyWarmStart">
@name WarmStart related methods 
</member>
        <member name="M:OsiCbcSolverInterface.isIterationLimitReached">
Iteration limit reached?
</member>
        <member name="M:OsiCbcSolverInterface.isDualObjectiveLimitReached">
Is the given dual objective limit reached?
</member>
        <member name="M:OsiCbcSolverInterface.isPrimalObjectiveLimitReached">
Is the given primal objective limit reached?
</member>
        <member name="M:OsiCbcSolverInterface.isProvenDualInfeasible">
Is dual infeasiblity proven?
</member>
        <member name="M:OsiCbcSolverInterface.isProvenPrimalInfeasible">
Is primal infeasiblity proven?
</member>
        <member name="M:OsiCbcSolverInterface.isProvenOptimal">
Is optimality proven?
</member>
        <member name="M:OsiCbcSolverInterface.isAbandoned">
@name Methods returning info on how the solution process terminated
Are there a numerical difficulties?
</member>
        <member name="M:OsiCbcSolverInterface.getHintParam(OsiHintParam,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,OsiHintStrength*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a hint parameter
</member>
        <member name="M:OsiCbcSolverInterface.getHintParam(OsiHintParam,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,OsiHintStrength*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get a hint parameter
</member>
        <member name="M:OsiCbcSolverInterface.setIntParam(OsiIntParam,System.Int32)">
@name Parameter set/get methods
     
  The set methods return true if the parameter was set to the given value,
  false otherwise. There can be various reasons for failure: the given
  parameter is not applicable for the solver (e.g., refactorization
  frequency for the cbc algorithm), the parameter is not yet implemented
  for the solver or simply the value of the parameter is out of the range
  the solver accepts. If a parameter setting call returns false check the
  details of your solver.
  
  The get methods return true if the given parameter is applicable for the
  solver and is implemented. In this case the value of the parameter is
  returned in the second argument. Otherwise they return false.

</member>
        <member name="M:OsiCbcSolverInterface.branchAndBound">
Invoke solver's built-in enumeration algorithm
</member>
        <member name="M:OsiCbcSolverInterface.resolve">
Resolve an LP relaxation after problem modification
</member>
        <member name="M:OsiCbcSolverInterface.initialSolve">
@name Solve methods 
Solve initial LP relaxation
</member>
        <member name="T:OsiCbcSolverInterface">
Cbc Solver Interface
    
Instantiation of OsiCbcSolverInterface for the Model Algorithm.


</member>
        <member name="M:OsiUnitTest.TestOutcomes.print">
Print the list of outcomes
</member>
        <member name="M:OsiUnitTest.TestOutcomes.add(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,OsiUnitTest.TestOutcome.SeverityLevel,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices">
Add an outcome to the list
</member>
        <member name="T:OsiUnitTest.TestOutcomes">
Utility class to maintain a list of test outcomes.
</member>
        <member name="M:OsiUnitTest.TestOutcome.print">
Print the test outcome
</member>
        <member name="M:OsiUnitTest.TestOutcome.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.Is">
Standard constructor
</member>
        <member name="F:OsiUnitTest.TestOutcome.linenumber">
Line number in code file where test executed
</member>
        <member name="F:OsiUnitTest.TestOutcome.filename">
Name of code file where test executed
</member>
        <member name="F:OsiUnitTest.TestOutcome.expected">
Set to true if problem is expected
</member>
        <member name="F:OsiUnitTest.TestOutcome.severity">
Test result
</member>
        <member name="F:OsiUnitTest.TestOutcome.testcond">
Condition being tested
</member>
        <member name="F:OsiUnitTest.TestOutcome.testname">
Name of test
</member>
        <member name="F:OsiUnitTest.TestOutcome.component">
Name of component under test
</member>
        <member name="F:OsiUnitTest.TestOutcome.SeverityLevelName">
Print strings for SeverityLevel
</member>
        <member name="T:OsiUnitTest.TestOutcome">
A single test outcome record.
</member>
        <member name="M:OsiUnitTest.failureMessage(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices">
\overload
</member>
        <member name="M:OsiUnitTest.failureMessage(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\overload
</member>
        <member name="M:OsiCutsUnitTest">
A function that tests the methods in the OsiCuts class. 
</member>
        <member name="M:OsiRowCutDebuggerUnitTest(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A function that tests the methods in the OsiRowCutDebugger class. 
</member>
        <member name="M:OsiRowCutUnitTest(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A function that tests the methods in the OsiRowCut class. 
</member>
        <member name="M:OsiColCutUnitTest(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A function that tests the methods in the OsiColCut class. 
</member>
        <member name="M:OsiSolverInterfaceCommonUnitTest(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplici">
A function that tests the methods in the OsiSolverInterface class.
 * Some time ago, if this method is compiled with optimization,
 * the compilation took 10-15 minutes and the machine pages (has 256M core memory!)...

</member>
        <member name="M:OsiSolverInterfaceMpsUnitTest(std.vector&lt;OsiSolverInterface**,std.allocator&lt;OsiSolverInterface**&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A function that tests that a lot of problems given in MPS files (mostly the NETLIB problems) solve properly with all the specified solvers.
 *
 * The routine creates a vector of NetLib problems (problem name, objective,
 * various other characteristics), and a vector of solvers to be tested.
 *
 * Each solver is run on each problem. The run is deemed successful if the
 * solver reports the correct problem size after loading and returns the
 * correct objective value after optimization.

 * If multiple solvers are available, the results are compared pairwise against
 * the results reported by adjacent solvers in the solver vector. Due to
 * limitations of the volume solver, it must be the last solver in vecEmptySiP.

</member>
        <member name="F:CbcLotsizeBranchingObject.up_">
Lower [0] and upper [1] bounds for the up arm (way_ = 1)
</member>
        <member name="F:CbcLotsizeBranchingObject.down_">
Lower [0] and upper [1] bounds for the down arm (way_ = -1)
</member>
        <member name="M:CbcLotsizeBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be os the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcLotsizeBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcLotsizeBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcLotsizeBranchingObject.branch">
\brief Sets the bounds for the variable according to the current arm
           of the branch and advances the object state to the next arm.

</member>
        <member name="M:CbcLotsizeBranchingObject.Dispose">
Destructor
</member>
        <member name="M:CbcLotsizeBranchingObject.clone">
Clone
</member>
        <member name="M:CbcLotsizeBranchingObject.op_Assign(CbcLotsizeBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcLotsizeBranchingObject.#ctor(CbcLotsizeBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcLotsizeBranchingObject.#ctor">
Default constructor
</member>
        <member name="T:CbcLotsizeBranchingObject">
Lotsize branching object

  This object can specify a two-way branch on an integer variable. For each
  arm of the branch, the upper and lower bounds on the variable can be
  independently specified.

  Variable_ holds the index of the integer variable in the integerVariable_
  array of the model.

</member>
        <member name="F:CbcLotsize.range_">
Current range
</member>
        <member name="F:CbcLotsize.bound_">
Ranges
</member>
        <member name="F:CbcLotsize.numberRanges_">
Number of points
</member>
        <member name="F:CbcLotsize.rangeType_">
Type - 1 points, 2 ranges
</member>
        <member name="F:CbcLotsize.columnNumber_">
data
Column number in model
</member>
        <member name="M:CbcLotsize.printLotsize(System.Double,System.Boolean,System.Int32)">
Just for debug (CBC_PRINT defined in CbcBranchLotsize.cpp)
</member>
        <member name="M:CbcLotsize.canDoHeuristics">
\brief Return true if object can take part in normal heuristics

</member>
        <member name="M:CbcLotsize.bound">
Ranges
</member>
        <member name="M:CbcLotsize.numberRanges">
Number of points
</member>
        <member name="M:CbcLotsize.rangeType">
Type - 1 points, 2 ranges
</member>
        <member name="M:CbcLotsize.originalLowerBound">
Original variable bounds
</member>
        <member name="M:CbcLotsize.columnNumber">
Column number if single column object -1 otherwise,
        so returns &gt;= 0
        Used by heuristics

</member>
        <member name="M:CbcLotsize.setModelSequence(System.Int32)">
Set model column number
</member>
        <member name="M:CbcLotsize.modelSequence">
Model column number
</member>
        <member name="M:CbcLotsize.floorCeiling(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Returns floor and ceiling

</member>
        <member name="M:CbcLotsize.findRange(System.Double)">
Finds range of interest so value is feasible in range range_ or infeasible
        between hi[range_] and lo[range_+1].  Returns true if feasible.

</member>
        <member name="M:CbcLotsize.resetBounds(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Reset original upper and lower bound values from the solver.

      Handy for updating bounds held in this object after bounds held in the
      solver have been tightened.

</member>
        <member name="M:CbcLotsize.notPreferredNewFeasible">
\brief Given a valid solution (with reduced costs, etc.),
        return a branching object which would give a new feasible
        point in a bad direction.

      As for preferredNewFeasible(), but the preferred branching object will
      force movement in a direction that degrades the objective.

</member>
        <member name="M:CbcLotsize.preferredNewFeasible">
\brief Given a valid solution (with reduced costs, etc.),
        return a branching object which would give a new feasible
        point in the good direction.

      The preferred branching object will force the variable to be +/-1 from
      its current value, depending on the reduced cost and objective sense.  If
      movement in the direction which improves the objective is impossible due
      to bounds on the variable, the branching object will move in the other
      direction.  If no movement is possible, the method returns NULL.

      Only the bounds on this variable are considered when determining if the new
      point is feasible.

</member>
        <member name="M:CbcLotsize.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcLotsize.feasibleRegion">
Set bounds to contain the current solution.

      More precisely, for the variable associated with this object, take the
      value given in the current solution, force it within the current bounds
      if required, then set the bounds to fix the variable at the integer
      nearest the solution value.

</member>
        <member name="M:CbcLotsize.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcLotsize.clone">
Clone
</member>
        <member name="T:CbcLotsize">
Lotsize class 
</member>
        <member name="M:CbcGeneral.redoSequenceEtc(CbcModel*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Redoes data when sequence numbers change
</member>
        <member name="M:CbcGeneral.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcGeneral.feasibleRegion">
This looks at solution and sets bounds to contain solution
</member>
        <member name="M:CbcGeneral.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcGeneral.clone">
Clone
</member>
        <member name="M:CbcGeneral.#ctor(CbcModel*)">
Useful constructor
        Just needs to point to model.

</member>
        <member name="T:CbcGeneral">
Define a catch all class.
    This will create a list of subproblems

</member>
        <member name="M:CbcDummyBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be os the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcDummyBranchingObject.compareOriginalObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Compare the original object of \c this with the original object of \c
        brObj. Assumes that there is an ordering of the original objects.
        This method should be invoked only if \c this and brObj are of the same
        type.
        Return negative/0/positive depending on whether \c this is
        smaller/same/larger than the argument.

</member>
        <member name="M:CbcDummyBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcDummyBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcDummyBranchingObject.branch">
\brief Dummy branch

</member>
        <member name="M:CbcDummyBranchingObject.Dispose">
Destructor
</member>
        <member name="M:CbcDummyBranchingObject.clone">
Clone
</member>
        <member name="M:CbcDummyBranchingObject.op_Assign(CbcDummyBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcDummyBranchingObject.#ctor(CbcDummyBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcDummyBranchingObject.#ctor(CbcModel*)">
Default constructor
</member>
        <member name="T:CbcDummyBranchingObject">
Dummy branching object

  This object specifies a one-way dummy branch.
  This is so one can carry on branching even when it looks feasible

</member>
        <member name="F:CbcFixVariable.variable_">
Variable
</member>
        <member name="F:CbcFixVariable.newBound_">
For each variable new bounds
</member>
        <member name="F:CbcFixVariable.startUpper_">
Start of information for each state (setting new upper)
</member>
        <member name="F:CbcFixVariable.startLower_">
Start of information for each state (setting new lower)
</member>
        <member name="F:CbcFixVariable.states_">
Values of integers for various states
</member>
        <member name="F:CbcFixVariable.numberStates_">
Number of states
</member>
        <member name="M:CbcFixVariable.applyToSolver(OsiSolverInterface*,System.Int32)">
Apply to an LP solver.  Action depends on state

</member>
        <member name="M:CbcFixVariable.Dispose">
Destructor
</member>
        <member name="M:CbcFixVariable.clone">
Clone
</member>
        <member name="T:CbcFixVariable">
Class for consequent bounds.
    When a variable is branched on it normally interacts with other variables by
    means of equations.  There are cases where we want to step outside LP and do something
    more directly e.g. fix bounds.  This class is for that.

    A state of -9999 means at LB, +9999 means at UB,
    others mean if fixed to that value.


</member>
        <member name="F:CbcIdiotBranch.savedRandomNumberGenerator_">
Saved version of thread specific random number generator
</member>
        <member name="F:CbcIdiotBranch.randomNumberGenerator_">
data
Thread specific random number generator
</member>
        <member name="M:CbcIdiotBranch.buildCut(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Build "cut"
</member>
        <member name="M:CbcIdiotBranch.initializeForBranching(CbcModel*)">
Initialize for branching
</member>
        <member name="M:CbcIdiotBranch.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcIdiotBranch.feasibleRegion">
This looks at solution and sets bounds to contain solution
</member>
        <member name="M:CbcIdiotBranch.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcIdiotBranch.clone">
Clone
</member>
        <member name="M:CbcIdiotBranch.#ctor(CbcModel*)">
Useful constructor

</member>
        <member name="T:CbcIdiotBranch">
Define an idiotic idea class.
    The idea of this is that we take some integer variables away from integer and
    sum them with some randomness to get signed sum close to 0.5.  We then can
    branch to exclude that gap.

    This branching rule should be in addition to normal rules and have a high priority.

</member>
        <member name="F:CbcFixingBranchingObject.upList_">
upList - variables to fix to lb on up branch
</member>
        <member name="F:CbcFixingBranchingObject.downList_">
downList - variables to fix to lb on down branch
</member>
        <member name="F:CbcFixingBranchingObject.numberUp_">
Number on up list
</member>
        <member name="F:CbcFixingBranchingObject.numberDown_">
data
Number on down list
</member>
        <member name="M:CbcFixingBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be os the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcFixingBranchingObject.compareOriginalObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Compare the original object of \c this with the original object of \c
        brObj. Assumes that there is an ordering of the original objects.
        This method should be invoked only if \c this and brObj are of the same
        type.
        Return negative/0/positive depending on whether \c this is
        smaller/same/larger than the argument.

</member>
        <member name="M:CbcFixingBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcFixingBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcFixingBranchingObject.branch">
Does next branch and updates state
</member>
        <member name="M:CbcFixingBranchingObject.clone">
Clone
</member>
        <member name="T:CbcFixingBranchingObject">
General Branching Object class.
    Each way fixes some variables to lower bound

</member>
        <member name="F:CbcFollowOn.rhs_">
Possible rhs (if 0 then not possible)
</member>
        <member name="F:CbcFollowOn.matrixByRow_">
Matrix by row
</member>
        <member name="F:CbcFollowOn.matrix_">
data
Matrix
</member>
        <member name="M:CbcFollowOn.gutsOfFollowOn(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
As some computation is needed in more than one place - returns row
</member>
        <member name="M:CbcFollowOn.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcFollowOn.feasibleRegion">
This looks at solution and sets bounds to contain solution
</member>
        <member name="M:CbcFollowOn.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcFollowOn.clone">
Clone
</member>
        <member name="M:CbcFollowOn.#ctor(CbcModel*)">
Useful constructor

</member>
        <member name="T:CbcFollowOn">
Define a follow on class.
    The idea of this is that in air-crew scheduling problems crew may fly in on flight A
    and out on flight B or on some other flight.  A useful branch is one which on one side
    fixes all which go out on flight B to 0, while the other branch fixes all those that do NOT
    go out on flight B to 0.

    This branching rule should be in addition to normal rules and have a high priority.

</member>
        <member name="F:CbcBranchDefaultDecision.bestNumberDown_">
Number of infeasibilities for down
</member>
        <member name="F:CbcBranchDefaultDecision.bestObject_">
Pointer to best branching object
</member>
        <member name="F:CbcBranchDefaultDecision.bestChangeDown_">
Change down for best
</member>
        <member name="F:CbcBranchDefaultDecision.bestNumberUp_">
Number of infeasibilities for up
</member>
        <member name="F:CbcBranchDefaultDecision.bestChangeUp_">
Change up for best
</member>
        <member name="F:CbcBranchDefaultDecision.bestCriterion_">
data
"best" so far
</member>
        <member name="M:CbcBranchDefaultDecision.op_Assign(CbcBranchDefaultDecision!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="M:CbcBranchDefaultDecision.bestBranch(CbcBranchingObject**,System.Int32,System.Int32,System.Double*,System.Int32*,System.Double*,System.Int32*,System.Double)">
\brief Compare N branching objects. Return index of best
        and sets way of branching in chosen object.

      This routine is used only after strong branching.

</member>
        <member name="M:CbcBranchDefaultDecision.setBestCriterion(System.Double)">
Sets or gets best criterion so far 
</member>
        <member name="M:CbcBranchDefaultDecision.betterBranch(CbcBranchingObject*,CbcBranchingObject*,System.Double,System.Int32,System.Double,System.Int32)">
\brief Compare two branching objects. Return nonzero if \p thisOne is
           better than \p bestSoFar.

      The routine compares branches using the values supplied in \p numInfUp and
      \p numInfDn until a solution is found by search, after which it uses the
      values supplied in \p changeUp and \p changeDn. The best branching object
      seen so far and the associated parameter values are remembered in the
      \c CbcBranchDefaultDecision object. The nonzero return value is +1 if the
      up branch is preferred, -1 if the down branch is preferred.

      As the names imply, the assumption is that the values supplied for
      \p numInfUp and \p numInfDn will be the number of infeasibilities reported
      by the branching object, and \p changeUp and \p changeDn will be the
      estimated change in objective. Other measures can be used if desired.

      Because an \c CbcBranchDefaultDecision object remembers the current best
      branching candidate (#bestObject_) as well as the values used in the
      comparison, the parameter \p bestSoFar is redundant, hence unused.

</member>
        <member name="M:CbcBranchDefaultDecision.initialize(CbcModel*)">
Initialize, <i>e.g.</i> before the start of branch selection at a node
</member>
        <member name="M:CbcBranchDefaultDecision.clone">
Clone
</member>
        <member name="T:CbcBranchDefaultDecision">
Branching decision default class

  This class implements a simple default algorithm
  (betterBranch()) for choosing a branching variable.

</member>
        <member name="F:CbcSimpleIntegerPseudoCost.method_">
Method -
        0 - normal - return min (up,down)
        1 - if before any solution return CoinMax(up,down)
        2 - if before branched solution return CoinMax(up,down)
        3 - always return CoinMax(up,down)

</member>
        <member name="F:CbcSimpleIntegerPseudoCost.upDownSeparator_">
Up/down separator
        If &gt;0.0 then do first branch up if value-floor(value)
        &gt;= this value

</member>
        <member name="F:CbcSimpleIntegerPseudoCost.upPseudoCost_">
Up pseudo cost
</member>
        <member name="F:CbcSimpleIntegerPseudoCost.downPseudoCost_">
data
Down pseudo cost
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.setMethod(System.Int32)">
Set method
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.method">
method - see below for details
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.downEstimate">
Return "down" estimate (default 1.0e-5)
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.upEstimate">
Return "up" estimate
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.setUpDownSeparator(System.Double)">
Set up down separator
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.upDownSeparator">
Up down separator
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.setUpPseudoCost(System.Double)">
Set up pseudo cost
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.upPseudoCost">
Up pseudo cost
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.setDownPseudoCost(System.Double)">
Set down pseudo cost
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.downPseudoCost">
Down pseudo cost
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcSimpleIntegerPseudoCost.clone">
Clone
</member>
        <member name="T:CbcSimpleIntegerPseudoCost">
Define a single integer class but with pseudo costs
</member>
        <member name="F:CbcNWayBranchingObject.numberInSet_">
Number in set
</member>
        <member name="F:CbcNWayBranchingObject.object_">
Points back to object
</member>
        <member name="F:CbcNWayBranchingObject.order_">
order of branching - points back to CbcNWay
</member>
        <member name="M:CbcNWayBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be os the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcNWayBranchingObject.compareOriginalObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Compare the original object of \c this with the original object of \c
        brObj. Assumes that there is an ordering of the original objects.
        This method should be invoked only if \c this and brObj are of the same
        type.
        Return negative/0/positive depending on whether \c this is
        smaller/same/larger than the argument.

</member>
        <member name="M:CbcNWayBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcNWayBranchingObject.twoWay">
Is this a two way object (-1 down, +1 up)
</member>
        <member name="M:CbcNWayBranchingObject.numberBranches">
The number of branch arms created for this branching object

</member>
        <member name="M:CbcNWayBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcNWayBranchingObject.branch">
Does next branch and updates state
</member>
        <member name="M:CbcNWayBranchingObject.clone">
Clone
</member>
        <member name="M:CbcNWayBranchingObject.#ctor(CbcModel*,CbcNWay!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Useful constructor - order had matrix indices
        way_ -1 corresponds to setting first, +1 to second, +3 etc.
        this is so -1 and +1 have similarity to normal

</member>
        <member name="T:CbcNWayBranchingObject">
N way branching Object class.
    Variable is number of set.

</member>
        <member name="F:CbcNWay.consequence_">
Consequences (normally NULL)
</member>
        <member name="F:CbcNWay.members_">
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="F:CbcNWay.numberMembers_">
data
Number of members
</member>
        <member name="M:CbcNWay.redoSequenceEtc(CbcModel*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Redoes data when sequence numbers change
</member>
        <member name="M:CbcNWay.members">
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="M:CbcNWay.numberMembers">
Number of members
</member>
        <member name="M:CbcNWay.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcNWay.feasibleRegion">
This looks at solution and sets bounds to contain solution
</member>
        <member name="M:CbcNWay.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5 (and 0.5 will give this)
</member>
        <member name="M:CbcNWay.applyConsequence(System.Int32,System.Int32)">
Applies a consequence for a single member
</member>
        <member name="M:CbcNWay.setConsequence(System.Int32,CbcConsequence!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set up a consequence for a single member
</member>
        <member name="M:CbcNWay.Dispose">
Destructor
</member>
        <member name="M:CbcNWay.op_Assign(CbcNWay!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcNWay.clone">
Clone
</member>
        <member name="M:CbcNWay.#ctor(CbcModel*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Useful constructor (which are matrix indices)

</member>
        <member name="T:CbcNWay">
Define an n-way class for variables.
    Only valid value is one at UB others at LB
    Normally 0-1

</member>
        <member name="F:CbcSimpleInteger.preferredWay_">
If -1 down always chosen first, +1 up always, 0 normal
</member>
        <member name="F:CbcSimpleInteger.columnNumber_">
Column number in model
</member>
        <member name="F:CbcSimpleInteger.breakEven_">
Breakeven i.e. &gt;= this preferred is up
</member>
        <member name="F:CbcSimpleInteger.originalUpper_">
Original upper bound
</member>
        <member name="F:CbcSimpleInteger.originalLower_">
data
Original lower bound
</member>
        <member name="M:CbcSimpleInteger.setBreakEven(System.Double)">
Set breakeven e.g 0.7 -&gt; &gt;= 0.7 go up first
</member>
        <member name="M:CbcSimpleInteger.breakEven">
Breakeven e.g 0.7 -&gt; &gt;= 0.7 go up first
</member>
        <member name="M:CbcSimpleInteger.originalLowerBound">
Original bounds
</member>
        <member name="M:CbcSimpleInteger.resetSequenceEtc(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Change column numbers after preprocessing

</member>
        <member name="M:CbcSimpleInteger.resetBounds(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Reset variable bounds to their original values.

      Bounds may be tightened, so it may be good to be able to set this info in object.

</member>
        <member name="M:CbcSimpleInteger.setColumnNumber(System.Int32)">
Set column number
</member>
        <member name="M:CbcSimpleInteger.columnNumber">
Column number if single column object -1 otherwise,
        so returns &gt;= 0
        Used by heuristics

</member>
        <member name="M:CbcSimpleInteger.feasibleRegion">
Set bounds to fix the variable at the current (integer) value.

      Given an integer value, set the lower and upper bounds to fix the
      variable. The algorithm takes a bit of care in order to compensate for
      minor numerical inaccuracy.

</member>
        <member name="M:CbcSimpleInteger.solverBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*)">
Create an OsiSolverBranch object

        This returns NULL if branch not represented by bound changes

</member>
        <member name="M:CbcSimpleInteger.fillCreateBranch(CbcIntegerBranchingObject*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Fills in a created branching object
</member>
        <member name="M:CbcSimpleInteger.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Create a branching object and indicate which way to branch first.

        The branching object has to know how to create branches (fix
        variables, etc.)

</member>
        <member name="M:CbcSimpleInteger.feasibleRegion(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*)">
Set bounds to fix the variable at the current (integer) value.

      Given an integer value, set the lower and upper bounds to fix the
      variable. Returns amount it had to move variable.

</member>
        <member name="M:CbcSimpleInteger.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcSimpleInteger.osiObject">
Construct an OsiSimpleInteger object
</member>
        <member name="M:CbcSimpleInteger.clone">
Clone
</member>
        <member name="T:CbcSimpleInteger">
Define a single integer class
</member>
        <member name="F:CbcIntegerBranchingObject.up_">
Lower [0] and upper [1] bounds for the up arm (way_ = 1)
</member>
        <member name="F:CbcIntegerBranchingObject.down_">
Lower [0] and upper [1] bounds for the down arm (way_ = -1)
</member>
        <member name="M:CbcIntegerBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be os the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcIntegerBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcIntegerBranchingObject.setUpBounds(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set lower and upper bounds for up branch
</member>
        <member name="M:CbcIntegerBranchingObject.setDownBounds(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set lower and upper bounds for down branch
</member>
        <member name="M:CbcIntegerBranchingObject.upBounds">
Lower and upper bounds for up branch
</member>
        <member name="M:CbcIntegerBranchingObject.downBounds">
Lower and upper bounds for down branch
</member>
        <member name="M:CbcIntegerBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcIntegerBranchingObject.tighten(OsiSolverInterface*)">
Change (tighten) bounds in object to reflect bounds in solver.
	Return true if now fixed 
</member>
        <member name="M:CbcIntegerBranchingObject.fix(OsiSolverInterface*,System.Double*,System.Double*,System.Int32)">
Update bounds in solver as in 'branch' and update given bounds.
        branchState is -1 for 'down' +1 for 'up' 
</member>
        <member name="M:CbcIntegerBranchingObject.branch">
\brief Sets the bounds for the variable according to the current arm
           of the branch and advances the object state to the next arm.
           Returns change in guessed objective on next branch

</member>
        <member name="M:CbcIntegerBranchingObject.fillPart(System.Int32,System.Int32,System.Double)">
Does part of constructor
</member>
        <member name="M:CbcIntegerBranchingObject.Dispose">
Destructor
</member>
        <member name="M:CbcIntegerBranchingObject.clone">
Clone
</member>
        <member name="M:CbcIntegerBranchingObject.op_Assign(CbcIntegerBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcIntegerBranchingObject.#ctor(CbcIntegerBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcIntegerBranchingObject.#ctor">
Default constructor
</member>
        <member name="T:CbcIntegerBranchingObject">
Simple branching object for an integer variable

  This object can specify a two-way branch on an integer variable. For each
  arm of the branch, the upper and lower bounds on the variable can be
  independently specified.

  Variable_ holds the index of the integer variable in the integerVariable_
  array of the model.

</member>
        <member name="F:CbcSOSBranchingObject.firstNonzero_">
The following two members describe the range in the members_ of the
        original object that whose upper bound is not fixed to 0. This is not
        necessary for Cbc to function correctly, this is there for heuristics so
        that separate branching decisions on the same object can be pooled into
        one branching object. 
</member>
        <member name="F:CbcSOSBranchingObject.separator_">
separator
</member>
        <member name="F:CbcSOSBranchingObject.set_">
data
</member>
        <member name="M:CbcSOSBranchingObject.computeNonzeroRange">
Fill out the \c firstNonzero_ and \c lastNonzero_ data members 
</member>
        <member name="M:CbcSOSBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be os the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcSOSBranchingObject.compareOriginalObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Compare the original object of \c this with the original object of \c
        brObj. Assumes that there is an ordering of the original objects.
        This method should be invoked only if \c this and brObj are of the same
        type.
        Return negative/0/positive depending on whether \c this is
        smaller/same/larger than the argument.

</member>
        <member name="M:CbcSOSBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcSOSBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcSOSBranchingObject.previousBranch">
Reset every information so that the branching object appears to point to
        the previous child. This method does not need to modify anything in any
        solver. 
</member>
        <member name="M:CbcSOSBranchingObject.fix(OsiSolverInterface*,System.Double*,System.Double*,System.Int32)">
Update bounds in solver as in 'branch' and update given bounds.
        branchState is -1 for 'down' +1 for 'up' 
</member>
        <member name="M:CbcSOSBranchingObject.branch">
Does next branch and updates state
</member>
        <member name="M:CbcSOSBranchingObject.clone">
Clone
</member>
        <member name="T:CbcSOSBranchingObject">
Branching object for Special ordered sets

    Variable_ is the set id number (redundant, as the object also holds a
    pointer to the set.

</member>
        <member name="F:CbcSOS.oddValues_">
Whether odd values e.g. negative
</member>
        <member name="F:CbcSOS.integerValued_">
Whether integer valued
</member>
        <member name="F:CbcSOS.sosType_">
SOS type
</member>
        <member name="F:CbcSOS.numberMembers_">
Number of members
</member>
        <member name="F:CbcSOS.numberTimesUp_">
Number of times we have gone up
</member>
        <member name="F:CbcSOS.numberTimesDown_">
Number of times we have gone down
</member>
        <member name="F:CbcSOS.upDynamicPseudoRatio_">
Up pseudo ratio
</member>
        <member name="F:CbcSOS.downDynamicPseudoRatio_">
Down pseudo ratio
</member>
        <member name="F:CbcSOS.shadowEstimateUp_">
Current pseudo-shadow price estimate up
</member>
        <member name="F:CbcSOS.shadowEstimateDown_">
Current pseudo-shadow price estimate down
</member>
        <member name="F:CbcSOS.weights_">
\brief Weights for individual members

    Arbitrary weights for members. Can be used to attach meaning to variable
    values independent of objective coefficients. For example, if the SOS set
    comprises binary variables used to choose a facility of a given size, the
    weight could be the corresponding facilty size. Fractional values of the
    SOS variables can then be used to estimate ideal facility size.

    Weights cannot be completely arbitrary. From the code, they must be
    differ by at least 1.0e-7

</member>
        <member name="F:CbcSOS.members_">
data
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="M:CbcSOS.setIntegerValued(System.Boolean)">
Set whether set is integer valued or not
</member>
        <member name="M:CbcSOS.canDoHeuristics">
\brief Return true if object can take part in normal heuristics

</member>
        <member name="M:CbcSOS.mutableWeights">
Array of weights 
</member>
        <member name="M:CbcSOS.mutableMembers">
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="M:CbcSOS.setNumberMembers(System.Int32)">
Set number of members
</member>
        <member name="M:CbcSOS.weights">
Array of weights 
</member>
        <member name="M:CbcSOS.numberTimesUp">
Up number times
</member>
        <member name="M:CbcSOS.numberTimesDown">
Down number times
</member>
        <member name="M:CbcSOS.sosType">
SOS type
</member>
        <member name="M:CbcSOS.members">
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="M:CbcSOS.numberMembers">
Number of members
</member>
        <member name="M:CbcSOS.osiObject(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Construct an OsiSOS object
</member>
        <member name="M:CbcSOS.redoSequenceEtc(CbcModel*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Redoes data when sequence numbers change
</member>
        <member name="M:CbcSOS.solverBranch">
Create an OsiSolverBranch object

        This returns NULL if branch not represented by bound changes

</member>
        <member name="M:CbcSOS.updateInformation(CbcObjectUpdateData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update object by CbcObjectUpdateData
</member>
        <member name="M:CbcSOS.createUpdateInformation(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,CbcNode!System.Runtime.CompilerServices.IsConst*,CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Pass in information on branch just done and create CbcObjectUpdateData instance.
        If object does not need data then backward pointer will be NULL.
        Assumes can get information from solver 
</member>
        <member name="M:CbcSOS.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcSOS.feasibleRegion">
This looks at solution and sets bounds to contain solution
</member>
        <member name="M:CbcSOS.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcSOS.clone">
Clone
</member>
        <member name="M:CbcSOS.#ctor(CbcModel*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
\brief Constructor with SOS type and member information

    Type specifies SOS 1 or 2. Identifier is an arbitrary value.

    Which should be an array of variable indices with numberMembers entries.
    Weights can be used to assign arbitrary weights to variables, in the order
    they are specified in which. If no weights are provided, a default array of
    0, 1, 2, ... is generated.

</member>
        <member name="T:CbcSOS">
\brief Branching object for Special Ordered Sets of type 1 and 2.

  SOS1 are an ordered set of variables where at most one variable can be
  non-zero. SOS1 are commonly defined with binary variables (interpreted as
  selection between alternatives) but this is not necessary.  An SOS1 with
  all binary variables is a special case of a clique (setting any one
  variable to 1 forces all others to 0).

  In theory, the implementation makes no assumptions about integrality in
  Type 1 sets. In practice, there are places where the code seems to have been
  written with a binary SOS mindset. Current development of SOS branching
  objects is proceeding in OsiSOS.

  SOS2 are an ordered set of variables in which at most two consecutive
  variables can be non-zero and must sum to 1 (interpreted as interpolation
  between two discrete values). By definition the variables are non-integer.

</member>
        <member name="F:CbcLongCliqueBranchingObject.upMask_">
upMask - bit set to fix to weak bounds, not set to leave unfixed
</member>
        <member name="F:CbcLongCliqueBranchingObject.downMask_">
downMask - bit set to fix to weak bounds, not set to leave unfixed
</member>
        <member name="F:CbcLongCliqueBranchingObject.clique_">
data
</member>
        <member name="M:CbcLongCliqueBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be os the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcLongCliqueBranchingObject.compareOriginalObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Compare the original object of \c this with the original object of \c
        brObj. Assumes that there is an ordering of the original objects.
        This method should be invoked only if \c this and brObj are of the same
        type.
        Return negative/0/positive depending on whether \c this is
        smaller/same/larger than the argument.

</member>
        <member name="M:CbcLongCliqueBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcLongCliqueBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcLongCliqueBranchingObject.branch">
Does next branch and updates state
</member>
        <member name="M:CbcLongCliqueBranchingObject.clone">
Clone
</member>
        <member name="T:CbcLongCliqueBranchingObject">
Unordered Clique Branching Object class.
    These are for cliques which are &gt; 64 members
    Variable is number of clique.

</member>
        <member name="F:CbcCliqueBranchingObject.upMask_">
upMask - bit set to fix to weak bounds, not set to leave unfixed
</member>
        <member name="F:CbcCliqueBranchingObject.downMask_">
downMask - bit set to fix to weak bounds, not set to leave unfixed
</member>
        <member name="F:CbcCliqueBranchingObject.clique_">
data
</member>
        <member name="M:CbcCliqueBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be of the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcCliqueBranchingObject.compareOriginalObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Compare the original object of \c this with the original object of \c
        brObj. Assumes that there is an ordering of the original objects.
        This method should be invoked only if \c this and brObj are of the same
        type.
        Return negative/0/positive depending on whether \c this is
        smaller/same/larger than the argument.

</member>
        <member name="M:CbcCliqueBranchingObject.type">
Return the type (an integer identifier) of \c this 
</member>
        <member name="M:CbcCliqueBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcCliqueBranchingObject.branch">
Does next branch and updates state
</member>
        <member name="M:CbcCliqueBranchingObject.clone">
Clone
</member>
        <member name="F:CbcClique.type_">
\brief Strong value for each member.

      This also specifies whether a variable has a +1 or -1 coefficient.
        - 0 =&gt; -1 coefficient, 0 is strong value
        - 1 =&gt; +1 coefficient, 1 is strong value
      If unspecified, all coefficients are assumed to be positive.
    
      Indexed as 0 .. numberMembers_-1

</member>
        <member name="F:CbcClique.members_">
Members (indices in range 0 ... numberIntegers_-1)
</member>
        <member name="F:CbcClique.numberNonSOSMembers_">
Number of Non SOS members i.e. fixing to zero is strong
</member>
        <member name="F:CbcClique.numberMembers_">
data
Number of members
</member>
        <member name="M:CbcClique.redoSequenceEtc(CbcModel*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Redoes data when sequence numbers change
</member>
        <member name="M:CbcClique.members">
Members (indices in range 0 ... numberIntegers_-1)
</member>
        <member name="M:CbcClique.numberNonSOSMembers">
\brief Number of variables with -1 coefficient
      
      Number of non-SOS members, i.e., fixing to zero is strong.
      See comments at head of class, and comments for #type_.

</member>
        <member name="M:CbcClique.numberMembers">
Number of members
</member>
        <member name="M:CbcClique.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object
</member>
        <member name="M:CbcClique.feasibleRegion">
This looks at solution and sets bounds to contain solution
</member>
        <member name="M:CbcClique.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:CbcClique.Dispose">
Destructor
</member>
        <member name="M:CbcClique.op_Assign(CbcClique!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcClique.clone">
Clone
</member>
        <member name="M:CbcClique.#ctor(CbcClique!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcClique.#ctor(CbcModel*,System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Useful constructor (which are integer indices) slack can denote a slack
	in set.  If type == NULL then as if 1

</member>
        <member name="M:CbcClique.#ctor">
Default Constructor
</member>
        <member name="M:CbcStopNow.Dispose">
Destructor
</member>
        <member name="M:CbcStopNow.clone">
Clone
</member>
        <member name="M:CbcStopNow.op_Assign(CbcStopNow!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcStopNow.#ctor(CbcStopNow!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor .

</member>
        <member name="M:CbcStopNow.#ctor">
@name Constructors and destructors etc
Default Constructor
</member>
        <member name="M:CbcStopNow.callBack(CbcModel*,System.Int32)">
@name Decision methods
</member>
        <member name="F:CbcUser.userName_">
Name of user function
</member>
        <member name="F:CbcUser.coinModel_">
@name Private member data
CoinModel
</member>
        <member name="M:CbcUser.Dispose">
Destructor
</member>
        <member name="M:CbcUser.clone">
Clone
</member>
        <member name="M:CbcUser.op_Assign(CbcUser!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcUser.#ctor(CbcUser!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcUser.#ctor">
@name Constructors and destructors etc
Default Constructor
</member>
        <member name="M:CbcUser.canDo(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns true if function knows about option
</member>
        <member name="M:CbcUser.solve(CbcSolver*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Solve (whatever that means)
</member>
        <member name="M:CbcUser.name">
Name
</member>
        <member name="M:CbcUser.stuff">
Other info - needs expanding
</member>
        <member name="M:CbcUser.coinModel">
@name usage methods
CoinModel if valid
</member>
        <member name="M:CbcUser.fillInformation(CbcSolver*,CbcSolverUsefulData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Get useful stuff
</member>
        <member name="M:CbcUser.exportData(CbcSolver*)">
Export Data (i.e. at very end)
</member>
        <member name="M:CbcUser.importData(CbcSolver*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**)">
@name import/export methods
</member>
        <member name="M:CbcMain0(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcSolverUsefulData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
And this uses it
</member>
        <member name="F:CbcSolverUsefulData.totalTime_">
@name Member data
</member>
        <member name="M:CbcSolverUsefulData.Dispose">
Destructor
</member>
        <member name="M:CbcSolverUsefulData.op_Assign(CbcSolverUsefulData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcSolverUsefulData.#ctor(CbcSolverUsefulData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor .

</member>
        <member name="M:CbcSolverUsefulData.#ctor">
@name Constructors and destructors etc
Default Constructor
</member>
        <member name="T:CbcSolverUsefulData">
The CbcSolver class was taken out at a 9/12/09 meeting
This is a feeble replacement.
At present everything is public

</member>
        <member name="F:CbcSolver.readMode_">
Where to start reading commands
</member>
        <member name="F:CbcSolver.noPrinting_">
Whether to print to std::cout
</member>
        <member name="F:CbcSolver.doMiplib_">
Whether to do miplib test
</member>
        <member name="F:CbcSolver.parameters_">
Parameters and values
</member>
        <member name="F:CbcSolver.startTime_">
Cpu time at instantiation
</member>
        <member name="F:CbcSolver.callBack_">
Stop now stuff
</member>
        <member name="F:CbcSolver.numberCutGenerators_">
Number of cut generators
</member>
        <member name="F:CbcSolver.numberUserFunctions_">
Number of user functions
</member>
        <member name="F:CbcSolver.cutGenerator_">
Cut generators
</member>
        <member name="F:CbcSolver.originalCoinModel_">
Copy of model on initial load
</member>
        <member name="F:CbcSolver.originalSolver_">
Copy of model on initial load (will contain output solutions)
</member>
        <member name="F:CbcSolver.statusUserFunction_">
Status of user functions
        0 - not used
        1 - needs cbc_load
        2 - available - data in coinModel
        3 - data loaded - can do cbc_save

</member>
        <member name="F:CbcSolver.userFunction_">
User functions
</member>
        <member name="F:CbcSolver.babModel_">
Updated model
</member>
        <member name="F:CbcSolver.model_">
@name Private member data
Reference model
</member>
        <member name="M:CbcSolver.setReadMode(System.Int32)">
Where to start reading commands
</member>
        <member name="M:CbcSolver.setPrinting(System.Boolean)">
Whether to print to std::cout
</member>
        <member name="M:CbcSolver.startTime">
Start time
</member>
        <member name="M:CbcSolver.cutGeneratorArray">
Cut generator array
</member>
        <member name="M:CbcSolver.numberCutGenerators">
Number of cutgenerators
</member>
        <member name="M:CbcSolver.setOriginalCoinModel(CoinModel*)">
Copy of model on initial load
</member>
        <member name="M:CbcSolver.setOriginalSolver(OsiClpSolverInterface*)">
Copy of model on initial load (will contain output solutions)
</member>
        <member name="M:CbcSolver.originalCoinModel">
Copy of model on initial load
</member>
        <member name="M:CbcSolver.originalSolver">
Copy of model on initial load (will contain output solutions)
</member>
        <member name="M:CbcSolver.userFunctionArray">
User function array
</member>
        <member name="M:CbcSolver.numberUserFunctions">
Number of userFunctions
</member>
        <member name="M:CbcSolver.babModel">
Return updated Cbc model
</member>
        <member name="M:CbcSolver.model">
Return original Cbc model
</member>
        <member name="M:CbcSolver.userFunction(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
User function (NULL if no match)
</member>
        <member name="M:CbcSolver.setDoubleValue(CbcOrClpParameterType,System.Double)">
Set double value
</member>
        <member name="M:CbcSolver.doubleValue(CbcOrClpParameterType)">
Get double value
</member>
        <member name="M:CbcSolver.setIntValue(CbcOrClpParameterType,System.Int32)">
Set int value
</member>
        <member name="M:CbcSolver.intValue(CbcOrClpParameterType)">
@name useful stuff
Get int value
</member>
        <member name="M:CbcSolver.updateModel(ClpSimplex*,System.Int32)">
1 - add heuristics to model
        2 - do heuristics (and set cutoff and best solution)
        3 - for miplib test so skip some
        (out model later)

Updates model_ from babModel_ according to returnMode
        returnMode -
        0 model and solver untouched - babModel updated
        1 model updated - just with solution basis etc
        2 model updated i.e. as babModel (babModel NULL) (only use without preprocessing)

</member>
        <member name="M:CbcSolver.analyze(OsiClpSolverInterface*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,CoinMessageHandler*)">
@name miscellaneous methods to line up with old
</member>
        <member name="M:CbcSolver.addCutGenerator(CglCutGenerator*)">
Add cut generator
</member>
        <member name="M:CbcSolver.setUserCallBack(CbcStopNow*)">
Set user call back
</member>
        <member name="M:CbcSolver.addUserFunction(CbcUser*)">
Add user function
</member>
        <member name="M:CbcSolver.fillParameters">
Fill with standard parameters
</member>
        <member name="M:CbcSolver.Dispose">
Destructor
</member>
        <member name="M:CbcSolver.op_Assign(CbcSolver!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcSolver.#ctor(CbcSolver!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor .

</member>
        <member name="M:CbcSolver.#ctor(CbcModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor from model
</member>
        <member name="M:CbcSolver.#ctor(OsiClpSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor from solver
</member>
        <member name="M:CbcSolver.#ctor">
@name Constructors and destructors etc
Default Constructor
</member>
        <member name="M:CbcSolver.solve(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
This takes a list of commands, does "stuff" and returns
        returnMode -
        0 model and solver untouched - babModel updated
        1 model updated - just with solution basis etc
        2 model updated i.e. as babModel (babModel NULL) (only use without preprocessing)

</member>
        <member name="M:CbcSolver.solve(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.Int32)">
@name Solve method
This takes a list of commands, does "stuff" and returns
        returnMode -
        0 model and solver untouched - babModel updated
        1 model updated - just with solution basis etc
        2 model updated i.e. as babModel (babModel NULL) (only use without preprocessing)

</member>
        <member name="M:CoinReadNextField">
Simple read stuff
</member>
        <member name="F:CbcOrClpParam.fakeValue_">
Return this as main value if an integer
</member>
        <member name="F:CbcOrClpParam.fakeKeyWord_">
If &gt;=0 then integers allowed as a fake keyword
	 So minusnnnn would got to -nnnn in currentKeyword_
	 and plusnnnn would go to fakeKeyword_+nnnn

</member>
        <member name="F:CbcOrClpParam.whereUsed_">
7 if used everywhere,
         1 - used by clp
         2 - used by cbc
         4 - used by ampl

</member>
        <member name="F:CbcOrClpParam.stringValue_">
String parameter - current value
</member>
        <member name="F:CbcOrClpParam.doubleValue_">
Double parameter - current value
</member>
        <member name="F:CbcOrClpParam.intValue_">
Integer parameter - current value
</member>
        <member name="F:CbcOrClpParam.display_">
Display on ?
</member>
        <member name="F:CbcOrClpParam.currentKeyWord_">
Current keyWord (if a keyword parameter)
</member>
        <member name="F:CbcOrClpParam.action_">
Action
</member>
        <member name="F:CbcOrClpParam.longHelp_">
Long help
</member>
        <member name="F:CbcOrClpParam.shortHelp_">
Short help
</member>
        <member name="F:CbcOrClpParam.name_">
Name
</member>
        <member name="F:CbcOrClpParam.definedKeyWords_">
set of valid strings
</member>
        <member name="F:CbcOrClpParam.lowerIntValue_">
If int == okay
</member>
        <member name="F:CbcOrClpParam.lowerDoubleValue_">
If double == okay
</member>
        <member name="F:CbcOrClpParam.type_">
@name data
      We might as well throw all type data in - could derive?

</member>
        <member name="M:CbcOrClpParam.gutsOfConstructor">
gutsOfConstructor
</member>
        <member name="M:CbcOrClpParam.setFakeKeyWord(System.Int32)">
Sets value of fake keyword to current size of keywords
</member>
        <member name="M:CbcOrClpParam.setFakeKeyWord(System.Int32,System.Int32)">
Sets value of fake keyword
</member>
        <member name="M:CbcOrClpParam.fakeKeyWord">
Gets value of fake keyword
</member>
        <member name="M:CbcOrClpParam.whereUsed">
7 if used everywhere,
         1 - used by clp
         2 - used by cbc
         4 - used by ampl

</member>
        <member name="M:CbcOrClpParam.printString">
Print action and string
</member>
        <member name="M:CbcOrClpParam.printLongHelp">
Print Long help
</member>
        <member name="M:CbcOrClpParam.setLonghelp(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
Set Long help
</member>
        <member name="M:CbcOrClpParam.displayThis">
whether to display
</member>
        <member name="M:CbcOrClpParam.type">
type
</member>
        <member name="M:CbcOrClpParam.matches(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
Returns 1 if matches minimum, 2 if matches less, 0 if not matched
</member>
        <member name="M:CbcOrClpParam.setStringValue(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
Sets string value
</member>
        <member name="M:CbcOrClpParam.setDoubleValueWithMessage(System.Double)">
Sets double value with message
</member>
        <member name="M:CbcOrClpParam.setDoubleValue(System.Double)">
Sets double value
</member>
        <member name="M:CbcOrClpParam.setIntValueWithMessage(System.Int32)">
Sets int value with message
</member>
        <member name="M:CbcOrClpParam.setIntValue(System.Int32)">
Sets int value
</member>
        <member name="M:CbcOrClpParam.currentOptionAsInteger(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns current parameter option position
	 but if fake keyword returns a fake value and sets
	 fakeInteger to true value.  If not fake then fakeInteger is -COIN_INT_MAX

</member>
        <member name="M:CbcOrClpParam.currentOptionAsInteger">
Returns current parameter option position
</member>
        <member name="M:CbcOrClpParam.setCurrentOptionWithMessage(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
Sets current parameter option using string with message
</member>
        <member name="M:CbcOrClpParam.setCurrentOption(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst)">
Sets current parameter option using string
</member>
        <member name="M:CbcOrClpParam.setCurrentOptionWithMessage(System.Int32)">
Sets current parameter option and returns printable string
</member>
        <member name="M:CbcOrClpParam.setCurrentOption(System.Int32,System.Boolean)">
Sets current parameter option
</member>
        <member name="M:CbcOrClpParam.currentOption">
Returns current parameter option
</member>
        <member name="M:CbcOrClpParam.printOptions">
Prints parameter options
</member>
        <member name="M:CbcOrClpParam.parameterOption(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
Returns parameter option which matches (-1 if none)
</member>
        <member name="M:CbcOrClpParam.lengthMatchName">
Returns length of name for ptinting
</member>
        <member name="M:CbcOrClpParam.matchName">
Returns name which could match
</member>
        <member name="M:CbcOrClpParam.checkDoubleParameter(System.Double)">
Checks a double parameter (nonzero code if error)
</member>
        <member name="M:CbcOrClpParam.intParameter(OsiSolverInterface*)">
Gets a int parameter
</member>
        <member name="M:CbcOrClpParam.setIntParameterWithMessage(OsiSolverInterface*,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets int parameter and returns printable string and error code
</member>
        <member name="M:CbcOrClpParam.setIntParameter(OsiSolverInterface*,System.Int32)">
Sets a int parameter (nonzero code if error)
</member>
        <member name="M:CbcOrClpParam.doubleParameter(OsiSolverInterface*)">
Gets a double parameter
</member>
        <member name="M:CbcOrClpParam.setDoubleParameterWithMessage(OsiSolverInterface*,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets double parameter and returns printable string and error code
</member>
        <member name="M:CbcOrClpParam.setDoubleParameter(OsiSolverInterface*,System.Double)">
Sets a double parameter (nonzero code if error)
</member>
        <member name="M:CbcOrClpParam.intParameter(ClpSimplex*)">
Gets a int parameter
</member>
        <member name="M:CbcOrClpParam.setIntParameterWithMessage(ClpSimplex*,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets int parameter and returns printable string and error code
</member>
        <member name="M:CbcOrClpParam.setIntParameter(ClpSimplex*,System.Int32)">
Sets a int parameter (nonzero code if error)
</member>
        <member name="M:CbcOrClpParam.setDoubleParameterWithMessage(ClpSimplex*,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets double parameter and returns printable string and error code
</member>
        <member name="M:CbcOrClpParam.doubleParameter(ClpSimplex*)">
Gets a double parameter
</member>
        <member name="M:CbcOrClpParam.setDoubleParameter(ClpSimplex*,System.Double)">
Sets a double parameter (nonzero code if error)
</member>
        <member name="M:CbcOrClpParam.intParameter(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a int parameter
</member>
        <member name="M:CbcOrClpParam.setIntParameterWithMessage(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets int parameter and returns printable string and error code
</member>
        <member name="M:CbcOrClpParam.setIntParameter(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Sets a int parameter (nonzero code if error)
</member>
        <member name="M:CbcOrClpParam.doubleParameter(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Gets a double parameter
</member>
        <member name="M:CbcOrClpParam.setDoubleParameterWithMessage(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets double parameter and returns printable string and error code
</member>
        <member name="M:CbcOrClpParam.setDoubleParameter(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Sets a double parameter (nonzero code if error)
</member>
        <member name="M:CbcOrClpParam.upperIntValue">
Returns the upper bound for an int-valued parameter
</member>
        <member name="M:CbcOrClpParam.lowerIntValue">
Returns the lower bound for an int-valued parameter
</member>
        <member name="M:CbcOrClpParam.upperDoubleValue">
Returns the upper bound for a double-valued parameter
</member>
        <member name="M:CbcOrClpParam.lowerDoubleValue">
Returns the lower bound for a double-valued parameter
</member>
        <member name="M:CbcOrClpParam.definedKeywords">
Returns set of valid strings
</member>
        <member name="M:CbcOrClpParam.longHelp">
Returns long help
</member>
        <member name="M:CbcOrClpParam.shortHelp">
Returns short help
</member>
        <member name="M:CbcOrClpParam.name">
Returns name
</member>
        <member name="M:CbcOrClpParam.addHelp(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
Adds one help line
</member>
        <member name="M:CbcOrClpParam.append(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
@name stuff 
Insert string (only valid for keywords)
</member>
        <member name="M:CbcOrClpParam.Dispose">
Destructor
</member>
        <member name="M:CbcOrClpParam.op_Assign(CbcOrClpParam!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. This copies the data
</member>
        <member name="M:CbcOrClpParam.#ctor(CbcOrClpParam!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:CbcOrClpParam.#ctor">
@name Constructor and destructor 
Constructors
</member>
        <member name="T:CbcOrClpParam">
Very simple class for setting parameters
</member>
        <member name="T:OsiSolverInterface">
   This has parameter handling stuff which can be shared between Cbc and Clp (and Dylp etc).

   This (and .cpp) should be copied so that it is the same in Cbc/Test and Clp/Test.
   I know this is not elegant but it seems simplest.

   It uses COIN_HAS_CBC for parameters wanted by CBC
   It uses COIN_HAS_CLP for parameters wanted by CLP (or CBC using CLP)
   It could use COIN_HAS_DYLP for parameters wanted by DYLP
   It could use COIN_HAS_DYLP_OR_CLP for parameters wanted by DYLP or CLP etc etc


</member>
        <member name="M:OsiClpSolverInterfaceUnitTest(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A function that tests the methods in the OsiClpSolverInterface class. 
</member>
        <member name="F:OsiClpDisasterHandler.inTrouble_">
Are we in trouble
</member>
        <member name="F:OsiClpDisasterHandler.phase_">
phase
      0 initial
      1 trying continuing with back in and maybe different perturb
      2 trying continuing with back in and different scaling
      3 trying dual from all slack
      4 trying primal from previous stored basis

</member>
        <member name="F:OsiClpDisasterHandler.whereFrom_">
Where from 
      0 dual (resolve)
      1 crunch
      2 primal (resolve)
      4 dual (initialSolve)
      6 primal (initialSolve)

</member>
        <member name="F:OsiClpDisasterHandler.osiModel_">
@name Data members
     The data members are protected to allow access for derived classes. 
Pointer to model
</member>
        <member name="M:OsiClpDisasterHandler.inTrouble">
are we in trouble
</member>
        <member name="M:OsiClpDisasterHandler.phase">
Get phase
</member>
        <member name="M:OsiClpDisasterHandler.setPhase(System.Int32)">
Set phase
</member>
        <member name="M:OsiClpDisasterHandler.whereFrom">
Get where from
</member>
        <member name="M:OsiClpDisasterHandler.setWhereFrom(System.Int32)">
Set where from
</member>
        <member name="M:OsiClpDisasterHandler.osiModel">
Get model
</member>
        <member name="M:OsiClpDisasterHandler.setOsiModel(OsiClpSolverInterface*)">
@name Sets/gets 
set model. 
</member>
        <member name="M:OsiClpDisasterHandler.clone">
Clone
</member>
        <member name="M:OsiClpDisasterHandler.Dispose">
Destructor 
</member>
        <member name="M:OsiClpDisasterHandler.#ctor(OsiClpSolverInterface*)">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:OsiClpDisasterHandler.typeOfDisaster">
Type of disaster 0 can fix, 1 abort
</member>
        <member name="M:OsiClpDisasterHandler.saveInfo">
saves information for next attempt
</member>
        <member name="M:OsiClpDisasterHandler.check">
Checks if disaster
</member>
        <member name="M:OsiClpDisasterHandler.intoSimplex">
@name Virtual methods that the derived classe should provide.

Into simplex
</member>
        <member name="F:OsiClpSolverInterface.columnScale_">
Column scale factors (has inverse at end)
</member>
        <member name="F:OsiClpSolverInterface.rowScale_">
Row scale factors (has inverse at end)
</member>
        <member name="F:OsiClpSolverInterface.fakeObjective_">
Fake objective
</member>
        <member name="F:OsiClpSolverInterface.disasterHandler_">
Possible disaster handler
</member>
        <member name="F:OsiClpSolverInterface.continuousModel_">
Continuous model
</member>
        <member name="F:OsiClpSolverInterface.lastNumberRows_">
Number of rows when last "scaled"
</member>
        <member name="F:OsiClpSolverInterface.baseModel_">
Copy of model when option 131072 set
</member>
        <member name="F:OsiClpSolverInterface.specialOptions_">
Special options
      0x80000000 off
      0 simple stuff for branch and bound
      1 try and keep work regions as much as possible
      2 do not use any perturbation
      4 allow exit before re-factorization
      8 try and re-use factorization if no cuts
      16 use standard strong branching rather than clp's
      32 Just go to first factorization in fast dual
      64 try and tighten bounds in crunch
      128 Model will only change in column bounds
      256 Clean up model before hot start
      512 Give user direct access to Clp regions in getBInvARow etc (i.e.,
          do not unscale, and do not return result in getBInv parameters;
	  you have to know where to look for the answer)
      1024 Don't "borrow" model in initialSolve
      2048 Don't crunch
      4096 quick check for optimality
      Bits above 8192 give where called from in Cbc
      At present 0 is normal, 1 doing fast hotstarts, 2 is can do quick check
      65536 Keep simple i.e. no  crunch etc
      131072 Try and keep scaling factors around
      262144 Don't try and tighten bounds (funny global cuts)
      524288 Fake objective and 0-1
      1048576 Don't recompute ray after crunch
      2097152 
      8388608 Odd integers e.g. semi-continuous

</member>
        <member name="F:OsiClpSolverInterface.cleanupScaling_">
Scaling option
      When scaling is on it is possible that the scaled problem
      is feasible but the unscaled is not.  Clp returns a secondary
      status code to that effect.  This option allows for a cleanup.
      If you use it I would suggest 1.
      This only affects actions when scaled optimal
      0 - no action
      1 - clean up using dual if primal infeasibility
      2 - clean up using dual if dual infeasibility
      3 - clean up using dual if primal or dual infeasibility
      11,12,13 - as 1,2,3 but use primal

</member>
        <member name="F:OsiClpSolverInterface.solveOptions_">
Options for initialSolve
</member>
        <member name="F:OsiClpSolverInterface.saveData_">
To save data in OsiSimplex stuff
</member>
        <member name="F:OsiClpSolverInterface.whichRange_">
Pointer to variables for which we want range information
      The number is in [0]
      memory is not owned by OsiClp

</member>
        <member name="F:OsiClpSolverInterface.integerInformation_">
Pointer to integer information
</member>
        <member name="F:OsiClpSolverInterface.matrixByRowAtContinuous_">
Pointer to row-wise copy of continuous problem matrix coefficients.
</member>
        <member name="F:OsiClpSolverInterface.matrixByRow_">
Pointer to row-wise copy of problem matrix coefficients.
</member>
        <member name="F:OsiClpSolverInterface.notOwned_">
To say if destructor should delete underlying model
</member>
        <member name="F:OsiClpSolverInterface.itlimOrig_">
The original iteration limit before hotstarts started. 
</member>
        <member name="F:OsiClpSolverInterface.basis_">
Warmstart information to be used in resolves. 
</member>
        <member name="F:OsiClpSolverInterface.spareArrays_">
Arrays for hot starts
</member>
        <member name="F:OsiClpSolverInterface.largestAway_">
Largest amount continuous away from bound
</member>
        <member name="F:OsiClpSolverInterface.smallestElementInCut_">
Smallest allowed element in cut.
      If smaller than this then ignored 
</member>
        <member name="F:OsiClpSolverInterface.factorization_">
factorization for hot starts
</member>
        <member name="F:OsiClpSolverInterface.smallModel_">
Alternate model (hot starts) - but also could be permanent and used for crunch
</member>
        <member name="F:OsiClpSolverInterface.setInfo_">
SOS set info
</member>
        <member name="F:OsiClpSolverInterface.numberSOS_">
Number of SOS sets
</member>
        <member name="F:OsiClpSolverInterface.stuff_">
Stuff for fast dual
</member>
        <member name="F:OsiClpSolverInterface.rowActivity_">
also save row and column information for hot starts
      only used in hotstarts so can be casual 
</member>
        <member name="F:OsiClpSolverInterface.ws_">
A pointer to the warmstart information to be used in the hotstarts.
      This is NOT efficient and more thought should be given to it... 
</member>
        <member name="F:OsiClpSolverInterface.rowrange_">
Pointer to dense vector of slack upper bounds for range 
      constraints (undefined for non-range rows)

</member>
        <member name="F:OsiClpSolverInterface.rhs_">
Pointer to dense vector of row right-hand side values
</member>
        <member name="F:OsiClpSolverInterface.rowsense_">
@name Cached information derived from the OSL model 
Pointer to dense vector of row sense indicators
</member>
        <member name="F:OsiClpSolverInterface.modelPtr_">
@name Protected member data 
Clp model represented by this class instance
</member>
        <member name="M:OsiClpSolverInterface.setContinuousModel(ClpSimplex*)">
Set continuous model
</member>
        <member name="M:OsiClpSolverInterface.getContinuousModel">
Get continuous model
</member>
        <member name="M:OsiClpSolverInterface.lexSolve">
Sort of lexicographic resolve
</member>
        <member name="M:OsiClpSolverInterface.setLargestAway(System.Double)">
Set largest amount continuous away from bound
</member>
        <member name="M:OsiClpSolverInterface.largestAway">
Get largest amount continuous away from bound
</member>
        <member name="M:OsiClpSolverInterface.computeLargestAway">
Compute largest amount any at continuous away from bound
</member>
        <member name="M:OsiClpSolverInterface.setSOSData(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Pass in sos stuff from AMPl
</member>
        <member name="M:OsiClpSolverInterface.passInRanges(System.Int32*)">
Pass in range array
</member>
        <member name="M:OsiClpSolverInterface.upRange">
If doing fast hot start then ranges are computed
</member>
        <member name="M:OsiClpSolverInterface.deleteScaleFactors">
Delete all scale factor stuff and reset option
</member>
        <member name="M:OsiClpSolverInterface.getBasis(System.Byte!System.Runtime.CompilerServices.IsConst*)">
Warm start from statusArray
</member>
        <member name="M:OsiClpSolverInterface.getBasisDiff(System.Byte!System.Runtime.CompilerServices.IsConst*)">
Warm start difference from basis_ to statusArray
</member>
        <member name="M:OsiClpSolverInterface.setBasis">
Just puts current basis_ into ClpSimplex model
</member>
        <member name="M:OsiClpSolverInterface.setBasis(CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets up working basis as a copy of input and puts in as basis

</member>
        <member name="M:OsiClpSolverInterface.redoScaleFactors(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Extend scale factors
</member>
        <member name="M:OsiClpSolverInterface.crunch">
Crunch down problem a bit
</member>
        <member name="M:OsiClpSolverInterface.extractSenseRhsRange">
A method that fills up the rowsense_, rhs_ and rowrange_ arrays
</member>
        <member name="M:OsiClpSolverInterface.freeCachedResults1">
Deletes all mutable stuff for matrix etc
</member>
        <member name="M:OsiClpSolverInterface.freeCachedResults0">
Deletes all mutable stuff for row ranges etc
</member>
        <member name="M:OsiClpSolverInterface.freeCachedResults">
Deletes all mutable stuff
</member>
        <member name="M:OsiClpSolverInterface.gutsOfDestructor">
@name Protected methods 
The real work of a copy constructor (used by copy and assignment)
</member>
        <member name="M:OsiClpSolverInterface.applyColCut(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply a column cut (adjust one or more bounds). 
</member>
        <member name="M:OsiClpSolverInterface.applyRowCut(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Protected methods
Apply a row cut (append to constraint matrix). 
</member>
        <member name="M:OsiClpSolverInterface.reset">
Resets as if default constructor
</member>
        <member name="M:OsiClpSolverInterface.Dispose">
Destructor
</member>
        <member name="M:OsiClpSolverInterface.op_Assign(OsiClpSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiClpSolverInterface.releaseClp">
Releases so won't error
</member>
        <member name="M:OsiClpSolverInterface.#ctor(ClpSimplex*,System.Boolean)">
Borrow constructor - only delete one copy
</member>
        <member name="M:OsiClpSolverInterface.#ctor(OsiClpSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiClpSolverInterface.clone(System.Boolean)">
Clone
</member>
        <member name="M:OsiClpSolverInterface.#ctor">
@name Constructors and destructors 
Default Constructor
</member>
        <member name="M:OsiClpSolverInterface.synchronizeModel">
Synchronize model (really if no cuts in tree)
</member>
        <member name="M:OsiClpSolverInterface.setFakeObjective(System.Double*)">
Set fake objective
</member>
        <member name="M:OsiClpSolverInterface.setFakeObjective(ClpLinearObjective*)">
Set fake objective (and take ownership)
</member>
        <member name="M:OsiClpSolverInterface.fakeObjective">
Get fake objective
</member>
        <member name="M:OsiClpSolverInterface.passInDisasterHandler(OsiClpDisasterHandler*)">
Pass in disaster handler
</member>
        <member name="M:OsiClpSolverInterface.disasterHandler">
Get disaster handler
</member>
        <member name="M:OsiClpSolverInterface.getSizeU">
Return number of entries in U part of current factorization
</member>
        <member name="M:OsiClpSolverInterface.getSizeL">
Return number of entries in L part of current factorization
</member>
        <member name="M:OsiClpSolverInterface.infeasibleOtherWay(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
See if any integer variables make infeasible other way
</member>
        <member name="M:OsiClpSolverInterface.tightenBounds(System.Int32)">
Tighten bounds - lightweight or very lightweight
      0 - normal, 1 lightweight but just integers, 2 lightweight and all

</member>
        <member name="M:OsiClpSolverInterface.setSolveOptions(ClpSolve!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Pass in initial solve options
</member>
        <member name="M:OsiClpSolverInterface.setSmallestElementInCut(System.Double)">
Set smallest allowed element in cut.
      If smaller than this then ignored 
</member>
        <member name="M:OsiClpSolverInterface.smallestElementInCut">
Get smallest allowed element in cut.
      If smaller than this then ignored 
</member>
        <member name="M:OsiClpSolverInterface.setCleanupScaling(System.Int32)">
Set Scaling option
      When scaling is on it is possible that the scaled problem
      is feasible but the unscaled is not.  Clp returns a secondary
      status code to that effect.  This option allows for a cleanup.
      If you use it I would suggest 1.
      This only affects actions when scaled optimal
      0 - no action
      1 - clean up using dual if primal infeasibility
      2 - clean up using dual if dual infeasibility
      3 - clean up using dual if primal or dual infeasibility
      11,12,13 - as 1,2,3 but use primal

</member>
        <member name="M:OsiClpSolverInterface.cleanupScaling">
Get scaling action option
</member>
        <member name="M:OsiClpSolverInterface.setLastAlgorithm(System.Int32)">
Set last algorithm used , 1 = primal, 2 = dual other unknown
</member>
        <member name="M:OsiClpSolverInterface.lastAlgorithm">
Last algorithm used , 1 = primal, 2 = dual other unknown
</member>
        <member name="M:OsiClpSolverInterface.specialOptions">
Get special options
</member>
        <member name="M:OsiClpSolverInterface.swapModelPtr(ClpSimplex*)">
Set pointer to Clp model and return old
</member>
        <member name="M:OsiClpSolverInterface.getModelPtr">
@name Clp specific public interfaces 
Get pointer to Clp model
</member>
        <member name="M:OsiClpSolverInterface.generateCpp(_iobuf*)">
Create C++ lines to get to current state
</member>
        <member name="M:OsiClpSolverInterface.setLogLevel(System.Int32)">
Set log level (will also set underlying solver's log level)
</member>
        <member name="M:OsiClpSolverInterface.newLanguage(CoinMessages.Language)">
Set language
</member>
        <member name="M:OsiClpSolverInterface.passInMessageHandler(CoinMessageHandler*)">
@name Message handling (extra for Clp messages).
     Normally I presume you would want the same language.
     If not then you could use underlying model pointer 
Pass in a message handler
      
      It is the client's responsibility to destroy a message handler installed
      by this routine; it will not be destroyed when the solver interface is
      destroyed. 

</member>
        <member name="M:OsiClpSolverInterface.replaceMatrix(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
And if it does matter (not used at present)
</member>
        <member name="M:OsiClpSolverInterface.replaceMatrixOptional(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
I (JJF) am getting annoyed because I can't just replace a matrix.
The default behavior of this is do nothing so only use where that would not matter
e.g. strengthening a matrix for MIP

</member>
        <member name="M:OsiClpSolverInterface.writeLp(_iobuf*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)">
Write the problem into the file pointed to by the parameter fp. 
      Other parameters are similar to 
      those of writeLp() with first parameter filename.

</member>
        <member name="M:OsiClpSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)">
Write the problem into an Lp file of the given filename.
      If objSense is non zero then -1.0 forces the code to write a
      maximization objective and +1.0 to write a minimization one.
      If 0.0 then solver can do what it wants.
      This version calls writeLpNative with names 
</member>
        <member name="M:OsiClpSolverInterface.readLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
Read file in LP format (with names)
</member>
        <member name="M:OsiClpSolverInterface.writeMpsNative(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.Int32,System.Int32,System.Double)">
Write the problem into an mps file of the given filename,
      names may be null.  formatType is
      0 - normal
      1 - extra accuracy 
      2 - IEEE hex (later)
      
      Returns non-zero on I/O error

</member>
        <member name="M:OsiClpSolverInterface.writeMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double)">
Write the problem into an mps file of the given filename.
      If objSense is non zero then -1.0 forces the code to write a
      maximization objective and +1.0 to write a minimization one.
      If 0.0 then solver can do what it wants 
</member>
        <member name="M:OsiClpSolverInterface.readMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinSet***!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Read an mps file
</member>
        <member name="M:OsiClpSolverInterface.readMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
Read an mps file from the given filename returns
      number of errors (see OsiMpsReader class) 
</member>
        <member name="M:OsiClpSolverInterface.readMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Read an mps file from the given filename (defaults to Osi reader) - returns
      number of errors (see OsiMpsReader class) 
</member>
        <member name="M:OsiClpSolverInterface.loadFromCoinModel(CoinModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
This loads a model from a coinModel object - returns number of errors
</member>
        <member name="M:OsiClpSolverInterface.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Just like the other loadProblem() methods except that the matrix is
      given in a standard column major ordered format (without gaps). 
</member>
        <member name="M:OsiClpSolverInterface.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Just like the other loadProblem() methods except that the matrix is
      given in a standard column major ordered format (without gaps). 
</member>
        <member name="M:OsiClpSolverInterface.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Just like the other loadProblem() methods except that the matrix is
      given as a ClpMatrixBase. 
</member>
        <member name="M:OsiClpSolverInterface.applyRowCuts(System.Int32,OsiRowCut!System.Runtime.CompilerServices.IsConst**)">
Apply a collection of row cuts which are all effective.
      applyCuts seems to do one at a time which seems inefficient.
      This uses array of pointers

</member>
        <member name="M:OsiClpSolverInterface.applyRowCuts(System.Int32,OsiRowCut!System.Runtime.CompilerServices.IsConst*)">
Apply a collection of row cuts which are all effective.
      applyCuts seems to do one at a time which seems inefficient.

</member>
        <member name="M:OsiClpSolverInterface.restoreBaseModel(System.Int32)">
Strip off rows to get to this number of rows.
      If solver wants it can restore a copy of "base" (continuous) model here

</member>
        <member name="M:OsiClpSolverInterface.saveBaseModel">
If solver wants it can save a copy of "base" (continuous) model here

</member>
        <member name="M:OsiClpSolverInterface.addRow(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Add a row (constraint) to the problem. 
</member>
        <member name="M:OsiClpSolverInterface.addCol(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Add a column (primal variable) to the problem. 
</member>
        <member name="M:OsiClpSolverInterface.setRowPrice(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set dual solution vector
      
  rowprice[numrows()] is an array of values of the problem row
  dual variables. These values are copied to memory owned by the
  solver object or the solver.  They will be returned as the
  result of rowprice() until changed by another call to
  setRowprice() or by a call to any solver routine.  Whether the
  solver makes use of the solution in any way is
  solver-dependent. 

</member>
        <member name="M:OsiClpSolverInterface.setColSolution(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the primal solution column values
      
  colsol[numcols()] is an array of values of the problem column
  variables. These values are copied to memory owned by the
  solver object or the solver.  They will be returned as the
  result of colsol() until changed by another call to
  setColsol() or by a call to any solver routine.  Whether the
  solver makes use of the solution in any way is
  solver-dependent. 

</member>
        <member name="M:OsiClpSolverInterface.setObjSense(System.Double)">
Set objective function sense (1 for min (default), -1 for max,)
</member>
        <member name="M:OsiClpSolverInterface.findIntegersAndSOS(System.Boolean)">
\brief Identify integer variables and SOS and create corresponding objects.
  
    Record integer variables and create an OsiSimpleInteger object for each
    one.  All existing OsiSimpleInteger objects will be destroyed.
    If the solver supports SOS then do the same for SOS.
     If justCount then no objects created and we just store numberIntegers_
    Returns number of SOS

</member>
        <member name="M:OsiClpSolverInterface.replaceSetInfo(System.Int32,CoinSet*)">
Replace setInfo (takes over ownership)
</member>
        <member name="M:OsiClpSolverInterface.setInfo">
SOS set info
</member>
        <member name="M:OsiClpSolverInterface.numberSOS">
Number of SOS sets
</member>
        <member name="M:OsiClpSolverInterface.setInteger(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Set the variables listed in indices (which is of length len) to be
      integer variables 
</member>
        <member name="M:OsiClpSolverInterface.setContinuous(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Set the variables listed in indices (which is of length len) to be
      continuous variables 
</member>
        <member name="M:OsiClpSolverInterface.setInteger(System.Int32)">
Set the index-th variable to be an integer variable 
</member>
        <member name="M:OsiClpSolverInterface.setContinuous(System.Int32)">
@name Integrality related changing methods 
Set the index-th variable to be a continuous variable 
</member>
        <member name="M:OsiClpSolverInterface.setColName(System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
Set name of column
</member>
        <member name="M:OsiClpSolverInterface.setRowName(System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;)">
Set name of row
</member>
        <member name="M:OsiClpSolverInterface.setColUpper(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the upper bounds for all columns
	array [getNumCols()] is an array of values for the objective.
        This defaults to a series of set operations and is here for speed.

</member>
        <member name="M:OsiClpSolverInterface.setColLower(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the lower bounds for all columns
	array [getNumCols()] is an array of values for the objective.
        This defaults to a series of set operations and is here for speed.

</member>
        <member name="M:OsiClpSolverInterface.setObjective(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the objective coefficients for all columns
	array [getNumCols()] is an array of values for the objective.
        This defaults to a series of set operations and is here for speed.

</member>
        <member name="M:OsiClpSolverInterface.setRowBounds(System.Int32,System.Double,System.Double)">
Set a single row lower and upper bound 
</member>
        <member name="M:OsiClpSolverInterface.setColBounds(System.Int32,System.Double,System.Double)">
Set a single column lower and upper bound 
</member>
        <member name="M:OsiClpSolverInterface.setObjCoeff(System.Int32,System.Double)">
@name Problem modifying methods 
@name Changing bounds on variables and constraints 
Set an objective function coefficient 
</member>
        <member name="M:OsiClpSolverInterface.getIterationCount">
Get how many iterations it took to solve the problem (whatever
      "iteration" mean to the solver. 
</member>
        <member name="M:OsiClpSolverInterface.getObjValue">
Get objective function value
</member>
        <member name="M:OsiClpSolverInterface.getRowActivity">
Get pointer to array[getNumRows()] of row activity levels (constraint
      matrix times the solution vector 
</member>
        <member name="M:OsiClpSolverInterface.getReducedCost">
Get a pointer to array[getNumCols()] of reduced costs
</member>
        <member name="M:OsiClpSolverInterface.getRowPrice">
Get pointer to array[getNumRows()] of dual prices
</member>
        <member name="M:OsiClpSolverInterface.getColSolution">
@name Methods related to querying the solution 
Get pointer to array[getNumCols()] of primal solution vector
</member>
        <member name="M:OsiClpSolverInterface.getInfinity">
Get solver's value for infinity
</member>
        <member name="M:OsiClpSolverInterface.getMutableMatrixByCol">
Get pointer to mutable column-wise copy of matrix
</member>
        <member name="M:OsiClpSolverInterface.getMatrixByCol">
Get pointer to column-wise copy of matrix
</member>
        <member name="M:OsiClpSolverInterface.getMatrixByRow">
Get pointer to row-wise copy of matrix
</member>
        <member name="M:OsiClpSolverInterface.setIntegerType(System.Int32,System.Int32)">
Set integer type (0,1,2=optional,3=sc,4=scint)
</member>
        <member name="M:OsiClpSolverInterface.integerType(System.Int32)">
Return integer type (0,1,2=optional,3=sc,4=scint)
</member>
        <member name="M:OsiClpSolverInterface.isHeuristicInteger(System.Int32)">
Return true only if integer and not optional
</member>
        <member name="M:OsiClpSolverInterface.setOptionalInteger(System.Int32)">
Set the index-th variable to be an optional integer variable 
</member>
        <member name="M:OsiClpSolverInterface.isOptionalInteger(System.Int32)">
Return true if column is integer but does not have to
      be declared as such.
      Note: This function returns true if the the column
      is binary or a general integer.

</member>
        <member name="M:OsiClpSolverInterface.getColType(System.Boolean)">
Return array of column length
      0 - continuous
      1 - binary (may get fixed later)
      2 - general integer (may get fixed later)

</member>
        <member name="M:OsiClpSolverInterface.isFreeBinary(System.Int32)">
Return true if variable is binary and not fixed at either bound
</member>
        <member name="M:OsiClpSolverInterface.isIntegerNonBinary(System.Int32)">
Return true if variable is general integer
</member>
        <member name="M:OsiClpSolverInterface.isInteger(System.Int32)">
Return true if column is integer.
      Note: This function returns true if the the column
      is binary or a general integer.

</member>
        <member name="M:OsiClpSolverInterface.isBinary(System.Int32)">
Return true if variable is binary
</member>
        <member name="M:OsiClpSolverInterface.isContinuous(System.Int32)">
Return true if column is continuous
</member>
        <member name="M:OsiClpSolverInterface.getObjSense">
Get objective function sense (1 for min (default), -1 for max)
</member>
        <member name="M:OsiClpSolverInterface.getObjCoefficients">
Get pointer to array[getNumCols()] of objective function coefficients
</member>
        <member name="M:OsiClpSolverInterface.getRowUpper">
Get pointer to array[getNumRows()] of row upper bounds
</member>
        <member name="M:OsiClpSolverInterface.getRowLower">
Get pointer to array[getNumRows()] of row lower bounds
</member>
        <member name="M:OsiClpSolverInterface.getColUpper">
Get pointer to array[getNumCols()] of column upper bounds
</member>
        <member name="M:OsiClpSolverInterface.getColLower">
Get pointer to array[getNumCols()] of column lower bounds
</member>
        <member name="M:OsiClpSolverInterface.getColName(System.Int32,System.UInt32)">
Return name of column if one exists or Cnnnnnnn
maxLen is currently ignored and only there to match the signature from the base class!
</member>
        <member name="M:OsiClpSolverInterface.getRowName(System.Int32,System.UInt32)">
Return name of row if one exists or Rnnnnnnn
maxLen is currently ignored and only there to match the signature from the base class!
</member>
        <member name="M:OsiClpSolverInterface.getNumElements">
Get number of nonzero elements
</member>
        <member name="M:OsiClpSolverInterface.getNumRows">
Get number of rows
</member>
        <member name="M:OsiClpSolverInterface.getNumCols">
@name Problem information methods
     
  These methods call the solver's query routines to return
  information about the problem referred to by the current object.
  Querying a problem that has no data associated with it result in
  zeros for the number of rows and columns, and NULL pointers from
  the methods that return vectors.
  
  Const pointers returned from any data-query method are valid as
  long as the data is unchanged and the solver is not called.

@name Methods related to querying the input data 
Get number of columns
</member>
        <member name="M:OsiClpSolverInterface.modelCut(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Return a conflict analysis cut from model
      If type is 0 then genuine cut, if 1 then only partially processed

</member>
        <member name="M:OsiClpSolverInterface.smallModelCut(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Return a conflict analysis cut from small model
</member>
        <member name="M:OsiClpSolverInterface.setStuff(System.Double,System.Double)">
Sets integer tolerance and increment
</member>
        <member name="M:OsiClpSolverInterface.stopFastDual">
Stop fast dual
</member>
        <member name="M:OsiClpSolverInterface.startFastDual(System.Int32)">
Start faster dual - returns negative if problems 1 if infeasible,
      Options to pass to solver
      1 - create external reduced costs for columns
      2 - create external reduced costs for rows
      4 - create external row activity (columns always done)
      Above only done if feasible
      When set resolve does less work

</member>
        <member name="M:OsiClpSolverInterface.unmarkHotStart">
Delete the snapshot
</member>
        <member name="M:OsiClpSolverInterface.solveFromHotStart">
Optimize starting from the hotstart
</member>
        <member name="M:OsiClpSolverInterface.setColumnStatus(System.Int32,ClpSimplex.Status)">
Set column status in ClpSimplex and warmStart
</member>
        <member name="M:OsiClpSolverInterface.getPointerToWarmStart(System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Get warm start information.
      
      Return warm start information for the current state of the solver
      interface. If there is no valid warm start information, an empty warm
      start object wil be returned.  This does not necessarily create an 
      object - may just point to one.  must Delete set true if user
      should delete returned object.
      OsiClp version always returns pointer and false.

</member>
        <member name="M:OsiClpSolverInterface.setWarmStart(CoinWarmStart!System.Runtime.CompilerServices.IsConst*)">
Set warmstarting information. Return true/false depending on whether
      the warmstart information was accepted or not. 
</member>
        <member name="M:OsiClpSolverInterface.getConstPointerToWarmStart">
Get warmstarting information
</member>
        <member name="M:OsiClpSolverInterface.getPointerToWarmStart">
Get warmstarting information
</member>
        <member name="M:OsiClpSolverInterface.getWarmStart">
Get warmstarting information
</member>
        <member name="M:OsiClpSolverInterface.getEmptyWarmStart">
@name WarmStart related methods 
</member>
        <member name="M:OsiClpSolverInterface.isIterationLimitReached">
Iteration limit reached?
</member>
        <member name="M:OsiClpSolverInterface.isDualObjectiveLimitReached">
Is the given dual objective limit reached?
</member>
        <member name="M:OsiClpSolverInterface.isPrimalObjectiveLimitReached">
Is the given primal objective limit reached?
</member>
        <member name="M:OsiClpSolverInterface.isProvenDualInfeasible">
Is dual infeasiblity proven?
</member>
        <member name="M:OsiClpSolverInterface.isProvenPrimalInfeasible">
Is primal infeasiblity proven?
</member>
        <member name="M:OsiClpSolverInterface.isProvenOptimal">
Is optimality proven?
</member>
        <member name="M:OsiClpSolverInterface.isAbandoned">
@name Methods returning info on how the solution process terminated
Are there a numerical difficulties?
</member>
        <member name="M:OsiClpSolverInterface.setIntParam(OsiIntParam,System.Int32)">
@name Parameter set/get methods
     
  The set methods return true if the parameter was set to the given value,
  false otherwise. There can be various reasons for failure: the given
  parameter is not applicable for the solver (e.g., refactorization
  frequency for the clp algorithm), the parameter is not yet implemented
  for the solver or simply the value of the parameter is out of the range
  the solver accepts. If a parameter setting call returns false check the
  details of your solver.
  
  The get methods return true if the given parameter is applicable for the
  solver and is implemented. In this case the value of the parameter is
  returned in the second argument. Otherwise they return false.

</member>
        <member name="M:OsiClpSolverInterface.dualPivotResult(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVector*)">
Obtain a result of the dual pivot (similar to the previous method)
      Differences: entering variable and a sign of its change are now
      the outputs, the leaving variable and its statuts -- the inputs
      If dx!=NULL, then *dx contains dual ray
      Return code: same

</member>
        <member name="M:OsiClpSolverInterface.primalPivotResult(System.Int32,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVector*)">
Obtain a result of the primal pivot 
      Outputs: colOut -- leaving column, outStatus -- its status,
      t -- step size, and, if dx!=NULL, *dx -- primal ray direction.
      Inputs: colIn -- entering column, sign -- direction of its change (+/-1).
      Both for colIn and colOut, artificial variables are index by
      the negative of the row index minus 1.
      Return code (for now): 0 -- leaving variable found, 
      -1 -- everything else?
      Clearly, more informative set of return values is required 
      Primal and dual solutions are updated

</member>
        <member name="M:OsiClpSolverInterface.pivot(System.Int32,System.Int32,System.Int32)">
Perform a pivot by substituting a colIn for colOut in the basis. 
      The status of the leaving variable is given in statOut. Where
      1 is to upper bound, -1 to lower bound
      Return code is 0 for okay,
      1 if inaccuracy forced re-factorization (should be okay) and
      -1 for singular factorization

</member>
        <member name="M:OsiClpSolverInterface.getBasics(System.Int32*)">
Get basic indices (order of indices corresponds to the
      order of elements in a vector retured by getBInvACol() and
      getBInvCol()).

</member>
        <member name="M:OsiClpSolverInterface.getBInvCol(System.Int32,System.Double*)">
Get a column of the basis inverse
</member>
        <member name="M:OsiClpSolverInterface.getBInvACol(CoinIndexedVector*)">
Update (i.e. ftran) the vector passed in.
      Unscaling is applied after - can't be applied before

</member>
        <member name="M:OsiClpSolverInterface.getBInvACol(System.Int32,CoinIndexedVector*)">
Get a column of the tableau
</member>
        <member name="M:OsiClpSolverInterface.getBInvACol(System.Int32,System.Double*)">
Get a column of the tableau
</member>
        <member name="M:OsiClpSolverInterface.getBInvRow(System.Int32,System.Double*)">
Get a row of the basis inverse
</member>
        <member name="M:OsiClpSolverInterface.getBInvARow(System.Int32,CoinIndexedVector*,CoinIndexedVector*,System.Boolean)">
Get a row of the tableau (slack part in slack if not NULL)
      If keepScaled is true then scale factors not applied after so
      user has to use coding similar to what is in this method

</member>
        <member name="M:OsiClpSolverInterface.getBInvARow(System.Int32,System.Double*,System.Double*)">
Get a row of the tableau (slack part in slack if not NULL)
</member>
        <member name="M:OsiClpSolverInterface.getReducedGradient(System.Double*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Get the reduced gradient for the cost vector c
</member>
        <member name="M:OsiClpSolverInterface.basisIsAvailable">
Returns true if a basis is available
      AND problem is optimal.  This should be used to see if
      the BInvARow type operations are possible and meaningful. 

</member>
        <member name="M:OsiClpSolverInterface.canDoSimplexInterface">
\brief Simplex API capability.
  
    Returns
     - 0 if no simplex API
     - 1 if can just do getBInv etc
     - 2 if has all OsiSimplex methods

</member>
        <member name="M:OsiClpSolverInterface.crossover(System.Int32,System.Int32)">
Solve when primal column and dual row solutions are near-optimal
      options - 0 no presolve (use primal and dual)
                1 presolve (just use primal)
		2 no presolve (just use primal)
      basis -   0 use all slack basis
                1 try and put some in basis

</member>
        <member name="M:OsiClpSolverInterface.branchAndBound">
Invoke solver's built-in enumeration algorithm
</member>
        <member name="M:OsiClpSolverInterface.resolveGub(System.Int32)">
Resolve an LP relaxation after problem modification (try GUB)
</member>
        <member name="M:OsiClpSolverInterface.resolve">
Resolve an LP relaxation after problem modification
</member>
        <member name="M:OsiClpSolverInterface.initialSolve">
@name Solve methods 
Solve initial LP relaxation
</member>
        <member name="M:COIN.CglProbing.getMaxElementsRoot">
Get maximum number of elements in row for it to be considered (root node)
</member>
        <member name="M:COIN.CglProbing.setMaxElementsRoot(System.Int32)">
Set maximum number of elements in row for it to be considered (root node)
</member>
        <member name="M:COIN.CglProbing.getMaxLookRoot">
Get maximum number of variables to look at in one probe (root node)
</member>
        <member name="M:COIN.CglProbing.setMaxLookRoot(System.Int32)">
Set maximum number of variables to look at in one probe (root node)
</member>
        <member name="M:COIN.CglProbing.getMaxProbeRoot">
Get maximum number of unsatisfied variables to look at (root node)
</member>
        <member name="M:COIN.CglProbing.setMaxProbeRoot(System.Int32)">
Set maximum number of unsatisfied variables to look at (root node)
</member>
        <member name="M:COIN.CglProbing.getMaxPassRoot">
Get maximum number of passes per node (root node)
</member>
        <member name="M:COIN.CglProbing.setMaxPassRoot(System.Int32)">
Set maximum number of passes per node  (root node)
</member>
        <member name="M:COIN.CglProbing.getMaxElements">
Get maximum number of elements in row for it to be considered
</member>
        <member name="M:COIN.CglProbing.setMaxElements(System.Int32)">
Set maximum number of elements in row for it to be considered
</member>
        <member name="M:COIN.CglProbing.getMaxLook">
Get maximum number of variables to look at in one probe
</member>
        <member name="M:COIN.CglProbing.setMaxLook(System.Int32)">
Set maximum number of variables to look at in one probe
</member>
        <member name="M:COIN.CglProbing.getMaxProbe">
Get maximum number of unsatisfied variables to look at
</member>
        <member name="M:COIN.CglProbing.setMaxProbe(System.Int32)">
Set maximum number of unsatisfied variables to look at
</member>
        <member name="M:COIN.CglProbing.getLogLevel">
Get log level
</member>
        <member name="M:COIN.CglProbing.setLogLevel(System.Int32)">
Set log level - 0 none, 1 - a bit, 2 - more details
</member>
        <member name="M:COIN.CglProbing.getMaxPass">
Get maximum number of passes per node
</member>
        <member name="M:COIN.CglProbing.setMaxPass(System.Int32)">
@name Change maxima 
Set maximum number of passes per node
</member>
        <member name="M:COIN.CglProbing.setUsingObjective(System.Int32)">
@name Whether use objective as constraint 
Set
			0 don't
			1 do
			-1 don't even think about it

</member>
        <member name="F:CglCutGenerator.canDoGlobalCuts_">
True if can do global cuts i.e. no general integers
</member>
        <member name="F:CglCutGenerator.aggressive_">
Aggressiveness - 0 = neutral, 100 is normal root node.
Really just a hint to cut generator

</member>
        <member name="M:CglCutGenerator.maximumLengthOfCutInTree">
Return maximum length of cut in tree
</member>
        <member name="M:CglCutGenerator.needsOptimalBasis">
Return true if needs optimal basis to do cuts
</member>
        <member name="M:CglCutGenerator.mayGenerateRowCutsInTree">
Returns true if may generate Row cuts in tree (rather than root node).
Used so know if matrix will change in tree.  Really
meant so column cut generators can still be active
without worrying code.
Default is true

</member>
        <member name="M:CglCutGenerator.canDoGlobalCuts">
Say whether can do global cuts
</member>
        <member name="M:CglCutGenerator.setGlobalCuts(System.Boolean)">
Set whether can do global cuts
</member>
        <member name="M:CglCutGenerator.setAggressiveness(System.Int32)">
Set Aggressiveness - 0 = neutral, 100 is normal root node.
Really just a hint to cut generator

</member>
        <member name="M:CglCutGenerator.getAggressiveness">
@name Gets and Sets 
Get Aggressiveness - 0 = neutral, 100 is normal root node.
Really just a hint to cut generator

</member>
        <member name="M:CglCutGenerator.refreshSolver(OsiSolverInterface*)">
This can be used to refresh any information
</member>
        <member name="M:CglCutGenerator.Dispose">
Destructor
</member>
        <member name="M:CglCutGenerator.op_Assign(CglCutGenerator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CglCutGenerator.clone">
Clone
</member>
        <member name="M:CglCutGenerator.#ctor(CglCutGenerator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CglCutGenerator.#ctor">
@name Constructors and destructors 
Default constructor
</member>
        <member name="M:CglCutGenerator.generateCuts(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CglTreeInfo!System.Runtime.CompilerServices.IsConst)">
@name Generate Cuts 
Generate cuts for the model data contained in si.
  The generated cuts are inserted into and returned in the
  collection of cuts cs.

</member>
        <member name="T:CglCutGenerator">

Cut Generator Base Class

This is an abstract base class for generating cuts.  A specific cut 
generator will inherit from this class.

</member>
        <member name="F:CoinThreadRandom.seed_">
@name Data members
     The data members are protected to allow access for derived classes. 
Current seed
</member>
        <member name="M:CoinThreadRandom.randomize(System.Int32)">
make more random (i.e. for startup)
</member>
        <member name="M:CoinThreadRandom.randomDouble">
return a random number
</member>
        <member name="M:CoinThreadRandom.getSeed">
Get seed. 
</member>
        <member name="M:CoinThreadRandom.setSeed(System.Int32)">
@name Sets/gets 
Set seed. 
</member>
        <member name="M:CoinThreadRandom.Dispose">
Destructor 
</member>
        <member name="M:CoinThreadRandom.#ctor(System.Int32)">
Constructor wih seed. 
</member>
        <member name="M:CoinThreadRandom.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="T:CoinThreadRandom">
Class for thread specific random numbers

</member>
        <member name="M:CoinStrlenAsInt(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Cube Root
This helper returns "sizeof" as an int
This helper returns "strlen" as an int
</member>
        <member name="M:CoinFindDirSeparator">
This function figures out whether file names should contain slashes or 
    backslashes as directory separator 
</member>
        <member name="M:CoinSeedRandom(System.Int32)">
Set the seed for the random number generator
</member>
        <member name="M:CoinStrdup(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Returns strdup or NULL if original NULL 
</member>
        <member name="M:CoinCheckIntZero(System.Int32*,System.Int32!System.Runtime.CompilerServices.IsConst)">
This Debug helper function checks an array is all zero
</member>
        <member name="M:CoinCheckDoubleZero(System.Double*,System.Int32!System.Runtime.CompilerServices.IsConst)">
This Debug helper function checks an array is all zero
</member>
        <member name="F:OsiSolverInterface.objName_">
Objective name
</member>
        <member name="F:OsiSolverInterface.colNames_">
Column names
</member>
        <member name="F:OsiSolverInterface.rowNames_">
Row names
</member>
        <member name="F:OsiSolverInterface.strictColSolution_">
Column solution satisfying lower and upper column bounds
</member>
        <member name="F:OsiSolverInterface.ws_">
Warm start information used for hot starts when the default
       hot start implementation is used. 
</member>
        <member name="F:OsiSolverInterface.hintStrength_">
Array of hint strengths
</member>
        <member name="F:OsiSolverInterface.hintParam_">
Array of hint parameters
</member>
        <member name="F:OsiSolverInterface.strParam_">
Array of string parameters
</member>
        <member name="F:OsiSolverInterface.dblParam_">
Array of double parameters
</member>
        <member name="F:OsiSolverInterface.intParam_">
Array of integer parameters
</member>
        <member name="F:OsiSolverInterface.appDataEtc_">
@name Private member data
Pointer to user-defined data structure - and more if user wants
</member>
        <member name="F:OsiSolverInterface.columnType_">
Column type
      0 - continuous
      1 - binary (may get fixed later)
      2 - general integer (may get fixed later)
      3 - if supported - semi-continuous
      4 - if supported - semi-continuous integer

</member>
        <member name="F:OsiSolverInterface.object_">
Integer and ... information (integer info normally at beginning)
</member>
        <member name="F:OsiSolverInterface.numberObjects_">
Total number of objects
</member>
        <member name="F:OsiSolverInterface.numberIntegers_">
Number of integers
</member>
        <member name="F:OsiSolverInterface.messages_">
Messages
</member>
        <member name="F:OsiSolverInterface.defaultHandler_">
Flag to say if the currrent handler is the default handler.
      Indicates if the solver interface object is responsible
      for destruction of the handler (true) or if the client is
      responsible (false).

</member>
        <member name="F:OsiSolverInterface.handler_">
Message handler
</member>
        <member name="F:OsiSolverInterface.rowCutDebugger_">
@name Protected member data
</member>
        <member name="M:OsiSolverInterface.setInitialData">
Set OsiSolverInterface object state for default constructor

      This routine establishes the initial values of data fields in the
      OsiSolverInterface object when the object is created using the
      default constructor.

</member>
        <member name="M:OsiSolverInterface.convertSenseToBound(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A quick inlined function to convert from the sense/rhs/range style
	of constraint definition to the lb/ub style 

A quick inlined function to convert from the sense/rhs/range style of
    constraint definition to the lb/ub style 
</member>
        <member name="M:OsiSolverInterface.convertBoundToSense(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A quick inlined function to convert from the lb/ub style of
	constraint definition to the sense/rhs/range style 

A quick inlined function to convert from the lb/ub style of constraint
    definition to the sense/rhs/range style 
</member>
        <member name="M:OsiSolverInterface.applyColCut(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Apply a column cut (adjust the bounds of one or more variables). 
</member>
        <member name="M:OsiSolverInterface.applyRowCut(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Protected methods
Apply a row cut (append to the constraint matrix). 
</member>
        <member name="M:OsiSolverInterface.reset">
Reset the solver interface.

    A call to reset() returns the solver interface to the same state as
    it would have if it had just been constructed by calling the default
    constructor OsiSolverInterface().

</member>
        <member name="M:OsiSolverInterface.Dispose">
Destructor
</member>
        <member name="M:OsiSolverInterface.op_Assign(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiSolverInterface.#ctor(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiSolverInterface.clone(System.Boolean)">
Clone

      The result of calling clone(false) is defined to be equivalent to
      calling the default constructor OsiSolverInterface().

</member>
        <member name="M:OsiSolverInterface.#ctor">
@name Constructors and destructors
Default Constructor
</member>
        <member name="M:OsiSolverInterface.dualPivotResult(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVector*)">
Obtain a result of the dual pivot (similar to the previous method)
      Differences: entering variable and a sign of its change are now
      the outputs, the leaving variable and its statuts -- the inputs
      If dx!=NULL, then *dx contains dual ray
      Return code: same

</member>
        <member name="M:OsiSolverInterface.primalPivotResult(System.Int32,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVector*)">
Obtain a result of the primal pivot 
      Outputs: colOut -- leaving column, outStatus -- its status,
      t -- step size, and, if dx!=NULL, *dx -- primal ray direction.
      Inputs: colIn -- entering column, sign -- direction of its change (+/-1).
      Both for colIn and colOut, artificial variables are index by
      the negative of the row index minus 1.
      Return code (for now): 0 -- leaving variable found, 
      -1 -- everything else?
      Clearly, more informative set of return values is required 
      Primal and dual solutions are updated

</member>
        <member name="M:OsiSolverInterface.pivot(System.Int32,System.Int32,System.Int32)">
Perform a pivot by substituting a colIn for colOut in the basis. 
     The status of the leaving variable is given in outStatus. Where
     1 is to upper bound, -1 to lower bound
     Return code was undefined - now for OsiClp is 0 for okay,
     1 if inaccuracy forced re-factorization (should be okay) and
     -1 for singular factorization

</member>
        <member name="M:OsiSolverInterface.disableSimplexInterface">
Undo whatever setting changes the above method had to make
</member>
        <member name="M:OsiSolverInterface.enableSimplexInterface(System.Boolean)">
Enables normal operation of subsequent functions.
     This method is supposed to ensure that all typical things (like
     reduced costs, etc.) are updated when individual pivots are executed
     and can be queried by other methods.  says whether will be
     doing primal or dual

</member>
        <member name="M:OsiSolverInterface.optimalBasisIsAvailable">
Synonym for #basisIsAvailable
</member>
        <member name="M:OsiSolverInterface.forceFeasible">
Use current solution to set bounds so current integer feasible solution will stay feasible.
        Only feasible bounds will be used, even if current solution outside bounds.  The amount of
        such violation will be returned (and if small can be ignored)

</member>
        <member name="M:OsiSolverInterface.addObjects(System.Int32,OsiObject**)">
Add in object information.
  
      Objects are cloned; the owner can delete the originals.

</member>
        <member name="M:OsiSolverInterface.deleteObjects">
Delete all object information
</member>
        <member name="M:OsiSolverInterface.modifiableObject(System.Int32)">
Get the specified object
</member>
        <member name="M:OsiSolverInterface.object(System.Int32)">
Get the specified object
</member>
        <member name="M:OsiSolverInterface.objects">
Get the array of objects
</member>
        <member name="M:OsiSolverInterface.setNumberObjects(System.Int32)">
Set the number of objects
</member>
        <member name="M:OsiSolverInterface.numberObjects">
Get the number of objects
</member>
        <member name="M:OsiSolverInterface.findIntegersAndSOS(System.Boolean)">
\brief Identify integer variables and SOS and create corresponding objects.
  
      Record integer variables and create an OsiSimpleInteger object for each
      one.  All existing OsiSimpleInteger objects will be destroyed.
      If the solver supports SOS then do the same for SOS.

      If justCount then no objects created and we just store numberIntegers_
      Returns number of SOS

</member>
        <member name="M:OsiSolverInterface.findIntegers(System.Boolean)">
@name Methods for dealing with discontinuities other than integers.
  
     Osi should be able to know about SOS and other types.  This is an optional
     section where such information can be stored.


\brief Identify integer variables and create corresponding objects.
  
      Record integer variables and create an OsiSimpleInteger object for each
      one.  All existing OsiSimpleInteger objects will be destroyed.
      If justCount then no objects created and we just store numberIntegers_

</member>
        <member name="M:OsiSolverInterface.defaultHandler">
Return true if default handler
</member>
        <member name="M:OsiSolverInterface.messagesPointer">
Return a pointer to the current set of messages
</member>
        <member name="M:OsiSolverInterface.messages">
Return the current set of messages
</member>
        <member name="M:OsiSolverInterface.messageHandler">
Return a pointer to the current message handler
</member>
        <member name="M:OsiSolverInterface.newLanguage(CoinMessages.Language)">
Set language
</member>
        <member name="M:OsiSolverInterface.passInMessageHandler(CoinMessageHandler*)">
@name Message handling
  
    See the COIN library documentation for additional information about
    COIN message facilities.
  

Pass in a message handler
  
    It is the client's responsibility to destroy a message handler installed
    by this routine; it will not be destroyed when the solver interface is
    destroyed. 

</member>
        <member name="M:OsiSolverInterface.getAuxiliaryInfo">
Get pointer to auxiliary info object
</member>
        <member name="M:OsiSolverInterface.getApplicationData">
Get application data
</member>
        <member name="M:OsiSolverInterface.setAuxiliaryInfo(OsiAuxInfo*)">
Create a clone of an Auxiliary Information object.
        The base class just stores an application data pointer
        but can be more general.  Application data pointer is
        designed for one user while this can be extended to cope
        with more general extensions.

</member>
        <member name="M:OsiSolverInterface.setApplicationData(System.Void*)">
@name Setting/Accessing application data 
Set application data.

	This is a pointer that the application can store into and
	retrieve from the solver interface.
	This field is available for the application to optionally
	define and use.

</member>
        <member name="M:OsiSolverInterface.statistics(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Get some statistics about model - min/max always computed
      type 0-&gt;4 , larger gives more information
      0 - Just set min and max values of coefficients

</member>
        <member name="M:OsiSolverInterface.differentModel(OsiSolverInterface*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
@name Miscellaneous 
Check two models against each other.  Return nonzero if different.
      Ignore names if that set.
      (Note initial version does not check names)
      May modify both models by cleaning up

</member>
        <member name="M:OsiSolverInterface.readLp(_iobuf*,System.Double!System.Runtime.CompilerServices.IsConst)">
Read file in LP format from the file pointed to by fp.
See class CoinLpIO for description of this format.
</member>
        <member name="M:OsiSolverInterface.readLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
Read file in LP format from file with name filename.
See class CoinLpIO for description of this format.
</member>
        <member name="M:OsiSolverInterface.writeLpNative(_iobuf*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Write the problem into the file pointed to by the parameter fp. 
      Other parameters are similar to 
      those of writeLpNative() with first parameter filename.

</member>
        <member name="M:OsiSolverInterface.writeLpNative(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Boolean!System.Runtime.CompilerServ">
Write the problem into an Lp file. Parameters are similar to 
      those of writeLp(), but in addition row names and column names
      may be given. 

      Parameter rowNames may be NULL, in which case default row names 
      are used. If rowNames is not NULL, it must have exactly one entry
      per row in the problem and one additional
      entry (rowNames[getNumRows()] with the objective function name.
      These getNumRows()+1 entries must be distinct. If this is not the 
      case, default row names
      are used. In addition, format restrictions are imposed on names
      (see CoinLpIO::is_invalid_name() for details).

      Similar remarks can be made for the parameter columnNames which
      must either be NULL or have exactly getNumCols() distinct entries.

      Write objective function name and constraint names if 
      useRowNames is true. 
</member>
        <member name="M:OsiSolverInterface.writeLp(_iobuf*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)">
Write the problem into the file pointed to by the parameter fp. 
      Other parameters are similar to 
      those of writeLp() with first parameter filename.

</member>
        <member name="M:OsiSolverInterface.loadProblem(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
@name Methods for problem input and output 
</member>
        <member name="M:OsiSolverInterface.deleteBranchingInfo(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Deletes branching information before columns deleted
</member>
        <member name="M:OsiSolverInterface.applyRowCuts(System.Int32,OsiRowCut!System.Runtime.CompilerServices.IsConst**)">
Apply a collection of row cuts which are all effective.
	This is passed in as an array of pointers.

</member>
        <member name="M:OsiSolverInterface.applyRowCuts(System.Int32,OsiRowCut!System.Runtime.CompilerServices.IsConst*)">
Apply a collection of row cuts which are all effective.
	applyCuts seems to do one at a time which seems inefficient.
	Would be even more efficient to pass an array of pointers.

</member>
        <member name="M:OsiSolverInterface.restoreBaseModel(System.Int32)">
\brief Reduce the constraint system to the specified number of
    	       constraints.

       If solver wants it can restore a copy of "base" (continuous) model
       here.

       \note
       The name is somewhat misleading. Implementors should consider
       the opportunity to optimise behaviour in the common case where
       \p numberRows is exactly the number of original constraints. Do not,
       however, neglect the possibility that \p numberRows does not equal
       the number of original constraints.

</member>
        <member name="M:OsiSolverInterface.saveBaseModel">
\brief Save a copy of the base model
    
      If solver wants it can save a copy of "base" (continuous) model here.

</member>
        <member name="M:OsiSolverInterface.replaceMatrix(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Replace the constraint matrix
    
      And if it does matter (not used at present)

</member>
        <member name="M:OsiSolverInterface.replaceMatrixOptional(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Replace the constraint matrix

      I (JJF) am getting annoyed because I can't just replace a matrix.
      The default behavior of this is do nothing so only use where that would
      not matter, e.g. strengthening a matrix for MIP.

</member>
        <member name="M:OsiSolverInterface.deleteRows(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
\brief Delete a set of rows (constraints) from the problem.

      The solver interface for a basis-oriented solver will maintain valid
      warm start information if all deleted rows are loose.

</member>
        <member name="M:OsiSolverInterface.addRows(CoinBuild!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add rows using a CoinBuild object
</member>
        <member name="M:OsiSolverInterface.addRows(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Add a set of rows (constraints) to the problem.
    
      The default implementation simply makes repeated calls to
      addRow().

</member>
        <member name="M:OsiSolverInterface.addRows(System.Int32!System.Runtime.CompilerServices.IsConst,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Add a set of rows (constraints) to the problem.
    
      The default implementation simply makes repeated calls to
      addRow().

</member>
        <member name="M:OsiSolverInterface.deleteCols(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
\brief Remove a set of columns (primal variables) from the
	       problem.

      The solver interface for a basis-oriented solver will maintain valid
      warm start information if all deleted variables are nonbasic.

</member>
        <member name="M:OsiSolverInterface.addCols(CoinModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add columns from a model object.  returns
       -1 if object in bad state (i.e. has row information)
       otherwise number of errors
       modelObject non const as can be regularized as part of build

</member>
        <member name="M:OsiSolverInterface.addCols(CoinBuild!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Add columns using a CoinBuild object
</member>
        <member name="M:OsiSolverInterface.addCols(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Add a set of columns (primal variables) to the problem.
    
      The default implementation simply makes repeated calls to
      addCol().

</member>
        <member name="M:OsiSolverInterface.addCols(System.Int32!System.Runtime.CompilerServices.IsConst,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Add a set of columns (primal variables) to the problem.
    
      The default implementation simply makes repeated calls to
      addCol().

</member>
        <member name="M:OsiSolverInterface.addCol(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Add a column (primal variable) to the problem. 
</member>
        <member name="M:OsiSolverInterface.addCol(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
@name Methods to modify the constraint system.

     Note that new columns are added as continuous variables.

Add a column (primal variable) to the problem. 
</member>
        <member name="M:OsiSolverInterface.setInteger(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Set the variables listed in indices (which is of length len) to be
	integer variables 
</member>
        <member name="M:OsiSolverInterface.setContinuous(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Set the variables listed in indices (which is of length len) to be
	continuous variables 
</member>
        <member name="M:OsiSolverInterface.setInteger(System.Int32)">
Set the index-th variable to be an integer variable 
</member>
        <member name="M:OsiSolverInterface.setContinuous(System.Int32)">
@name Methods to set variable type 
Set the index-th variable to be a continuous variable 
</member>
        <member name="M:OsiSolverInterface.reducedCostFix(System.Double,System.Boolean)">
Fix variables at bound based on reduced cost
    
	For variables currently at bound, fix the variable at bound if the
	reduced cost exceeds the gap. Return the number of variables fixed.

	If justInteger is set to false, the routine will also fix continuous
	variables, but the test still assumes a delta of 1.0.

</member>
        <member name="M:OsiSolverInterface.setRowPrice(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set dual solution variable values

	rowprice[getNumRows()] is an array of values for the dual variables.
	These values are copied to memory owned by the solver interface
	object or the solver.  They will be returned as the result of
	getRowPrice() until changed by another call to setRowPrice() or by a
	call to any solver routine.  Whether the solver makes use of the
	solution in any way is solver-dependent.

</member>
        <member name="M:OsiSolverInterface.setColSolution(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the primal solution variable values

	colsol[getNumCols()] is an array of values for the primal variables.
	These values are copied to memory owned by the solver interface
	object or the solver.  They will be returned as the result of
	getColSolution() until changed by another call to setColSolution() or
	by a call to any solver routine.  Whether the solver makes use of the
	solution in any way is solver-dependent.

</member>
        <member name="M:OsiSolverInterface.setRowSetTypes(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the type of a set of rows.
	The default implementation just invokes setRowType()
	over and over again.

</member>
        <member name="M:OsiSolverInterface.setRowType(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Double,System.Double)">
Set the type of a single row 
</member>
        <member name="M:OsiSolverInterface.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the bounds on a set of rows.

	The default implementation just invokes setRowBounds() over and over
	again.  For each row, boundList must contain both a lower and
	upper bound, in that order.

</member>
        <member name="M:OsiSolverInterface.setRowBounds(System.Int32,System.Double,System.Double)">
Set a single row lower and upper bound.
	The default implementation just invokes setRowLower() and
	setRowUpper() 
</member>
        <member name="M:OsiSolverInterface.setRowUpper(System.Int32,System.Double)">
Set a single row upper bound.
	Use getInfinity() for infinity. 
</member>
        <member name="M:OsiSolverInterface.setRowLower(System.Int32,System.Double)">
Set a single row lower bound.
	Use -getInfinity() for -infinity. 
</member>
        <member name="M:OsiSolverInterface.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the upper and lower bounds of a set of columns.

	The default implementation just invokes setColBounds() over and over
	again.  For each column, boundList must contain both a lower and
	upper bound, in that order.

</member>
        <member name="M:OsiSolverInterface.setColBounds(System.Int32,System.Double,System.Double)">
Set a single column lower and upper bound.
	The default implementation just invokes setColLower() and
	setColUpper() 
</member>
        <member name="M:OsiSolverInterface.setColUpper(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the upper bounds for all columns.

	array [getNumCols()] is an array of values for the upper bounds.
	This defaults to a series of set operations and is here for speed.

</member>
        <member name="M:OsiSolverInterface.setColUpper(System.Int32,System.Double)">
Set a single column upper bound.
	Use getInfinity() for infinity. 
</member>
        <member name="M:OsiSolverInterface.setColLower(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the lower bounds for all columns.

	array [getNumCols()] is an array of values for the lower bounds.
	This defaults to a series of set operations and is here for speed.

</member>
        <member name="M:OsiSolverInterface.setColLower(System.Int32,System.Double)">
Set a single column lower bound.
	Use -getInfinity() for -infinity. 
</member>
        <member name="M:OsiSolverInterface.setObjSense(System.Double)">
Set the objective function sense.

        Use 1 for minimisation (default), -1 for maximisation.

	\note
	Implementors note that objective function sense is a parameter of
	the OSI, not a property of the problem. Objective sense can be
	set prior to problem load and should not be affected by loading a
	new problem.

</member>
        <member name="M:OsiSolverInterface.setObjective(System.Double!System.Runtime.CompilerServices.IsConst*)">
Set the objective coefficients for all columns.

	array [getNumCols()] is an array of values for the objective.
	This defaults to a series of set operations and is here for speed.

</member>
        <member name="M:OsiSolverInterface.setObjCoeffSet(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Set a set of objective function coefficients 
</member>
        <member name="M:OsiSolverInterface.setObjCoeff(System.Int32,System.Double)">
@name Methods to modify the objective, bounds, and solution

     For functions which take a set of indices as parameters
     (\c setObjCoeffSet(), \c setColSetBounds(), \c setRowSetBounds(),
     \c setRowSetTypes()), the parameters follow the C++ STL iterator
     convention: \c indexFirst points to the first index in the
     set, and \c indexLast points to a position one past the last index
     in the set.
  

Set an objective function coefficient 
</member>
        <member name="M:OsiSolverInterface.getFractionalIndices(System.Double!System.Runtime.CompilerServices.IsConst)">
Get vector of indices of primal variables which are integer variables 
	but have fractional values in the current solution. 
</member>
        <member name="M:OsiSolverInterface.getPrimalRays(System.Int32)">
Get as many primal rays as the solver can provide. In case of proven
	dual infeasibility there should (with high probability) be at least
	one.
   
	\note
	Implementors of solver interfaces note that the double pointers in
	the vector should point to arrays of length getNumCols() and they
	should be allocated with new[].

	\note
	Clients of solver interfaces note that it is the client's
	responsibility to free the double pointers in the vector using
	delete[]. Clients are reminded that a problem can be dual and primal
	infeasible.

</member>
        <member name="M:OsiSolverInterface.getDualRays(System.Int32,System.Boolean)">
Get as many dual rays as the solver can provide. In case of proven
	primal infeasibility there should (with high probability) be at least
	one.

	The first getNumRows() ray components will always be associated with
	the row duals (as returned by getRowPrice()). If \c fullRay is true,
	the final getNumCols() entries will correspond to the ray components
	associated with the nonbasic variables. If the full ray is requested
	and the method cannot provide it, it will throw an exception.

	\note
	Implementors of solver interfaces note that the double pointers in
	the vector should point to arrays of length getNumRows() (fullRay =
	false) or (getNumRows()+getNumCols()) (fullRay = true) and they should
	be allocated with new[].

	\note
	Clients of solver interfaces note that it is the client's
	responsibility to free the double pointers in the vector using
	delete[]. Clients are reminded that a problem can be dual and primal
	infeasible.

</member>
        <member name="M:OsiSolverInterface.getIterationCount">
Get the number of iterations it took to solve the problem (whatever
	`iteration' means to the solver).

</member>
        <member name="M:OsiSolverInterface.getObjValue">
Get the objective function value.
</member>
        <member name="M:OsiSolverInterface.getRowActivity">
Get a pointer to array[getNumRows()] of row activity levels.
    
      The row activity for a row is the left-hand side evaluated at the
      current solution.

</member>
        <member name="M:OsiSolverInterface.getReducedCost">
Get a pointer to an array[getNumCols()] of reduced costs
</member>
        <member name="M:OsiSolverInterface.getRowPrice">
Get pointer to array[getNumRows()] of dual variable values
</member>
        <member name="M:OsiSolverInterface.getStrictColSolution">
Get a pointer to an array[getNumCols()] of primal variable values
	guaranteed to be between the column lower and upper bounds.

</member>
        <member name="M:OsiSolverInterface.getColSolution">
@name Solution query methods 
Get a pointer to an array[getNumCols()] of primal variable values
</member>
        <member name="M:OsiSolverInterface.getInfinity">
Get the solver's value for infinity
</member>
        <member name="M:OsiSolverInterface.getMatrixByCol">
Get a pointer to a column-wise copy of the matrix
</member>
        <member name="M:OsiSolverInterface.getMatrixByRow">
Get a pointer to a row-wise copy of the matrix
</member>
        <member name="M:OsiSolverInterface.setColumnType(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Set column type
</member>
        <member name="M:OsiSolverInterface.isFreeBinary(System.Int32)">
Return true if the variable is binary and not fixed
</member>
        <member name="M:OsiSolverInterface.isIntegerNonBinary(System.Int32)">
Return true if the variable is general integer
</member>
        <member name="M:OsiSolverInterface.isBinary(System.Int32)">
Return true if the variable is binary
</member>
        <member name="M:OsiSolverInterface.isContinuous(System.Int32)">
Return true if the variable is continuous
</member>
        <member name="M:OsiSolverInterface.getRowUpper">
Get a pointer to an array[getNumRows()] of row upper bounds
</member>
        <member name="M:OsiSolverInterface.getRowLower">
Get a pointer to an array[getNumRows()] of row lower bounds
</member>
        <member name="M:OsiSolverInterface.getColUpper">
Get a pointer to an array[getNumCols()] of column upper bounds
</member>
        <member name="M:OsiSolverInterface.getColLower">
Get a pointer to an array[getNumCols()] of column lower bounds
</member>
        <member name="M:OsiSolverInterface.getNumIntegers">
Get the number of integer variables
</member>
        <member name="M:OsiSolverInterface.getNumElements">
Get the number of nonzero elements
</member>
        <member name="M:OsiSolverInterface.getNumRows">
Get the number of rows
</member>
        <member name="M:OsiSolverInterface.getNumCols">
@name Problem query methods

   Querying a problem that has no data associated with it will result in
   zeros for the number of rows and columns, and NULL pointers from the
   methods that return vectors.

   Const pointers returned from any data-query method are valid as long as
   the data is unchanged and the solver is not called.

Get the number of columns
</member>
        <member name="M:OsiSolverInterface.unmarkHotStart">
Delete the hot start snapshot.
</member>
        <member name="M:OsiSolverInterface.solveFromHotStart">
Optimize starting from the hot start snapshot.
</member>
        <member name="M:OsiSolverInterface.setWarmStart(CoinWarmStart!System.Runtime.CompilerServices.IsConst*)">
\brief Set warm start information.
    
      Return true or false depending on whether the warm start information was
      accepted or not.
      By definition, a call to setWarmStart with a null parameter should
      cause the solver interface to refresh its warm start information
      from the underlying solver.

</member>
        <member name="M:OsiSolverInterface.getPointerToWarmStart(System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Get warm start information.

      Return warm start information for the current state of the solver
      interface. If there is no valid warm start information, an empty warm
      start object wil be returned.  This does not necessarily create an 
      object - may just point to one.  must Delete set true if user
      should delete returned object.

</member>
        <member name="M:OsiSolverInterface.getWarmStart">
\brief Get warm start information.

      Return warm start information for the current state of the solver
      interface. If there is no valid warm start information, an empty warm
      start object wil be returned.

</member>
        <member name="M:OsiSolverInterface.getEmptyWarmStart">
\name Warm start methods

    Note that the warm start methods return a generic CoinWarmStart object.
    The precise characteristics of this object are solver-dependent. Clients
    who wish to maintain a maximum degree of solver independence should take
    care to avoid unnecessary assumptions about the properties of a warm start
    object.

</member>
        <member name="M:OsiSolverInterface.isIterationLimitReached">
Iteration limit reached?
</member>
        <member name="M:OsiSolverInterface.isDualObjectiveLimitReached">
Is the given dual objective limit reached?
</member>
        <member name="M:OsiSolverInterface.isPrimalObjectiveLimitReached">
Is the given primal objective limit reached?
</member>
        <member name="M:OsiSolverInterface.isProvenDualInfeasible">
Is dual infeasibility proven?
</member>
        <member name="M:OsiSolverInterface.isProvenPrimalInfeasible">
Is primal infeasibility proven?
</member>
        <member name="M:OsiSolverInterface.isProvenOptimal">
Is optimality proven?
</member>
        <member name="M:OsiSolverInterface.isAbandoned">
@name Methods returning info on how the solution process terminated
Are there numerical difficulties?
</member>
        <member name="M:OsiSolverInterface.getIntegerTolerance">
\brief Return the integrality tolerance of the underlying solver.
    
	We should be able to get an integrality tolerance, but
        until that time just use the primal tolerance

	\todo
	This method should be replaced; it's architecturally wrong.  This
	should be an honest dblParam with a keyword. Underlying solvers
	that do not support integer variables should return false for set and
	get on this parameter.  Underlying solvers that support integrality
	should add this to the parameters they support, using whatever
	tolerance is appropriate.  -lh, 091021-

</member>
        <member name="M:OsiSolverInterface.branchAndBound">
Invoke solver's built-in enumeration algorithm
</member>
        <member name="M:OsiSolverInterface.initialSolve">
@name Solve methods
Solve initial LP relaxation
</member>
        <member name="F:OsiSolverInterface.ApplyCutsReturnCode.applied_">
Counter for applied cuts
</member>
        <member name="F:OsiSolverInterface.ApplyCutsReturnCode.ineffective_">
Counter for ineffective cuts
</member>
        <member name="F:OsiSolverInterface.ApplyCutsReturnCode.infeasible_">
Counter for infeasible cuts
</member>
        <member name="F:OsiSolverInterface.ApplyCutsReturnCode.extInconsistent_">
Counter for model-inconsistent cuts
</member>
        <member name="F:OsiSolverInterface.ApplyCutsReturnCode.intInconsistent_">
@name Private member data
Counter for logically inconsistent cuts
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.incrementApplied">
Increment applied cut counter
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.incrementIneffective">
Increment ineffective cut counter
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.incrementInfeasible">
Increment infeasible cut counter
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.incrementExternallyInconsistent">
Increment model-inconsistent counter
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.incrementInternallyInconsistent">
@name Private methods 
Increment logically inconsistent cut counter
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.getNumApplied">
Number of cuts applied
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.getNumIneffective">
Number of redundant or ineffective cuts
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.getNumInfeasible">
Number of cuts that cause obvious infeasibility
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.getNumInconsistentWrtIntegerModel">
Number of cuts inconsistent with the current model
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.getNumInconsistent">
@name Accessing return code attributes 
Number of logically inconsistent cuts
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.Dispose">
Destructor
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.op_Assign(OsiSolverInterface.ApplyCutsReturnCode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.#ctor(OsiSolverInterface.ApplyCutsReturnCode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiSolverInterface.ApplyCutsReturnCode.#ctor">
@name Constructors and desctructors
Default constructor
</member>
        <member name="T:OsiSolverInterface.ApplyCutsReturnCode">
Internal class for obtaining status from the applyCuts method
</member>
        <member name="F:OsiForceDo">
And this means throw an exception if not possible 
</member>
        <member name="F:OsiHintDo">
This means do hint if at all possible 
</member>
        <member name="F:OsiHintTry">
This means it is only a hint 
</member>
        <member name="F:OsiHintIgnore">
Ignore hint (default) 
</member>
        <member name="F:OsiLastHintParam">
Just a marker, so that OsiSolverInterface can allocate a static sized
      array to store parameters. 
</member>
        <member name="F:OsiDoInBranchAndCut">
Whether we are in branch and cut - so can modify behavior 
</member>
        <member name="F:OsiDoReducePrint">
Whether to reduce amount of printout, e.g., for branch and cut 
</member>
        <member name="F:OsiDoCrash">
Whether to create a non-slack basis (only in initialSolve) 
</member>
        <member name="F:OsiDoScale">
Whether to scale problem 
</member>
        <member name="F:OsiDoDualInResolve">
Whether to use a dual algorithm in resolve.
      The reverse is to use a primal algorithm 
</member>
        <member name="F:OsiDoPresolveInResolve">
Whether to do a presolve in resolve 
</member>
        <member name="F:OsiDoDualInInitial">
Whether to use a dual algorithm in initialSolve.
      The reverse is to use a primal algorithm 
</member>
        <member name="F:OsiDoPresolveInInitial">
Whether to do a presolve in initialSolve 
</member>
        <member name="F:OsiObjOffset">
The value of any constant term in the objective function. 
</member>
        <member name="M:CoinWarmStartDiff.clone">
`Virtual constructor'
</member>
        <member name="M:CoinWarmStartDiff.Dispose">
Abstract destructor
</member>
        <member name="M:CoinWarmStart.clone">
`Virtual constructor'
</member>
        <member name="M:CoinWarmStart.Dispose">
Abstract destructor
</member>
        <member name="T:CoinWarmStart">
Abstract base class for warm start information.

    Really nothing can be generalized for warm start information --- all we
    know is that it exists. Hence the abstract base class contains only a
    virtual destructor and a virtual clone function (a virtual constructor),
    so that derived classes can provide these functions.

</member>
        <member name="M:COIN.OsiCbcSolverInterface.getRealSolverPtr">
Get pointer to underlying solver
</member>
        <member name="M:COIN.OsiCbcSolverInterface.getModelPtr">
Get pointer to Cbc model
</member>
        <member name="M:COIN.ClpModel.deleteQuadraticObjective">
Get rid of quadratic objective
</member>
        <member name="M:COIN.ClpModel.loadQuadraticObjective(System.Int32,System.Int32[],System.Int32[],System.Double[])">
            <summary>Load up quadratic objective. This is stored as a CoinPackedMatrix.
Adds quadratic component to any existing linear objective.
It's assumed the matrix is symmetric, so only provide top part.
Also, for diagonal elements pass double value, and for non-diagonals normal value.
start[0 .. n] gives for every column (variable) the starting point in the column and value arrays. start[n] = #nz
column[0 .. nz-1] gives for each nonzero element the second involved column--the first involved column gives start.
value[0 .. nz-1] gives the nonzero (multiplier) value.
EXAMPLE: Quadratic objective 0.5 x1 ^ 2 + x2 ^ 2 - x1x2 becomes
start = { 0, 2, 3}, column = {0 (x1^2), 1 (x1x2), 1 (x2^2) }, 
element = { 1.0 (x1^2, diagonal so double value), -1.0 (x1x2, non-diagonal so normal value), 2.0 (x2^2, diagonal so double value)}
</summary>
        </member>
        <member name="M:COIN.CbcModel.cutGenerator(System.Int32)">
Get the specified cut generator
</member>
        <member name="M:COIN.CbcModel.cutGenerators">
Get the list of cut generators
</member>
        <member name="M:COIN.CbcModel.numberCutGenerators">
Get the number of cut generators
</member>
        <member name="M:COIN.CbcModel.status">
Final status of problem - 0 finished, 1 stopped, 2 difficulties
</member>
        <member name="M:COIN.CbcModel.setStrategy(COIN.CbcStrategy)">
Set the strategy. assigns
</member>
        <member name="M:COIN.CbcModel.addCutGenerator(COIN.CglCutGenerator,System.Int32,System.String,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32)">
Add one generator - up to user to delete generators.
        howoften affects how generator is used. 0 or 1 means always,
        &gt;1 means every that number of nodes.  Negative values have same
        meaning as positive but they may be switched off (-&gt; -100) by code if
        not many cuts generated at continuous.  -99 is just done at root.
        Name is just for printout.
        If depth &gt;0 overrides how often generator is called (if howOften==-1 or &gt;0).

</member>
        <member name="M:COIN.CbcCutGenerator.generator">
Get the \c CglCutGenerator corresponding to this \c CbcCutGenerator.
</member>
        <member name="M:COIN.CbcCutGenerator.#ctor(COIN.CbcModel,COIN.CglCutGenerator,System.Int32,System.String,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32)">
Normal constructor

Normal constructor
</member>
        <member name="M:CbcCutModifier.generateCpp(_iobuf*)">
Create C++ lines to get to current state
</member>
        <member name="M:CbcCutModifier.modify(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,OsiRowCut*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns
        0 unchanged
        1 strengthened
        2 weakened
        3 deleted

</member>
        <member name="M:CbcCutModifier.clone">
Clone
</member>
        <member name="M:CbcCutModifier.op_Assign(CbcCutModifier!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment
</member>
        <member name="M:CbcCutModifier.Dispose">
Destructor
</member>
        <member name="M:CbcCutModifier.#ctor">
Default Constructor
</member>
        <member name="T:CbcCutModifier">
Abstract cut modifier base class

    In exotic circumstances - cuts may need to be modified
    a) strengthened - changed
    b) weakened - changed
    c) deleted - set to NULL
    d) unchanged

</member>
        <member name="F:CglTreeProbingInfo.numberEntries_">
Number entries in fixingEntry_ (and fixEntry_) or -2 if correct style
</member>
        <member name="F:CglTreeProbingInfo.maximumEntries_">
Maximum number in fixEntry_
</member>
        <member name="F:CglTreeProbingInfo.numberIntegers_">
Number of 0-1 variables
</member>
        <member name="F:CglTreeProbingInfo.numberVariables_">
Number of variables
</member>
        <member name="F:CglTreeProbingInfo.fixingEntry_">
Entries for fixing variable when collecting
</member>
        <member name="F:CglTreeProbingInfo.backward_">
Backward look up
</member>
        <member name="F:CglTreeProbingInfo.integerVariable_">
List of 0-1 integer variables
</member>
        <member name="F:CglTreeProbingInfo.toOne_">
Starts of integer variable going to one
</member>
        <member name="F:CglTreeProbingInfo.toZero_">
Starts of integer variable going to zero
</member>
        <member name="F:CglTreeProbingInfo.fixEntry_">
Entries for fixing variables
</member>
        <member name="M:CglTreeProbingInfo.convert">
Converts to ordered
</member>
        <member name="M:CglTreeProbingInfo.numberIntegers">
Number of 0-1 variables
</member>
        <member name="M:CglTreeProbingInfo.numberVariables">
Number of variables
</member>
        <member name="M:CglTreeProbingInfo.backward">
Backward look up
</member>
        <member name="M:CglTreeProbingInfo.integerVariable">
List of 0-1 integer variables
</member>
        <member name="M:CglTreeProbingInfo.toOne">
Starts of integer variable going to one
</member>
        <member name="M:CglTreeProbingInfo.toZero">
Starts of integer variable going to zero
</member>
        <member name="M:CglTreeProbingInfo.fixEntries">
Entries for fixing variables
</member>
        <member name="M:CglTreeProbingInfo.generateCuts(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CglTreeInfo!System.Runtime.CompilerServices.IsConst)">
Generate cuts from implications
</member>
        <member name="M:CglTreeProbingInfo.packDown">
Packs down entries
</member>
        <member name="M:CglTreeProbingInfo.fixColumns(System.Int32,System.Int32,OsiSolverInterface*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Fix entries in a solver using implications for one variable
</member>
        <member name="M:CglTreeProbingInfo.fixColumns(OsiSolverInterface*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Fix entries in a solver using implications
</member>
        <member name="M:CglTreeProbingInfo.initializeFixing(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Initalizes fixing arrays etc - returns &gt;0 if we want to save info
      0 if we don't and -1 if is to be used 
</member>
        <member name="M:CglTreeProbingInfo.fixes(System.Int32,System.Int32,System.Int32,System.Boolean)">
Take action if cut generator can fix a variable 
      (toValue -1 for down, +1 for up)
      Returns true if still room, false if not  
</member>
        <member name="M:CglTreeProbingInfo.Dispose">
Destructor
</member>
        <member name="M:CglTreeProbingInfo.op_Assign(CglTreeProbingInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CglTreeProbingInfo.clone">
Clone
</member>
        <member name="M:CglTreeProbingInfo.#ctor(CglTreeProbingInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CglTreeProbingInfo.#ctor(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Constructor from model
</member>
        <member name="M:CglTreeProbingInfo.#ctor">
Default constructor
</member>
        <member name="M:CglTreeInfo.initializeFixing(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Initalizes fixing arrays etc - returns &gt;0 if we want to save info
      0 if we don't and -1 if is to be used 
</member>
        <member name="M:CglTreeInfo.fixes(System.Int32,System.Int32,System.Int32,System.Boolean)">
Take action if cut generator can fix a variable (toValue -1 for down, +1 for up)
</member>
        <member name="M:CglTreeInfo.Dispose">
Destructor
</member>
        <member name="M:CglTreeInfo.op_Assign(CglTreeInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CglTreeInfo.clone">
Clone
</member>
        <member name="M:CglTreeInfo.#ctor(CglTreeInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CglTreeInfo.#ctor">
Default constructor
</member>
        <member name="F:CglTreeInfo.randomNumberGenerator">
Optional pointer to thread specific random number generator
</member>
        <member name="F:CglTreeInfo.strengthenRow">
Replacement array.  Before Branch and Cut it may be beneficial to strengthen rows
      rather than adding cuts.  If this array is not NULL then the cut generator can
      place a pointer to the stronger cut in this array which is number of rows in size.

      A null (i.e. zero elements and free rhs) cut indicates that the row is useless 
      and can be removed.

      The calling function can then replace those rows.

</member>
        <member name="F:CglTreeInfo.originalColumns">
Original columns (if preprocessed)
</member>
        <member name="F:CglTreeInfo.parentSolver">
parent solver
</member>
        <member name="F:CglTreeInfo.hasParent">
nonzero if called from child of main model
      1 if heuristic run
      2 if doing full search

</member>
        <member name="F:CglTreeInfo.inTree">
Set true if in tree (to avoid ambiguity at first branch)
</member>
        <member name="F:CglTreeInfo.options">
Options 
      1 - treat costed integers as important
      2 - switch off some stuff as variables semi-integer
      4 - set global cut flag if at root node
      8 - set global cut flag if at root node and first pass
      16 - set global cut flag and make cuts globally valid
      32 - last round of cuts did nothing - maybe be more aggressive
      64 - in preprocessing stage
      128 - looks like solution
      256 - want alternate cuts
      512 - in sub tree (i.e. parent model)
      1024 - in must call again mode or after everything mode

</member>
        <member name="F:CglTreeInfo.formulation_rows">
The number of rows in the original formulation. Some generators may not
      want to consider already generated rows when generating new ones. 
</member>
        <member name="F:CglTreeInfo.pass">
How many times the cut generator was already invoked in this search tree
      node 
</member>
        <member name="F:CglTreeInfo.level">
The level of the search tree node
</member>
        <member name="T:CglTreeInfo">
Information about where the cut generator is invoked from. 
</member>
        <member name="M:COIN.CbcStrategy.preProcessState">
See what sort of preprocessing was done
</member>
        <member name="M:COIN.CbcStrategy.setPreProcessState(System.Int32)">
Say preProcessing done
</member>
        <member name="M:COIN.CbcStrategy.getNested">
Get model depth (i.e. how nested)
</member>
        <member name="M:COIN.CbcStrategy.setNested(System.Int32)">
Set model depth (i.e. how nested)
</member>
        <member name="M:COIN.CbcStrategy.setupOther(COIN.CbcModel)">
Other stuff e.g. strong branching and preprocessing

Other stuff e.g. strong branching and preprocessing
</member>
        <member name="M:COIN.CbcStrategy.setupPrinting(COIN.CbcModel,System.Int32)">
Do printing stuff

Do printing stuff
</member>
        <member name="M:COIN.CbcStrategy.setupHeuristics(COIN.CbcModel)">
Setup heuristics

Setup heuristics
</member>
        <member name="M:COIN.CbcStrategy.setupCutGenerators(COIN.CbcModel)">
Setup cut generators

Setup cut generators
</member>
        <member name="M:CbcStrategyDefaultSubTree.op_Assign(CbcStrategyDefaultSubTree!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="M:CbcStrategyDefaultSubTree.setupOther(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Other stuff e.g. strong branching
</member>
        <member name="M:CbcStrategyDefaultSubTree.setupPrinting(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Do printing stuff
</member>
        <member name="M:CbcStrategyDefaultSubTree.setupHeuristics(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup heuristics
</member>
        <member name="M:CbcStrategyDefaultSubTree.setupCutGenerators(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup cut generators
</member>
        <member name="M:CbcStrategyDefaultSubTree.clone">
Clone
</member>
        <member name="T:CbcStrategyDefaultSubTree">
Default class for sub trees

</member>
        <member name="M:CbcStrategyDefault.op_Assign(CbcStrategyDefault!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="F:CbcStrategyDefault.preProcessPasses_">
Number of pre-processing passes
</member>
        <member name="F:CbcStrategyDefault.desiredPreProcess_">
Desired pre-processing
        0 - none
        1 - ordinary
        2 - find sos
        3 - find cliques
        4 - more aggressive sos
        5 - add integer slacks

</member>
        <member name="M:CbcStrategyDefault.generateCpp(_iobuf*)">
Create C++ lines to get to current state
</member>
        <member name="M:CbcStrategyDefault.preProcessPasses">
See how many passes wanted
</member>
        <member name="M:CbcStrategyDefault.desiredPreProcess">
See what sort of preprocessing wanted
</member>
        <member name="M:CbcStrategyDefault.setupPreProcessing(System.Int32,System.Int32)">
Set up preProcessing - see below
</member>
        <member name="M:CbcStrategyDefault.setupOther(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Other stuff e.g. strong branching
</member>
        <member name="M:CbcStrategyDefault.setupPrinting(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Do printing stuff
</member>
        <member name="M:CbcStrategyDefault.setupHeuristics(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup heuristics
</member>
        <member name="M:CbcStrategyDefault.setupCutGenerators(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup cut generators
</member>
        <member name="M:CbcStrategyDefault.clone">
Clone
</member>
        <member name="T:CbcStrategyDefault">
Default class

</member>
        <member name="M:CbcStrategyNull.op_Assign(CbcStrategyNull!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="M:CbcStrategyNull.setupOther(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Other stuff e.g. strong branching
</member>
        <member name="M:CbcStrategyNull.setupPrinting(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Do printing stuff
</member>
        <member name="M:CbcStrategyNull.setupHeuristics(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup heuristics
</member>
        <member name="M:CbcStrategyNull.setupCutGenerators(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup cut generators
</member>
        <member name="M:CbcStrategyNull.clone">
Clone
</member>
        <member name="T:CbcStrategyNull">
Null class

</member>
        <member name="F:CbcStrategy.process_">
If preprocessing then this is object
</member>
        <member name="F:CbcStrategy.preProcessState_">
PreProcessing state -
        -1 infeasible
        0 off
        1 was done (so need post-processing)

</member>
        <member name="F:CbcStrategy.depth_">
Model depth
</member>
        <member name="M:CbcStrategy.op_Assign(CbcStrategy!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="M:CbcStrategy.status(CbcModel*,CbcNodeInfo*,System.Int32)">
After a CbcModel::resolve this can return a status
        -1 no effect
        0 treat as optimal
        1 as 0 but do not do any more resolves (i.e. no more cuts)
        2 treat as infeasible

</member>
        <member name="M:CbcStrategy.generateCpp(_iobuf*)">
Create C++ lines to get to current state
</member>
        <member name="M:CbcStrategy.partialNodeInfo(CbcModel*,CbcNodeInfo*,CbcNode*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinWarmStartDiff!System.Runtime.CompilerServices.IsConst*)">
Return a new Partial node information pointer (descendant of CbcPartialNodeInfo)
</member>
        <member name="M:CbcStrategy.fullNodeInfo(CbcModel*,System.Int32)">
Return a new Full node information pointer (descendant of CbcFullNodeInfo)
</member>
        <member name="M:CbcStrategy.deletePreProcess">
Delete pre-processing object to save memory
</member>
        <member name="M:CbcStrategy.process">
Pre-processing object
</member>
        <member name="M:CbcStrategy.preProcessState">
See what sort of preprocessing was done
</member>
        <member name="M:CbcStrategy.setPreProcessState(System.Int32)">
Say preProcessing done
</member>
        <member name="M:CbcStrategy.getNested">
Get model depth (i.e. how nested)
</member>
        <member name="M:CbcStrategy.setNested(System.Int32)">
Set model depth (i.e. how nested)
</member>
        <member name="M:CbcStrategy.setupOther(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Other stuff e.g. strong branching and preprocessing
</member>
        <member name="M:CbcStrategy.setupPrinting(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Do printing stuff
</member>
        <member name="M:CbcStrategy.setupHeuristics(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup heuristics
</member>
        <member name="M:CbcStrategy.setupCutGenerators(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Setup cut generators
</member>
        <member name="M:CbcStrategy.clone">
Clone
</member>
        <member name="T:CbcStrategy">
Strategy base class 
</member>
        <member name="M:getIntegerInformation(OsiObject!System.Runtime.CompilerServices.IsConst*,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
So we can use osiObject or CbcObject during transition
</member>
        <member name="F:CbcModel.masterThread_">
Pointer to masterthread
</member>
        <member name="F:CbcModel.master_">
Thread stuff for master
</member>
        <member name="F:CbcModel.numberGlobalCutsIn_">
Number of global cuts on entry to a node
</member>
        <member name="F:CbcModel.threadMode_">
thread mode
        always use numberThreads for branching
        1 set then deterministic
        2 set then use numberThreads for root cuts
        4 set then use numberThreads in root mini branch and bound
        default is 0

</member>
        <member name="F:CbcModel.numberThreads_">
Parallel
0 - off
1 - testing
2-99 threads
other special meanings

</member>
        <member name="F:CbcModel.storedRowCuts_">
Stored row cuts for donor/recipient CbcModel
</member>
        <member name="F:CbcModel.updateItems_">
Update items
</member>
        <member name="F:CbcModel.maximumNumberUpdateItems_">
Maximum number of outstanding update information items
</member>
        <member name="F:CbcModel.numberUpdateItems_">
Number of outstanding update information items
</member>
        <member name="F:CbcModel.continuousPriority_">
Anything with priority &gt;= this can be treated as continuous
</member>
        <member name="F:CbcModel.maximumNumberIterations_">
Maximum number of iterations (designed to be used in heuristics)
</member>
        <member name="F:CbcModel.resolveAfterTakeOffCuts_">
Whether to force a resolve after takeOffCuts
</member>
        <member name="F:CbcModel.solverCharacteristics_">
For advanced applications you may wish to modify the behavior of Cbc
e.g. if the solver is a NLP solver then you may not have an exact
optimum solution at each step.  This gives characteristics - just for one BAB.
For actually saving/restoring a solution you need the actual solver one.

</member>
        <member name="F:CbcModel.strongInfo_">
0 - number times strong branching done, 1 - number fixed, 2 - number infeasible
        Second group of three is a snapshot at node [6] 
</member>
        <member name="F:CbcModel.numberStrongIterations_">
Number of iterations in strong branching
</member>
        <member name="F:CbcModel.searchStrategy_">
Strategy worked out - mainly at root node
</member>
        <member name="F:CbcModel.numberNewCuts_">
Number of new cuts
</member>
        <member name="F:CbcModel.numberOldActiveCuts_">
Number of old active cuts
</member>
        <member name="F:CbcModel.numberLongStrong_">
Number of long strong goes
</member>
        <member name="F:CbcModel.eventHappened_">
Whether event happened
</member>
        <member name="F:CbcModel.stoppedOnGap_">
Whether stopping on gap
</member>
        <member name="F:CbcModel.numberFixedNow_">
Number fixed by analyze so far
</member>
        <member name="F:CbcModel.numberFixedAtRoot_">
Number of fixed by analyze at root
</member>
        <member name="F:CbcModel.probingInfo_">
Probing info
</member>
        <member name="F:CbcModel.numberDJFixed_">
Number of reduced cost fixings
</member>
        <member name="F:CbcModel.maximumDepthActual_">
Maximum depth reached
</member>
        <member name="F:CbcModel.statistics_">
statistics
</member>
        <member name="F:CbcModel.maximumStatistics_">
Maximum number of statistics
</member>
        <member name="F:CbcModel.whichGenerator_">
Which cut generator generated this cut
</member>
        <member name="F:CbcModel.workingBasis_">
Work basis for temporary use
</member>
        <member name="F:CbcModel.randomNumberGenerator_">
Thread specific random number generator
</member>
        <member name="F:CbcModel.currentDepth_">
Current depth
</member>
        <member name="F:CbcModel.multipleRootTries_">
Multiple root tries
</member>
        <member name="F:CbcModel.randomSeed_">
Random seed
</member>
        <member name="F:CbcModel.maximumRows_">
Maximum number of rows
</member>
        <member name="F:CbcModel.maximumWhich_">
Maximum number of cuts (for whichGenerator_)
</member>
        <member name="F:CbcModel.currentPassNumber_">
Current cut pass number
</member>
        <member name="F:CbcModel.preferredWay_">
Preferred way of branching
</member>
        <member name="F:CbcModel.maximumCutPasses_">
Maximum number of cut passes
</member>
        <member name="F:CbcModel.maximumCutPassesAtRoot_">
Maximum number of cut passes at root
</member>
        <member name="F:CbcModel.continuousInfeasibilities_">
Number of infeasibilities at continuous
</member>
        <member name="F:CbcModel.originalContinuousObjective_">
Value of objective before root node cuts added

</member>
        <member name="F:CbcModel.continuousObjective_">
Value of objective at continuous
        (Well actually after initial round of cuts)

</member>
        <member name="F:CbcModel.numberFathoms_">
Number of times fast lp entered
</member>
        <member name="F:CbcModel.numberExtraNodes_">
Number of extra nodes in fast lp
</member>
        <member name="F:CbcModel.numberExtraIterations_">
Number of extra iterations in fast lp
</member>
        <member name="F:CbcModel.numberGlobalViolations_">
Number of times global cuts violated.  When global cut pool then this
        should be kept for each cut and type of cut 
</member>
        <member name="F:CbcModel.howOftenGlobalScan_">
How often to scan global cuts
</member>
        <member name="F:CbcModel.originalColumns_">
Original columns as created by integerPresolve or preprocessing
</member>
        <member name="F:CbcModel.ownObjects_">
Now we may not own objects - just point to solver's objects
</member>
        <member name="F:CbcModel.object_">
\brief Integer and Clique and ... information

      \note The code assumes that the first objects on the list will be
        SimpleInteger objects for each integer variable, followed by
        Clique objects. Portions of the code that understand Clique objects
        will fail if they do not immediately follow the SimpleIntegers.
        Large chunks of the code will fail if the first objects are not
        SimpleInteger. As of 2003.08, SimpleIntegers and Cliques are the only
        objects.

</member>
        <member name="F:CbcModel.numberObjects_">
Total number of objects
</member>
        <member name="F:CbcModel.rootSymmetryInfo_">
Root symmetry information
</member>
        <member name="F:CbcModel.symmetryInfo_">
Symmetry information
</member>
        <member name="F:CbcModel.fastNodeDepth_">
Depth for fast nodes
</member>
        <member name="F:CbcModel.lastHeuristic_">
Pointer to heuristic solver which found last solution (or NULL)
</member>
        <member name="F:CbcModel.heuristic_">
Heuristic solvers
</member>
        <member name="F:CbcModel.numberHeuristics_">
Number of heuristics
</member>
        <member name="F:CbcModel.numberCutGenerators_">
Number of cut generators
</member>
        <member name="F:CbcModel.printFrequency_">
Print frequency
</member>
        <member name="F:CbcModel.numberInfeasibleNodes_">
Number of nodes infeasible by normal branching (before cuts)
</member>
        <member name="F:CbcModel.temporaryPointer_">
Useful temporary pointer
</member>
        <member name="F:CbcModel.analyzeResults_">
Arrays with analysis results
</member>
        <member name="F:CbcModel.numberAnalyzeIterations_">
Number of analyze iterations to do
</member>
        <member name="F:CbcModel.penaltyScaleFactor_">
Scale factor to make penalties match strong.
        Should/will be computed 
</member>
        <member name="F:CbcModel.stopNumberIterations_">
For threads - stop after this many "iterations"
</member>
        <member name="F:CbcModel.numberPenalties_">
\brief The number of variables for which to compute penalties
           in dynamic strong branching.

</member>
        <member name="F:CbcModel.numberBeforeTrust_">
\brief The number of branches before pseudo costs believed
           in dynamic strong branching.

      A value of 0 is  off.

</member>
        <member name="F:CbcModel.numberStrong_">
Maximum number of candidates to consider for strong branching.
      To disable strong branching, set this to 0.

</member>
        <member name="F:CbcModel.presolve_">
Presolve for CbcTreeLocal
</member>
        <member name="F:CbcModel.appData_">
Pointer to user-defined data structure
</member>
        <member name="F:CbcModel.cbcRowActivity_">
Pointer to array[getNumRows()] (for speed) of row activity levels.
</member>
        <member name="F:CbcModel.cbcReducedCost_">
Get a pointer to array[getNumCols()] (for speed) of reduced costs
</member>
        <member name="F:CbcModel.cbcRowPrice_">
Pointer to array[getNumRows()] (for speed) of dual prices
</member>
        <member name="F:CbcModel.cbcColSolution_">
Pointer to array[getNumCols()] (for speed) of primal solution vector
</member>
        <member name="F:CbcModel.cbcRowUpper_">
Pointer to array[getNumRows()] (for speed) of row upper bounds
</member>
        <member name="F:CbcModel.cbcRowLower_">
Pointer to array[getNumRows()] (for speed) of row lower bounds
</member>
        <member name="F:CbcModel.cbcColUpper_">
Pointer to array[getNumCols()] (for speed) of column upper bounds
</member>
        <member name="F:CbcModel.cbcColLower_">
Whether to automatically do presolve before branch and bound.
        0 - no
        1 - ordinary presolve
        2 - integer presolve (dodgy)

Pointer to array[getNumCols()] (for speed) of column lower bounds
</member>
        <member name="F:CbcModel.parentModel_">
Parent model
</member>
        <member name="F:CbcModel.strategy_">
Strategy
</member>
        <member name="F:CbcModel.cutModifier_">
Cut modifier function
</member>
        <member name="F:CbcModel.branchingMethod_">
Variable selection function
</member>
        <member name="F:CbcModel.numberStoppedSubTrees_">
Number of times any subtree stopped on nodes, time etc
</member>
        <member name="F:CbcModel.heuristicModel_">
A pointer to model from CbcHeuristic
</member>
        <member name="F:CbcModel.subTreeModel_">
A pointer to model to be used for subtrees
</member>
        <member name="F:CbcModel.topOfTree_">
Pointer to top of tree
</member>
        <member name="F:CbcModel.tree_">
Tree
</member>
        <member name="F:CbcModel.problemFeasibility_">
User feasibility function (see CbcFeasibleBase.hpp)
</member>
        <member name="F:CbcModel.nodeCompare_">
User node comparison function
</member>
        <member name="F:CbcModel.moreSpecialOptions_">
More special options
        at present bottom 6 bits used for shadow price mode
        1024 for experimental hotstart
        2048,4096 breaking out of cuts
        8192 slowly increase minimum drop
        16384 gomory
	32768 more heuristics in sub trees
	65536 no cuts in preprocessing
        131072 Time limits elapsed
        18 bit (262144) - Perturb fathom nodes
        19 bit (524288) - No limit on fathom nodes
        20 bit (1048576) - Reduce sum of infeasibilities before cuts
        21 bit (2097152) - Reduce sum of infeasibilities after cuts

</member>
        <member name="F:CbcModel.specialOptions_">
        Special options
        0 bit (1) - check if cuts valid (if on debugger list)
        1 bit (2) - use current basis to check integer solution (rather than all slack)
        2 bit (4) - don't check integer solution (by solving LP)
        3 bit (8) - fast analyze
        4 bit (16) - non-linear model - so no well defined CoinPackedMatrix
        5 bit (32) - keep names
        6 bit (64) - try for dominated columns
        7 bit (128) - SOS type 1 but all declared integer
        8 bit (256) - Set to say solution just found, unset by doing cuts
        9 bit (512) - Try reduced model after 100 nodes
        10 bit (1024) - Switch on some heuristics even if seems unlikely
        11 bit (2048) - Mark as in small branch and bound
        12 bit (4096) - Funny cuts so do slow way (in some places)
        13 bit (8192) - Funny cuts so do slow way (in other places)
        14 bit (16384) - Use Cplex! for fathoming
        15 bit (32768) - Try reduced model after 0 nodes
        16 bit (65536) - Original model had integer bounds
        17 bit (131072) - Perturbation switched off
        18 bit (262144) - donor CbcModel
        19 bit (524288) - recipient CbcModel
        20 bit (1048576) - waiting for sub model to return
	22 bit (4194304) - do not initialize random seed in solver (user has)
	23 bit (8388608) - leave solver_ with cuts
	24 bit (16777216) - just get feasible if no cutoff

</member>
        <member name="F:CbcModel.usedInSolution_">
Array marked whenever a solution is found if non-zero
</member>
        <member name="F:CbcModel.continuousSolution_">
Holds solution at continuous (after cuts)
</member>
        <member name="F:CbcModel.integerInfo_">
Whether of not integer
</member>
        <member name="F:CbcModel.integerVariable_">
Indices of integer variables
</member>
        <member name="F:CbcModel.currentNode_">
Current node so can be used elsewhere
</member>
        <member name="F:CbcModel.nextRowCut_">
A pointer to a row cut which will be added instead of normal branching.
        After use it should be set to NULL.

</member>
        <member name="F:CbcModel.addedCuts_">
The list of cuts initially collected for this subproblem

      When the subproblem at this node is rebuilt, a set of cuts is collected
      for inclusion in the constraint system. If any of these cuts are
      subsequently removed because they have become loose, the corresponding
      entry is set to NULL.

</member>
        <member name="F:CbcModel.preProcess_">
preProcess used before branch and bound (optional)
</member>
        <member name="F:CbcModel.walkback_">
Array used to assemble the path between a node and the search tree root

      The array is resized when necessary. #maximumDepth_  is the current
      allocated size.

</member>
        <member name="F:CbcModel.maximumDepth_">
Current limit on search tree depth

      The allocated size of #walkback_. Increased as needed.

</member>
        <member name="F:CbcModel.currentNumberCuts_">
Number of entries in #addedCuts_
</member>
        <member name="F:CbcModel.phase_">
Current phase (so heuristics etc etc can find out).
        0 - initial solve
        1 - solve with cuts at root
        2 - solve with cuts
        3 - other e.g. strong branching
        4 - trying to validate a solution
        5 - at end of search

</member>
        <member name="F:CbcModel.maximumNumberCuts_">
Maximum number of cuts
</member>
        <member name="F:CbcModel.cutoffRowNumber_">
-1 - cutoff as constraint not activated
-2 - waiting to activate
&gt;=0 - activated

</member>
        <member name="F:CbcModel.numberRowsAtContinuous_">
Number of rows at continuous
</member>
        <member name="F:CbcModel.numberIntegers_">
Number of integers in problem
</member>
        <member name="F:CbcModel.secondaryStatus_">
Secondary status of problem
        -1 unset (status_ will also be -1)
        0 search completed with solution
        1 linear relaxation not feasible (or worse than cutoff)
        2 stopped on gap
        3 stopped on nodes
        4 stopped on time
        5 stopped on user event
        6 stopped on solutions

</member>
        <member name="F:CbcModel.status_">
Status of problem - 0 finished, 1 stopped, 2 difficulties
</member>
        <member name="F:CbcModel.numberSolves_">
Cumulative number of solves
</member>
        <member name="F:CbcModel.numberIterations_">
Cumulative number of iterations
</member>
        <member name="F:CbcModel.numberNodes2_">
Cumulative number of nodes for statistics.
        Must fix to match up

</member>
        <member name="F:CbcModel.numberNodes_">
Cumulative number of nodes
</member>
        <member name="F:CbcModel.numberHeuristicSolutions_">
Number of heuristic solutions
</member>
        <member name="F:CbcModel.hotstartPriorities_">
Hotstart priorities
</member>
        <member name="F:CbcModel.hotstartSolution_">
Hotstart solution
</member>
        <member name="F:CbcModel.whenCuts_">
At which depths to do cuts
</member>
        <member name="F:CbcModel.stateOfSearch_">
State of search
        0 - no solution
        1 - only heuristic solutions
        2 - branched to a solution
        3 - no solution but many nodes

</member>
        <member name="F:CbcModel.maximumSavedSolutions_">
Maximum number of saved solutions
</member>
        <member name="F:CbcModel.numberSavedSolutions_">
Number of saved solutions
</member>
        <member name="F:CbcModel.numberSolutions_">
Number of solutions
</member>
        <member name="F:CbcModel.minimumDrop_">
Minimum degradation in objective value to continue cut generation
</member>
        <member name="F:CbcModel.globalConflictCuts_">
Global conflict cuts
</member>
        <member name="F:CbcModel.globalCuts_">
Global cuts
</member>
        <member name="F:CbcModel.bestSolutionBasis_">
Warm start object produced by heuristic or strong branching

        If get a valid integer solution outside branch and bound then it can take
        a reasonable time to solve LP which produces clean solution.  If this object has
        any size then it will be used in solve.

</member>
        <member name="F:CbcModel.keepNamesPreproc">
keepNamesPreproc
   *  if variables names will be preserved in the pre-processed problem
   *  (usefull in callbacks)
   *
</member>
        <member name="F:CbcModel.mipStart_">
MIPstart values
      values for integer variables which will be converted to a complete integer initial feasible solution

</member>
        <member name="F:CbcModel.testSolution_">
For testing infeasibilities - will point to
        currentSolution_ or solver--&gt;getColSolution()

</member>
        <member name="F:CbcModel.currentSolution_">
Array holding the current solution.

      This array is used more as a temporary.

</member>
        <member name="F:CbcModel.savedSolutions_">
Arrays holding other solutions.
</member>
        <member name="F:CbcModel.bestSolution_">
Array holding the incumbent (best) solution.
</member>
        <member name="F:CbcModel.sumChangeObjective2_">
Sum of Changes to objective by subsequent solves
</member>
        <member name="F:CbcModel.sumChangeObjective1_">
Sum of Changes to objective by first solve
</member>
        <member name="F:CbcModel.bestPossibleObjective_">
Best possible objective
</member>
        <member name="F:CbcModel.bestObjective_">
Best objective
</member>
        <member name="F:CbcModel.emptyWarmStart_">
Pointer to an empty warm start object

      It turns out to be useful to have this available as a base from
      which to build custom warm start objects. This is typed as CoinWarmStart
      rather than CoinWarmStartBasis to allow for the possibility that a
      client might want to apply a solver that doesn't use a basis-based warm
      start. See getEmptyBasis for an example of how this field can be used.

</member>
        <member name="F:CbcModel.dblParam_">
Array for double parameters
</member>
        <member name="F:CbcModel.intParam_">
Array for integer parameters
</member>
        <member name="F:CbcModel.messages_">
Cbc messages
</member>
        <member name="F:CbcModel.defaultHandler_">
Flag to say if handler_ is the default handler.

      The default handler is deleted when the model is deleted. Other
      handlers (supplied by the client) will not be deleted.

</member>
        <member name="F:CbcModel.handler_">
Message handler
</member>
        <member name="F:CbcModel.referenceSolver_">
A copy of the solver, taken at constructor or by saveReferenceSolver
</member>
        <member name="F:CbcModel.continuousSolver_">
A copy of the solver, taken at the continuous (root) node.
</member>
        <member name="F:CbcModel.ownership_">
Ownership of objects and other stuff

        0x80000000 model owns solver
        0x40000000 all variables CbcDynamicPseudoCost

</member>
        <member name="F:CbcModel.solver_">
@name Private member data
The solver associated with this model.
</member>
        <member name="M:CbcModel.setMIPStart(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst**,System.Double!System.Runtime.CompilerServices.IsConst*)">
may be safer to use this overload method: c++ string libraries 
     * implementation may not be binary compatible 
</member>
        <member name="M:CbcModel.setKeepNamesPreproc(System.Boolean)">
if original column names will be preserved in preprocessed problem

</member>
        <member name="M:CbcModel.redoWalkBack">
Redo walkback arrays
</member>
        <member name="M:CbcModel.setBestSolutionBasis(CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Warm start object produced by heuristic or strong branching

        If get a valid integer solution outside branch and bound then it can take
        a reasonable time to solve LP which produces clean solution.  If this object has
        any size then it will be used in solve.

</member>
        <member name="M:CbcModel.usefulInformation">
Generate an OsiBranchingInformation object
</member>
        <member name="M:CbcModel.generateCpp(_iobuf*,System.Int32)">
Create C++ lines to get to current state
</member>
        <member name="M:CbcModel.allDynamic">
Says whether all dynamic integers
</member>
        <member name="M:CbcModel.setStoredRowCuts(CglStored*)">
Set stored row cuts for donor/recipient CbcModel
</member>
        <member name="M:CbcModel.storedRowCuts">
Get stored row cuts for donor/recipient CbcModel
</member>
        <member name="M:CbcModel.mutableStrongInfo">
Return mutable strong info
</member>
        <member name="M:CbcModel.strongInfo">
Return strong info
</member>
        <member name="M:CbcModel.incrementStrongInfo(System.Int32,System.Int32,System.Int32,System.Boolean)">
Increment strong info
</member>
        <member name="M:CbcModel.numberExtraIterations">
Number of extra iterations
</member>
        <member name="M:CbcModel.zeroExtra">
Zero extra
</member>
        <member name="M:CbcModel.setContinuousPriority(System.Int32)">
Set anything with priority &gt;= this can be treated as continuous
</member>
        <member name="M:CbcModel.continuousPriority">
Get anything with priority &gt;= this can be treated as continuous
</member>
        <member name="M:CbcModel.fastNodeDepth">
Get depth for fast nodes
</member>
        <member name="M:CbcModel.setFastNodeDepth(System.Int32)">
Set depth for fast nodes
</member>
        <member name="M:CbcModel.rootSymmetryInfo">
Root symmetry information
</member>
        <member name="M:CbcModel.zapSymmetry">
get rid of all
</member>
        <member name="M:CbcModel.setSymmetryInfo(CbcSymmetry*)">
Set symmetry information
</member>
        <member name="M:CbcModel.symmetryInfo">
Symmetry information
</member>
        <member name="M:CbcModel.setMaximumNumberIterations(System.Int32)">
Set maximum number of iterations (designed to be used in heuristics)
</member>
        <member name="M:CbcModel.maximumNumberIterations">
Get maximum number of iterations (designed to be used in heuristics)
</member>
        <member name="M:CbcModel.numberStrongIterations">
Get the number of iterations done in strong branching.
</member>
        <member name="M:CbcModel.setNumberStrongIterations(System.Int32)">
Set the number of iterations done in strong branching.
</member>
        <member name="M:CbcModel.randomNumberGenerator">
Thread specific random number generator
</member>
        <member name="M:CbcModel.probingInfo">
Get a pointer to probing info
</member>
        <member name="M:CbcModel.deleteNode(CbcNode*)">
Delete a node and possibly null out currentNode_
</member>
        <member name="M:CbcModel.currentNode">
Get a pointer to current node (be careful)
</member>
        <member name="M:CbcModel.setNextRowCut(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy and set a pointer to a row cut which will be added instead of normal branching.
</member>
        <member name="M:CbcModel.zapGlobalCuts">
Get rid of global cuts
</member>
        <member name="M:CbcModel.globalCuts">
Global cuts
</member>
        <member name="M:CbcModel.currentNumberCuts">
Number of entries in the list returned by #addedCuts()
</member>
        <member name="M:CbcModel.addedCuts">
Return the list of cuts initially collected for this subproblem
</member>
        <member name="M:CbcModel.hotstartPriorities">
Get the hotstart priorities
</member>
        <member name="M:CbcModel.hotstartSolution">
Get the hotstart solution
</member>
        <member name="M:CbcModel.adjustHeuristics">
Adjust heuristics based on model
</member>
        <member name="M:CbcModel.doHeuristicsAtRoot(System.Int32)">
Do heuristics at root.
        0 - don't delete
        1 - delete
        2 - just delete - don't even use

</member>
        <member name="M:CbcModel.fillPseudoCosts(System.Double*,System.Double*,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
Return pseudo costs
        If not all integers or not pseudo costs - returns all zero
        Length of arrays are numberIntegers() and entries
        correspond to integerVariable()[i]
        User must allocate arrays before call

</member>
        <member name="M:CbcModel.pseudoShadow(System.Int32)">
Fill in useful estimates
</member>
        <member name="M:CbcModel.zapIntegerInformation(System.Boolean)">
Zap integer information in problem (may leave object info)
</member>
        <member name="M:CbcModel.synchronizeNumberBeforeTrust(System.Int32)">
Set numberBeforeTrust in all objects
</member>
        <member name="M:CbcModel.convertToDynamic">
If numberBeforeTrust &gt;0 then we are going to use CbcBranchDynamic.
        Scan and convert CbcSimpleInteger objects

</member>
        <member name="M:CbcModel.setObjectiveValue(CbcNode*,CbcNode!System.Runtime.CompilerServices.IsConst*)">
Set objective value in a node.  This is separated out so that
       odd solvers can use.  It may look at extra information in
       solverCharacteriscs_ and will also use bound from parent node

</member>
        <member name="M:CbcModel.previousBounds(CbcNode*,CbcNodeInfo*,System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Returns bounds just before where - initially original bounds.
        Also sets downstream nodes (lower if force 1, upper if 2)

</member>
        <member name="M:CbcModel.addCuts1(CbcNode*,CoinWarmStartBasis**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Traverse the tree from node to root and prep the model

      addCuts1() begins the job of prepping the model to match the current
      subproblem. The model is stripped of all cuts, and the search tree is
      traversed from node to root to determine the changes required. Appropriate
      bounds changes are installed, a list of cuts is collected but not
      installed, and an appropriate basis (minus the cuts, but big enough to
      accommodate them) is constructed.

      Returns true if new problem similar to old

      \todo addCuts1() is called in contexts where it's known in advance that
        all that's desired is to determine a list of cuts and do the
        bookkeeping (adjust the reference counts). The work of installing
        bounds and building a basis goes to waste.

</member>
        <member name="M:CbcModel.addCuts(CbcNode*,CoinWarmStartBasis**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Determine and install the active cuts that need to be added for
      the current subproblem

      The whole truth is a bit more complicated. The first action is a call to
      addCuts1(). addCuts() then sorts through the list, installs the tight
      cuts in the model, and does bookkeeping (adjusts reference counts).
      The basis returned from addCuts1() is adjusted accordingly.

      If it turns out that the node should really be fathomed by bound,
      addCuts() simply treats all the cuts as loose as it does the bookkeeping.


</member>
        <member name="M:CbcModel.takeOffCuts(OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,OsiCuts*,System.Int32,OsiRowCut!System.Runtime.CompilerServices.IsConst**)">
Remove inactive cuts from the model

      An OsiSolverInterface is expected to maintain a valid basis, but not a
      valid solution, when loose cuts are deleted. Restoring a valid solution
      requires calling the solver to reoptimise. If it's certain the solution
      will not be required, set allowResolve to false to suppress
      reoptimisation.
      If saveCuts then slack cuts will be saved
      On input current cuts are cuts and newCuts
      on exit current cuts will be correct.  Returns number dropped

</member>
        <member name="M:CbcModel.getEmptyBasis(System.Int32,System.Int32)">
Return an empty basis object of the specified size

      A useful utility when constructing a basis for a subproblem from scratch.
      The object returned will be of the requested capacity and appropriate for
      the solver attached to the model.

</member>
        <member name="M:CbcModel.chooseBranch(CbcNode**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,CbcNode*,OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinWarmStartBasis*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Encapsulates choosing a variable -
        anyAction -2, infeasible (-1 round again), 0 done

</member>
        <member name="M:CbcModel.resolve(OsiSolverInterface*)">
Encapsulates solver resolve
</member>
        <member name="M:CbcModel.deleteSolutions">
Delete best and saved solutions
</member>
        <member name="M:CbcModel.saveBestSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double)">
Save a solution to best and move current to saved
</member>
        <member name="M:CbcModel.saveExtraSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double)">
Save a solution to saved list
</member>
        <member name="M:CbcModel.synchronizeHandlers(System.Int32)">
Makes all handlers same.  If makeDefault 1 then makes top level
        default and rest point to that.  If 2 then each is copy

</member>
        <member name="M:CbcModel.reducedCostFix">
Perform reduced cost fixing

      Fixes integer variables at their current value based on reduced cost
      penalties.  Returns number fixed

</member>
        <member name="M:CbcModel.setPointers(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Set pointers for speed
</member>
        <member name="M:CbcModel.getNodeCount2">
@name semi-private i.e. users should not use
Get how many Nodes it took to solve the problem.
</member>
        <member name="M:CbcModel.mergeModels(System.Int32,CbcModel**,System.Int32)">
Merge models
</member>
        <member name="M:CbcModel.startSplitModel(System.Int32)">
Start threads
</member>
        <member name="M:CbcModel.splitModel(System.Int32,CbcModel**,System.Int32)">
Split up nodes
</member>
        <member name="M:CbcModel.moveToModel(CbcModel*,System.Int32)">
Move/copy information from one model to another
        -1 - initialization
        0 - from base model
        1 - to base model (and reset)
        2 - add in final statistics etc (and reset so can do clean destruction)

</member>
        <member name="M:CbcModel.setInfoInChild(System.Int32,CbcThread*)">
Set information in a child
        -3 pass pointer to child thread info
        -2 just stop
        -1 delete simple child stuff
        0 delete opportunistic child stuff
        1 delete deterministic child stuff

</member>
        <member name="M:CbcModel.unlockThread">
Unlocks a thread if parallel to say cut pool stuff not needed

</member>
        <member name="M:CbcModel.lockThread">
Locks a thread if parallel so that stuff like cut pool
can be updated and/or used.

</member>
        <member name="M:CbcModel.isLocked">
From here to end of section - code in CbcThread.cpp until class changed
Returns true if locked
</member>
        <member name="M:CbcModel.master">
Thread stuff for master
</member>
        <member name="M:CbcModel.parallelMode">
Return
        -2 if deterministic threaded and main thread
        -1 if deterministic threaded and serial thread
        0 if serial
        1 if opportunistic threaded

</member>
        <member name="M:CbcModel.setThreadMode(System.Int32)">
Set thread mode
        always use numberThreads for branching
        1 set then deterministic
        2 set then use numberThreads for root cuts
        4 set then use numberThreads in root mini branch and bound
        8 set and numberThreads - do heuristics numberThreads at a time
        8 set and numberThreads==0 do all heuristics at once
        default is 0

</member>
        <member name="M:CbcModel.getThreadMode">
Get thread mode
</member>
        <member name="M:CbcModel.setNumberThreads(System.Int32)">
Set number of threads
</member>
        <member name="M:CbcModel.getNumberThreads">
Get number of threads
</member>
        <member name="M:CbcModel.walkback">
Get pointer to walkback
</member>
        <member name="M:CbcModel.masterThread">
Get pointer to masterthread
</member>
        <member name="M:CbcModel.haveMultiThreadSupport">
@name Multithreading
Indicates whether Cbc library has been compiled with multithreading support
</member>
        <member name="M:CbcModel.moveInfo(CbcModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Move status, nodes etc etc across
</member>
        <member name="M:CbcModel.gutsOfCopy(CbcModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Most of copy constructor
        mode - 0 copy but don't delete before
               1 copy and delete before
           2 copy and delete before (but use virgin generators)

</member>
        <member name="M:CbcModel.resetModel">
Clears out enough to reset CbcModel cutoff etc

</member>
        <member name="M:CbcModel.gutsOfDestructor2">
Clears out enough to reset CbcModel as if no branch and bound done

</member>
        <member name="M:CbcModel.gutsOfDestructor">
Clears out as much as possible (except solver)
</member>
        <member name="M:CbcModel.resetToReferenceSolver">
Uses a copy of reference solver to be current solver.
        Because of possible mismatches all exotic integer information is loat
        (apart from normal information in OsiSolverInterface)
        so SOS etc and priorities will have to be redone

</member>
        <member name="M:CbcModel.saveReferenceSolver">
Save a copy of the current solver so can be reset to
</member>
        <member name="M:CbcModel.referenceSolver">
A copy of the solver, taken at constructor or by saveReferenceSolver
</member>
        <member name="M:CbcModel.clearContinuousSolver">
Clear solver with continuous state
</member>
        <member name="M:CbcModel.createContinuousSolver">
Create solver with continuous state
</member>
        <member name="M:CbcModel.continuousSolver">
Returns solver with continuous state
</member>
        <member name="M:CbcModel.swapSolver(OsiSolverInterface*)">
Returns current solver - sets new one
</member>
        <member name="M:CbcModel.solver">
Returns solver - has current state
</member>
        <member name="M:CbcModel.Dispose">
Destructor
</member>
        <member name="M:CbcModel.op_Assign(CbcModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcModel.clone(System.Boolean)">
Clone 
</member>
        <member name="M:CbcModel.#ctor(CbcModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Copy constructor .
      If cloneHandler is true then message handler is cloned

</member>
        <member name="M:CbcModel.setModelOwnsSolver(System.Boolean)">
\brief Set ownership of solver

      A parameter of false tells CbcModel it does not own the solver and
      should not delete it. Once you claim ownership of the solver, you're
      responsible for eventually deleting it. Note that CbcModel clones
      solvers with abandon.  Unless you have a deep understanding of the
      workings of CbcModel, the only time you want to claim ownership is when
      you're about to delete the CbcModel object but want the solver to
      continue to exist (as, for example, when branchAndBound has finished
      and you want to hang on to the answer).

</member>
        <member name="M:CbcModel.assignSolver(OsiSolverInterface**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Assign a solver to the model (model assumes ownership)

      On return, \p solver will be NULL.
      If deleteSolver then current solver deleted (if model owned)

      \note Parameter settings in the outgoing solver are not inherited by
        the incoming solver.

</member>
        <member name="M:CbcModel.#ctor(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor from solver
</member>
        <member name="M:CbcModel.#ctor">
@name Constructors and destructors etc
Default Constructor
</member>
        <member name="M:CbcModel.checkModel">
Check original model before it gets messed up
</member>
        <member name="M:CbcModel.ownObjects">
Now we may not own objects - just point to solver's objects
</member>
        <member name="M:CbcModel.goToDantzig(System.Int32,ClpDualRowPivot**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Go to dantzig pivot selection if easy problem (clp only)
</member>
        <member name="M:CbcModel.setTemporaryPointer(System.Void*)">
Set useful temporary pointer
</member>
        <member name="M:CbcModel.temporaryPointer">
Get useful temporary pointer
</member>
        <member name="M:CbcModel.useElapsedTime">
Get time method
</member>
        <member name="M:CbcModel.setUseElapsedTime(System.Boolean)">
Set time method
</member>
        <member name="M:CbcModel.setCutoffAsConstraint(System.Boolean)">
Set cutoff as constraint
</member>
        <member name="M:CbcModel.moreSpecialOptions2">
Get more special options2
</member>
        <member name="M:CbcModel.moreSpecialOptions">
Get more special options
</member>
        <member name="M:CbcModel.setMoreSpecialOptions(System.Int32)">
Set more special options
        at present bottom 6 bits used for shadow price mode
        1024 for experimental hotstart
        2048,4096 breaking out of cuts
        8192 slowly increase minimum drop
        16384 gomory
	32768 more heuristics in sub trees
	65536 no cuts in preprocessing
        131072 Time limits elapsed
        18 bit (262144) - Perturb fathom nodes
        19 bit (524288) - No limit on fathom nodes
        20 bit (1048576) - Reduce sum of infeasibilities before cuts
        21 bit (2097152) - Reduce sum of infeasibilities after cuts
	22 bit (4194304) - Conflict analysis
	23 bit (8388608) - Conflict analysis - temporary bit
	24 bit (16777216) - Add cutoff as LP constraint (out)
	25 bit (33554432) - diving/reordering
	26 bit (67108864) - load global cuts from file
	27 bit (134217728) - append binding global cuts to file
	28 bit (268435456) - idiot branching
        29 bit (536870912) - don't make fake objective
	30 bit (1073741824) - Funny SOS or similar - be careful

</member>
        <member name="M:CbcModel.waitingForMiniBranchAndBound">
Says if model is sitting there waiting for mini branch and bound to finish
	This is because an event handler may only have access to parent model in
	mini branch and bound

</member>
        <member name="M:CbcModel.normalSolver">
Says if normal solver i.e. has well defined CoinPackedMatrix
</member>
        <member name="M:CbcModel.sayEventHappened">
Tell model to stop on event
</member>
        <member name="M:CbcModel.getMultipleRootTries">
Get multiple root tries
</member>
        <member name="M:CbcModel.setMultipleRootTries(System.Int32)">
Set multiple root tries
</member>
        <member name="M:CbcModel.getRandomSeed">
Get random seed
</member>
        <member name="M:CbcModel.setRandomSeed(System.Int32)">
Set random seed
</member>
        <member name="M:CbcModel.specialOptions">
Get special options
</member>
        <member name="M:CbcModel.setSpecialOptions(System.Int32)">
@name Specialized
        Set special options
        0 bit (1) - check if cuts valid (if on debugger list)
        1 bit (2) - use current basis to check integer solution (rather than all slack)
        2 bit (4) - don't check integer solution (by solving LP)
        3 bit (8) - fast analyze
        4 bit (16) - non-linear model - so no well defined CoinPackedMatrix
        5 bit (32) - keep names
        6 bit (64) - try for dominated columns
        7 bit (128) - SOS type 1 but all declared integer
        8 bit (256) - Set to say solution just found, unset by doing cuts
        9 bit (512) - Try reduced model after 100 nodes
        10 bit (1024) - Switch on some heuristics even if seems unlikely
        11 bit (2048) - Mark as in small branch and bound
        12 bit (4096) - Funny cuts so do slow way (in some places)
        13 bit (8192) - Funny cuts so do slow way (in other places)
        14 bit (16384) - Use Cplex! for fathoming
        15 bit (32768) - Try reduced model after 0 nodes
        16 bit (65536) - Original model had integer bounds
        17 bit (131072) - Perturbation switched off
        18 bit (262144) - donor CbcModel
        19 bit (524288) - recipient CbcModel
        20 bit (1048576) - waiting for sub model to return
	22 bit (4194304) - do not initialize random seed in solver (user has)
	23 bit (8388608) - leave solver_ with cuts
	24 bit (16777216) - just get feasible if no cutoff
	25 bit (33554432) - feasibility pump after root cuts
	26 bit (67108864) - child model but going for complete search

</member>
        <member name="M:CbcModel.defaultHandler">
Check default handler
</member>
        <member name="M:CbcModel.setDefaultHandler(System.Boolean)">
Set flag to say if handler_ is the default handler.

      The default handler is deleted when the model is deleted. Other
      handlers (supplied by the client) will not be deleted.

</member>
        <member name="M:CbcModel.logLevel">
Get log level
</member>
        <member name="M:CbcModel.setLogLevel(System.Int32)">
Set log level
</member>
        <member name="M:CbcModel.messagesPointer">
Return pointer to messages
</member>
        <member name="M:CbcModel.messages">
Return messages
</member>
        <member name="M:CbcModel.messageHandler">
Return handler
</member>
        <member name="M:CbcModel.newLanguage(CoinMessages.Language)">
Set language
</member>
        <member name="M:CbcModel.passInMessageHandler(CoinMessageHandler*)">
@name Message handling etc 
Pass in Message handler (not deleted at end)
</member>
        <member name="M:CbcModel.solverCharacteristics">
Get solver characteristics
</member>
        <member name="M:CbcModel.passInSolverCharacteristics(OsiBabSolver*)">
For advanced applications you may wish to modify the behavior of Cbc
e.g. if the solver is a NLP solver then you may not have an exact
optimum solution at each step.  Information could be built into
OsiSolverInterface but this is an alternative so that that interface
does not have to be changed.  If something similar is useful to
enough solvers then it could be migrated
You can also pass in by using solver-&gt;setAuxiliaryInfo.
You should do that if solver is odd - if solver is normal simplex
then use this.
NOTE - characteristics are not cloned

</member>
        <member name="M:CbcModel.getApplicationData">
Get application data
</member>
        <member name="M:CbcModel.setApplicationData(System.Void*)">
@name Setting/Accessing application data 
Set application data.

    This is a pointer that the application can store into and
    retrieve from the solver interface.
    This field is available for the application to optionally
    define and use.

</member>
        <member name="M:CbcModel.priority(System.Int32)">
Returns priority level for an object (or 1000 if no priorities exist)
</member>
        <member name="M:CbcModel.passInPriorities(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Pass in branching priorities.

        If ifClique then priorities are on cliques otherwise priorities are
        on integer variables.
        Other type (if exists set to default)
        1 is highest priority. (well actually -INT_MAX is but that's ugly)
        If hotstart &gt; 0 then branches are created to force
        the variable to the value given by best solution.  This enables a
        sort of hot start.  The node choice should be greatest depth
        and hotstart should normally be switched off after a solution.

        If ifNotSimpleIntegers true then appended to normal integers

        This is now deprecated except for simple usage.  If user
        creates Cbcobjects then set priority in them

        \internal Added for Kurt Spielberg.

</member>
        <member name="M:CbcModel.setLastHeuristic(CbcHeuristic*)">
set last heuristic which found a solution
</member>
        <member name="M:CbcModel.lastHeuristic">
Pointer to heuristic solver which found last solution (or NULL)
</member>
        <member name="M:CbcModel.setNumberHeuristics(System.Int32)">
Set the number of heuristics
</member>
        <member name="M:CbcModel.numberHeuristics">
Get the number of heuristics
</member>
        <member name="M:CbcModel.heuristic(System.Int32)">
Get the specified heuristic
</member>
        <member name="M:CbcModel.addHeuristic(CbcHeuristic*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32)">
\name Heuristics and priorities 
</member>
        <member name="M:CbcModel.setParentModel(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the parent model
</member>
        <member name="M:CbcModel.parentModel">
Get the current parent model
</member>
        <member name="M:CbcModel.setStrategy(CbcStrategy*)">
Set the strategy. assigns
</member>
        <member name="M:CbcModel.setStrategy(CbcStrategy*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the strategy. Clones
</member>
        <member name="M:CbcModel.strategy">
\name Strategy and sub models

      See the CbcStrategy class for additional information.

Get the current strategy
</member>
        <member name="M:CbcModel.addCutGenerator(CglCutGenerator*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32)">
Add one generator - up to user to delete generators.
        howoften affects how generator is used. 0 or 1 means always,
        &gt;1 means every that number of nodes.  Negative values have same
        meaning as positive but they may be switched off (-&gt; -100) by code if
        not many cuts generated at continuous.  -99 is just done at root.
        Name is just for printout.
        If depth &gt;0 overrides how often generator is called (if howOften==-1 or &gt;0).

</member>
        <member name="M:CbcModel.virginCutGenerator(System.Int32)">
Get the specified cut generator before any changes
</member>
        <member name="M:CbcModel.cutGenerator(System.Int32)">
Get the specified cut generator
</member>
        <member name="M:CbcModel.cutGenerators">
Get the list of cut generators
</member>
        <member name="M:CbcModel.numberCutGenerators">
Get the number of cut generators
</member>
        <member name="M:CbcModel.setStrongStrategy(System.Int32)">
Set strong branching strategy
</member>
        <member name="M:CbcModel.strongStrategy">
Stong branching strategy
</member>
        <member name="M:CbcModel.setSearchStrategy(System.Int32)">
Set strategy worked out - mainly at root node for use by CbcNode
</member>
        <member name="M:CbcModel.searchStrategy">
Strategy worked out - mainly at root node for use by CbcNode
</member>
        <member name="M:CbcModel.stateOfSearch">
\name Row (constraint) and Column (variable) cut generation 
State of search
        0 - no solution
        1 - only heuristic solutions
        2 - branched to a solution
        3 - no solution but many nodes

</member>
        <member name="M:CbcModel.setCutModifier(CbcCutModifier*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the cut modifier method

      \overload

</member>
        <member name="M:CbcModel.setCutModifier(CbcCutModifier*)">
Set the cut modifier method
</member>
        <member name="M:CbcModel.cutModifier">
Get the current cut modifier method
</member>
        <member name="M:CbcModel.setBranchingMethod(CbcBranchDecision*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set the branching method

      \overload

</member>
        <member name="M:CbcModel.setBranchingMethod(CbcBranchDecision*)">
Set the branching decision method.
</member>
        <member name="M:CbcModel.branchingMethod">
\name Branching Decisions

      See the CbcBranchDecision class for additional information.

Get the current branching decision method.
</member>
        <member name="M:CbcModel.typePresolve">
Whether to automatically do presolve before branch and bound (subTrees).
        0 - no
        1 - ordinary presolve
        2 - integer presolve (dodgy)

</member>
        <member name="M:CbcModel.incrementSubTreeStopped">
Says a sub tree was stopped
</member>
        <member name="M:CbcModel.numberStoppedSubTrees">
Returns number of times any subtree stopped on nodes, time etc
</member>
        <member name="M:CbcModel.subTreeModel(OsiSolverInterface*)">
For retrieving a copy of subtree model with given OsiSolver.
        If no subtree model will use self (up to user to reset cutoff etc).
        If solver NULL uses current

</member>
        <member name="M:CbcModel.passInSubTreeModel(CbcModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
For passing in an CbcModel to do a sub Tree (with derived tree handlers).
        Passed in model must exist for duration of branch and bound

</member>
        <member name="M:CbcModel.passInTreeHandler(CbcTree*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
For modifying tree handling (original is cloned)
</member>
        <member name="M:CbcModel.tree">
\name Tree methods and subtree methods 
Tree method e.g. heap (which may be overridden by inheritance)
</member>
        <member name="M:CbcModel.problemFeasibility">
\name Problem feasibility checking 
</member>
        <member name="M:CbcModel.nodeComparison">
\name Node selection 
</member>
        <member name="M:CbcModel.setHeuristicModel(CbcModel*)">
Set a pointer to model from CbcHeuristic
</member>
        <member name="M:CbcModel.heuristicModel">
A pointer to model from CbcHeuristic
</member>
        <member name="M:CbcModel.setStopNumberIterations(System.Int32)">
Set number of "iterations" to stop after
</member>
        <member name="M:CbcModel.getStopNumberIterations">
Get number of "iterations" to stop after
</member>
        <member name="M:CbcModel.workingBasis">
Work basis for temporary use
</member>
        <member name="M:CbcModel.maximumRows">
Maximum number of rows
</member>
        <member name="M:CbcModel.resolveAfterTakeOffCuts">
Whether to force a resolve after takeOffCuts
</member>
        <member name="M:CbcModel.numberGlobalViolations">
Number of times global cuts violated.  When global cut pool then this
        should be kept for each cut and type of cut 
</member>
        <member name="M:CbcModel.sumChangeObjective">
Sum of Changes to objective by first solve
</member>
        <member name="M:CbcModel.rootObjectiveAfterCuts">
Value of objective after root node cuts added
</member>
        <member name="M:CbcModel.getContinuousInfeasibilities">
Number of infeasibilities at continuous
</member>
        <member name="M:CbcModel.getContinuousObjective">
Value of objective at continuous
</member>
        <member name="M:CbcModel.setObjSense(System.Double)">
Set objective function sense (1 for min (default), -1 for max,)
</member>
        <member name="M:CbcModel.setNumberHeuristicSolutions(System.Int32)">
Set number of heuristic solutions
</member>
        <member name="M:CbcModel.getNumberHeuristicSolutions">
Get number of heuristic solutions
</member>
        <member name="M:CbcModel.phase">
Current phase (so heuristics etc etc can find out).
        0 - initial solve
        1 - solve with cuts at root
        2 - solve with cuts
        3 - other e.g. strong branching
        4 - trying to validate a solution
        5 - at end of search

</member>
        <member name="M:CbcModel.deleteSavedSolution(System.Int32)">
Delete a saved solution and move others up
</member>
        <member name="M:CbcModel.savedSolutionObjective(System.Int32)">
Return a saved solution objective (0==best) - COIN_DBL_MAX if off end
</member>
        <member name="M:CbcModel.savedSolution(System.Int32)">
Return a saved solution (0==best) - NULL if off end
</member>
        <member name="M:CbcModel.setMaximumSavedSolutions(System.Int32)">
Set maximum number of extra saved solutions
</member>
        <member name="M:CbcModel.maximumSavedSolutions">
Maximum number of extra saved solutions
</member>
        <member name="M:CbcModel.numberSavedSolutions">
Number of saved solutions (including best)
</member>
        <member name="M:CbcModel.setSolutionCount(System.Int32)">
Set number of solutions (so heuristics will be different)
</member>
        <member name="M:CbcModel.getSolutionCount">
Get number of solutions
</member>
        <member name="M:CbcModel.setBestSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Boolean)">
User callable setBestSolution.
        If check false does not check valid
        If true then sees if feasible and warns if objective value
        worse than given (so just set to COIN_DBL_MAX if you don't care).
        If check true then does not save solution if not feasible

</member>
        <member name="M:CbcModel.bestSolution">
The best solution to the integer programming problem.

      The best solution to the integer programming problem found during
      the search. If no solution is found, the method returns null.

</member>
        <member name="M:CbcModel.getSolverObjValue">
Get solver objective function value (as minimization)
</member>
        <member name="M:CbcModel.setObjValue(System.Double)">
Set best objective function value
</member>
        <member name="M:CbcModel.getBestPossibleObjValue">
Get best possible objective function value.
        This is better of best possible left on tree
        and best solution found.
        If called from within branch and cut may be optimistic.

</member>
        <member name="M:CbcModel.getObjValue">
Get best objective function value
</member>
        <member name="M:CbcModel.setMinimizationObjValue(System.Double)">
Set best objective function value as minimization
</member>
        <member name="M:CbcModel.getMinimizationObjValue">
Get best objective function value as minimization
</member>
        <member name="M:CbcModel.getCurrentMinimizationObjValue">
Get current minimization objective function value
</member>
        <member name="M:CbcModel.getCurrentObjValue">
Get current objective function value
</member>
        <member name="M:CbcModel.trueCutoff">
Return cutoff value with sign corrected
</member>
        <member name="M:CbcModel.trueObjValue(System.Double)">
Return objective function value with sign corrected
</member>
        <member name="M:CbcModel.modelFlipped">
Return true if model flipped to make minimize (for printing)
</member>
        <member name="M:CbcModel.getRowActivity">
Get pointer to array[getNumRows()] of row activity levels.
</member>
        <member name="M:CbcModel.getReducedCost">
Get a pointer to array[getNumCols()] of reduced costs
</member>
        <member name="M:CbcModel.getRowPrice">
Get pointer to array[getNumRows()] of dual prices
</member>
        <member name="M:CbcModel.getColSolution">
Get pointer to array[getNumCols()] of primal solution vector
</member>
        <member name="M:CbcModel.reserveCurrentSolution(System.Double!System.Runtime.CompilerServices.IsConst*)">
Make sure region there and optionally copy solution
</member>
        <member name="M:CbcModel.testSolution">
For testing infeasibilities - will point to
        currentSolution_ or solver--&gt;getColSolution()

</member>
        <member name="M:CbcModel.currentSolution">
Solution to the most recent lp relaxation.

      The solver's solution to the most recent lp relaxation.

</member>
        <member name="M:CbcModel.feasibleSolution(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Test the current solution for feasiblility.

      Scan all objects for indications of infeasibility. This is broken down
      into simple integer infeasibility (\p numberIntegerInfeasibilities)
      and all other reports of infeasibility (\p numberObjectInfeasibilities).

</member>
        <member name="M:CbcModel.checkSolution(System.Double,System.Double*,System.Int32,System.Double)">
Call this to really test if a valid solution can be feasible
        Solution is number columns in size.
        If fixVariables true then bounds of continuous solver updated.
        Returns objective value (worse than cutoff if not feasible)
        Previously computed objective value is now passed in (in case user does not do solve)
	virtual so user can override

</member>
        <member name="M:CbcModel.dealWithEventHandler(CbcEventHandler.CbcEvent,System.Double,System.Double!System.Runtime.CompilerServices.IsConst*)">
Deals with event handler and solution
</member>
        <member name="M:CbcModel.setBestObjectiveValue(System.Double)">
Just update objectiveValue
</member>
        <member name="M:CbcModel.setBestSolution(CBC_Message,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Record a new incumbent solution and update objectiveValue
</member>
        <member name="M:CbcModel.incrementUsed(System.Double!System.Runtime.CompilerServices.IsConst*)">
Increases usedInSolution for nonzeros
</member>
        <member name="M:CbcModel.usedInSolution">
Array marked whenever a solution is found if non-zero.
        Code marks if heuristic returns better so heuristic
        need only mark if it wants to on solutions which
        are worse than current 
</member>
        <member name="M:CbcModel.continuousSolution">
@name Methods related to querying the solution 
Holds solution at continuous (after cuts if branchAndBound called)
</member>
        <member name="M:CbcModel.getCbcRowActivity">
Get pointer to array[getNumRows()] (for speed) of row activity levels.
</member>
        <member name="M:CbcModel.getCbcReducedCost">
Get a pointer to array[getNumCols()] (for speed) of reduced costs
</member>
        <member name="M:CbcModel.getCbcRowPrice">
Get pointer to array[getNumRows()] (for speed) of dual prices
</member>
        <member name="M:CbcModel.getCbcColSolution">
Get pointer to array[getNumCols()] (for speed) of primal solution vector
</member>
        <member name="M:CbcModel.getCbcRowUpper">
Get pointer to array[getNumRows()] (for speed) of row upper bounds
</member>
        <member name="M:CbcModel.getCbcRowLower">
Get pointer to array[getNumRows()] (for speed) of row lower bounds
</member>
        <member name="M:CbcModel.getCbcColUpper">
Get pointer to array[getNumCols()] (for speed) of column upper bounds
</member>
        <member name="M:CbcModel.getCbcColLower">
Get pointer to array[getNumCols()] (for speed) of column lower bounds
</member>
        <member name="M:CbcModel.getInfinity">
Get solver's value for infinity
</member>
        <member name="M:CbcModel.getMatrixByCol">
Get pointer to column-wise copy of matrix
</member>
        <member name="M:CbcModel.getMatrixByRow">
Get pointer to row-wise copy of matrix
</member>
        <member name="M:CbcModel.isFreeBinary(System.Int32)">
Return true if variable is binary and not fixed at either bound
</member>
        <member name="M:CbcModel.isIntegerNonBinary(System.Int32)">
Return true if variable is general integer
</member>
        <member name="M:CbcModel.isInteger(System.Int32)">
Return true if column is integer.
        Note: This function returns true if the the column
        is binary or a general integer.

</member>
        <member name="M:CbcModel.isBinary(System.Int32)">
Return true if variable is binary
</member>
        <member name="M:CbcModel.isContinuous(System.Int32)">
Return true if variable is continuous
</member>
        <member name="M:CbcModel.getObjSense">
Get objective function sense (1 for min (default), -1 for max)
</member>
        <member name="M:CbcModel.getObjCoefficients">
Get pointer to array[getNumCols()] of objective function coefficients
</member>
        <member name="M:CbcModel.getRowUpper">
Get pointer to array[getNumRows()] of row upper bounds
</member>
        <member name="M:CbcModel.getRowLower">
Get pointer to array[getNumRows()] of row lower bounds
</member>
        <member name="M:CbcModel.getColUpper">
Get pointer to array[getNumCols()] of column upper bounds
</member>
        <member name="M:CbcModel.getColLower">
Get pointer to array[getNumCols()] of column lower bounds
</member>
        <member name="M:CbcModel.integerType">
Whether or not integer
</member>
        <member name="M:CbcModel.integerType(System.Int32)">
Whether or not integer
</member>
        <member name="M:CbcModel.numberIntegers">
Number of integers in problem
</member>
        <member name="M:CbcModel.getNumElements">
Get number of nonzero elements
</member>
        <member name="M:CbcModel.getNumRows">
Get number of rows
</member>
        <member name="M:CbcModel.getNumCols">
Get number of columns
</member>
        <member name="M:CbcModel.numberRowsAtContinuous">
@name Problem information methods

       These methods call the solver's query routines to return
       information about the problem referred to by the current object.
       Querying a problem that has no data associated with it result in
       zeros for the number of rows and columns, and NULL pointers from
       the methods that return vectors.

       Const pointers returned from any data-query method are valid as
       long as the data is unchanged and the solver is not called.

Number of rows in continuous (root) problem.
</member>
        <member name="M:CbcModel.isInitialSolveProvenDualInfeasible">
Is dual infeasiblity proven (for initialSolve) ?
</member>
        <member name="M:CbcModel.isInitialSolveProvenPrimalInfeasible">
Is primal infeasiblity proven (for initialSolve) ?
</member>
        <member name="M:CbcModel.isInitialSolveProvenOptimal">
Is optimality proven (for initialSolve) ?
</member>
        <member name="M:CbcModel.isInitialSolveAbandoned">
Are there numerical difficulties (for initialSolve) ?
</member>
        <member name="M:CbcModel.secondaryStatus">
Secondary status of problem
        -1 unset (status_ will also be -1)
        0 search completed with solution
        1 linear relaxation not feasible (or worse than cutoff)
        2 stopped on gap
        3 stopped on nodes
        4 stopped on time
        5 stopped on user event
        6 stopped on solutions
        7 linear relaxation unbounded
        8 stopped on iteration limit

</member>
        <member name="M:CbcModel.status">
Final status of problem
        Some of these can be found out by is...... functions
        -1 before branchAndBound
        0 finished - check isProvenOptimal or isProvenInfeasible to see if solution found
        (or check value of best solution)
        1 stopped - on maxnodes, maxsols, maxtime
        2 difficulties so run was abandoned
        (5 event user programmed event occurred)

</member>
        <member name="M:CbcModel.incrementNodeCount(System.Int32)">
Increment how many nodes it took to solve the problem.
</member>
        <member name="M:CbcModel.incrementIterationCount(System.Int32)">
Increment how many iterations it took to solve the problem.
</member>
        <member name="M:CbcModel.getIterationCount">
Get how many iterations it took to solve the problem.
</member>
        <member name="M:CbcModel.isSolutionLimitReached">
Solution limit reached?
</member>
        <member name="M:CbcModel.isSecondsLimitReached">
Time limit reached?
</member>
        <member name="M:CbcModel.isNodeLimitReached">
Node limit reached?
</member>
        <member name="M:CbcModel.isProvenDualInfeasible">
Was continuous solution unbounded
</member>
        <member name="M:CbcModel.isContinuousUnbounded">
Was continuous solution unbounded
</member>
        <member name="M:CbcModel.isProvenInfeasible">
Is  infeasiblity proven (or none better than cutoff)?
</member>
        <member name="M:CbcModel.isProvenOptimal">
Is optimality proven?
</member>
        <member name="M:CbcModel.isAbandoned">
@name Methods returning info on how the solution process terminated
Are there a numerical difficulties?
</member>
        <member name="M:CbcModel.printFrequency">
Get the print frequency
</member>
        <member name="M:CbcModel.conflictCut(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create conflict cut (well - most of)
</member>
        <member name="M:CbcModel.setOriginalColumns(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Set original columns as created by preprocessing
</member>
        <member name="M:CbcModel.originalColumns">
Original columns as created by integerPresolve or preprocessing
</member>
        <member name="M:CbcModel.howOftenGlobalScan">
Get how often to scan global cuts
</member>
        <member name="M:CbcModel.setHowOftenGlobalScan(System.Int32)">
Set how often to scan global cuts
</member>
        <member name="M:CbcModel.currentDepth">
Current depth
</member>
        <member name="M:CbcModel.setPenaltyScaleFactor(System.Double)">
Set scale factor to make penalties match strong.
        Should/will be computed 
</member>
        <member name="M:CbcModel.penaltyScaleFactor">
Get scale factor to make penalties match strong.
        Should/will be computed 
</member>
        <member name="M:CbcModel.setNumberAnalyzeIterations(System.Int32)">
Number of analyze iterations to do
</member>
        <member name="M:CbcModel.topOfTree">
Pointer to top of tree
</member>
        <member name="M:CbcModel.numberPenalties">
get the number of variables for which to compute penalties
        in dynamic strong branching. 
</member>
        <member name="M:CbcModel.setNumberPenalties(System.Int32)">
Set the number of variables for which to compute penalties
        in dynamic strong branching.

      A value of 0 disables penalties.

</member>
        <member name="M:CbcModel.numberBeforeTrust">
get the number of branches before pseudo costs believed
        in dynamic strong branching. 
</member>
        <member name="M:CbcModel.setNumberBeforeTrust(System.Int32)">
Set the number of branches before pseudo costs believed
        in dynamic strong branching.

      A value of 0 disables dynamic strong branching.

</member>
        <member name="M:CbcModel.doCutsNow(System.Int32)">
Return true if we want to do cuts
        If allowForTopOfTree zero then just does on multiples of depth
        if 1 then allows for doing at top of tree
        if 2 then says if cuts allowed anywhere apart from root

</member>
        <member name="M:CbcModel.setWhenCuts(System.Int32)">
Set at which depths to do cuts
</member>
        <member name="M:CbcModel.whenCuts">
Get at which depths to do cuts
</member>
        <member name="M:CbcModel.getPreferredWay">
Get the preferred way to branch (default 0) 
</member>
        <member name="M:CbcModel.setPreferredWay(System.Int32)">
Set global preferred way to branch
        -1 down, +1 up, 0 no preference 
</member>
        <member name="M:CbcModel.numberStrong">
Get the maximum number of candidates to be evaluated for strong
      branching.

</member>
        <member name="M:CbcModel.setNumberStrong(System.Int32)">
Set the maximum number of candidates to be evaluated for strong
      branching.

      A value of 0 disables strong branching.

</member>
        <member name="M:CbcModel.setCurrentPassNumber(System.Int32)">
Set current cut pass number in this round of cuts.
        (1 is first pass) 
</member>
        <member name="M:CbcModel.getCurrentPassNumber">
Get current cut pass number in this round of cuts.
        (1 is first pass) 
</member>
        <member name="M:CbcModel.getMaximumCutPasses">
Get the maximum number of cut passes at other nodes (default 10) 
</member>
        <member name="M:CbcModel.setMaximumCutPasses(System.Int32)">
Set the maximum number of cut passes at other nodes (default 10)
        Minimum drop can also be used for fine tuning 
</member>
        <member name="M:CbcModel.getMaximumCutPassesAtRoot">
Get the maximum number of cut passes at root node 
</member>
        <member name="M:CbcModel.setMaximumCutPassesAtRoot(System.Int32)">
Set the maximum number of cut passes at root node (default 20)
        Minimum drop can also be used for fine tuning 
</member>
        <member name="M:CbcModel.getMinimumDrop">
Get the minimum drop to continue cuts
</member>
        <member name="M:CbcModel.setMinimumDrop(System.Double)">
Set the minimum drop to continue cuts
</member>
        <member name="M:CbcModel.canStopOnGap">
See if can stop on gap
</member>
        <member name="M:CbcModel.getCutoffIncrement">
Get the
        \link CbcModel::CbcCutoffIncrement  \endlink
        desired.

</member>
        <member name="M:CbcModel.setCutoffIncrement(System.Double)">
Set the
        \link CbcModel::CbcCutoffIncrement  \endlink
        desired.

</member>
        <member name="M:CbcModel.getHeuristicFractionGap">
Get the \link CbcModel::CbcHeuristicFractionGap fraction heuristic gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.setHeuristicFractionGap(System.Double)">
Set the \link CbcModel::CbcHeuristicFractionGap fraction heuristic gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.getHeuristicGap">
Get the \link CbcModel::CbcHeuristicGap heuristic gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.setHeuristicGap(System.Double)">
Set the \link CbcModel::CbcHeuristicGap heuristic gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.getAllowablePercentageGap">
Get the \link CbcModel::CbcAllowableFractionGap percentage allowable gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.setAllowablePercentageGap(System.Double)">
Set the \link CbcModel::CbcAllowableFractionGap percentage allowable gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.getAllowableFractionGap">
Get the \link CbcModel::CbcAllowableFractionGap fraction allowable gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.setAllowableFractionGap(System.Double)">
Set the \link CbcModel::CbcAllowableFractionGap fraction allowable gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.getAllowableGap">
Get the \link CbcModel::CbcAllowableGap allowable gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.setAllowableGap(System.Double)">
Set the \link CbcModel::CbcAllowableGap allowable gap \endlink
        between the best known solution and the best possible solution.

</member>
        <member name="M:CbcModel.getInfeasibilityWeight">
Get the
        \link CbcModel::CbcInfeasibilityWeight
          weight per integer infeasibility \endlink

</member>
        <member name="M:CbcModel.setInfeasibilityWeight(System.Double)">
Set the
        \link CbcModel::CbcInfeasibilityWeight
          weight per integer infeasibility \endlink

</member>
        <member name="M:CbcModel.getIntegerTolerance">
Get the
      \link CbcModel::CbcIntegerTolerance integrality tolerance \endlink

</member>
        <member name="M:CbcModel.setIntegerTolerance(System.Double)">
Set the
      \link CbcModel::CbcIntegerTolerance integrality tolerance \endlink

</member>
        <member name="M:CbcModel.maximumSecondsReached">
Return true if maximum time reached
</member>
        <member name="M:CbcModel.getCurrentSeconds">
Current time since start of branchAndbound
</member>
        <member name="M:CbcModel.getMaximumSeconds">
Get the
        \link CbcModel::CbcMaximumSeconds maximum number of seconds \endlink
        desired.

</member>
        <member name="M:CbcModel.setMaximumSeconds(System.Double)">
Set the
        \link CbcModel::CbcMaximumSeconds maximum number of seconds \endlink
        desired.

</member>
        <member name="M:CbcModel.getPrintingMode">
Get the printing mode
</member>
        <member name="M:CbcModel.setPrintingMode(System.Int32)">
Set the printing mode
</member>
        <member name="M:CbcModel.getMaximumSolutions">
Get the
        \link CbcModel::CbcMaxNumSol maximum number of solutions \endlink
        desired.

</member>
        <member name="M:CbcModel.setMaximumSolutions(System.Int32)">
Set the
        \link CbcModel::CbcMaxNumSol maximum number of solutions \endlink
        desired.

</member>
        <member name="M:CbcModel.getMaximumNodes">
Get the \link CbcModel::CbcMaxNumNode maximum node limit \endlink
</member>
        <member name="M:CbcModel.setMaximumNodes(System.Int32)">
Set the \link CbcModel::CbcMaxNumNode maximum node limit \endlink
</member>
        <member name="M:CbcModel.getCutoff">
Get the cutoff bound on the objective function - always as minimize
</member>
        <member name="M:CbcModel.getDblParam(CbcModel.CbcDblParam)">
Get a double parameter
</member>
        <member name="M:CbcModel.getIntParam(CbcModel.CbcIntParam)">
Get an integer parameter
</member>
        <member name="M:CbcModel.setDblParam(CbcModel.CbcDblParam,System.Double)">
Set a double parameter
</member>
        <member name="M:CbcModel.setIntParam(CbcModel.CbcIntParam,System.Int32)">
@name Parameter set/get methods

       The set methods return true if the parameter was set to the given value,
       false if the value of the parameter is out of range.

       The get methods return the value of the parameter.


Set an integer parameter
</member>
        <member name="M:CbcModel.addSOSEtcToSolver">
Add SOS info to solver -
	Overwrites SOS information in solver with information
	in CbcModel.  Has no effect with some solvers. 
	Also updates integer info. 
</member>
        <member name="M:CbcModel.findIntegers(System.Boolean,System.Int32)">
\brief Identify integer variables and create corresponding objects.

      Record integer variables and create an CbcSimpleInteger object for each
      one.
      If \p startAgain is true, a new scan is forced, overwriting any existing
      integer variable information.
      If type &gt; 0 then 1==PseudoCost, 2 new ones low priority

</member>
        <member name="M:CbcModel.synchronizeModel">
Ensure attached objects point to this model.
</member>
        <member name="M:CbcModel.addObjects(System.Int32,CbcObject**)">
Add in object information.

      Objects are cloned; the owner can delete the originals.

</member>
        <member name="M:CbcModel.addObjects(System.Int32,OsiObject**)">
Add in object information.

      Objects are cloned; the owner can delete the originals.

</member>
        <member name="M:CbcModel.deleteObjects(System.Boolean)">
Delete all object information (and just back to integers if true)
</member>
        <member name="M:CbcModel.modifiableObject(System.Int32)">
Get the specified object
</member>
        <member name="M:CbcModel.object(System.Int32)">
Get the specified object
</member>
        <member name="M:CbcModel.objects">
Get the array of objects
</member>
        <member name="M:CbcModel.setNumberObjects(System.Int32)">
Set the number of objects
</member>
        <member name="M:CbcModel.numberObjects">
\name Object manipulation routines

      See OsiObject for an explanation of `object' in the context of CbcModel.

Get the number of objects
</member>
        <member name="M:CbcModel.setupCleanVariables">
Sets up cleanVariables array (i.e. ones to be careful about)
</member>
        <member name="M:CbcModel.cleanBounds(OsiSolverInterface*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Clean model i.e. make SOS/integer variables exactly at bound if needed.
Only if moreSpecialOptions2_ 15 bit set (32768) as there is a small 
overhead (more2 in standalone cbc).
Fine tuning can be done in configure with -DCLEAN_INTEGER_VARIABLES
and -DZERO_ODD_TOLERANCE=1.0e-nn
If CLEAN_INTEGER_VARIABLES not defined then cleaning is only done for 
SOS variables.
If ZERO_ODD_TOLERANCE not defined then 1.0e-14 used.  You can define as 
0.0 if you are paranoid. 
Returns number of variables forced out
cleanVariables array will be used if exists

</member>
        <member name="M:CbcModel.flipModel">
Flip direction of optimization on all models

</member>
        <member name="M:CbcModel.saveModel(OsiSolverInterface*,System.Double*,System.Boolean*)">
Save copy of the model.

</member>
        <member name="M:CbcModel.AddIntegers">
Add additional integers.

</member>
        <member name="M:CbcModel.postProcessedSolver(System.Int32)">
Returns postProcessed solution in solver(called from event handler)
     Normally used for integer solution (not really tested otherwise)
    solutionType 1 is best integer so far, 0 is current solution 
    (may not be integer) 
</member>
        <member name="M:CbcModel.analyzeObjective">
Analyze problem to find a minimum change in the objective function.

</member>
        <member name="M:CbcModel.tightenVubs(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double)">
\brief For variables involved in VUB constraints, see if we can tighten
           bounds by solving lp's

      This version is just handed a list of variables to be processed.

</member>
        <member name="M:CbcModel.originalModel(CbcModel*,System.Boolean)">
Put back information into the original model after integer presolve.
</member>
        <member name="M:CbcModel.integerPresolveThisModel(OsiSolverInterface*,System.Boolean)">
Do integer presolve, modifying the current model.

        Returns true if the model remains feasible after presolve.

</member>
        <member name="M:CbcModel.integerPresolve(System.Boolean)">
Do integer presolve, creating a new (presolved) model.

      Returns the new model, or NULL if feasibility is lost.
      If weak is true then just does a normal presolve

      \todo It remains to work out the cleanest way of getting a solution to
            the original problem at the end. So this is very preliminary.

</member>
        <member name="M:CbcModel.findCliques(System.Boolean,System.Int32,System.Int32,System.Int32)">
\name Presolve methods 
Identify cliques and construct corresponding objects.

        Find cliques with size in the range
        [\p atLeastThisMany, \p lessThanThis] and construct corresponding
        CbcClique objects.
        If \p makeEquality is true then a new model may be returned if
        modifications had to be made, otherwise \c this is returned.
        If the problem is infeasible #numberObjects_ is set to -1.
        A client must use deleteObjects() before a second call to findCliques().
        If priorities exist, clique priority is set to the default.

</member>
        <member name="M:CbcModel.whichGenerator">
Which cut generator generated this cut
</member>
        <member name="M:CbcModel.makeGlobalCuts">
Make partial cuts into global cuts
</member>
        <member name="M:CbcModel.makePartialCut(OsiRowCut!System.Runtime.CompilerServices.IsConst*,OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Make partial cut into a global cut and save
</member>
        <member name="M:CbcModel.makeGlobalCut(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Make given column cut into a global cut
</member>
        <member name="M:CbcModel.makeGlobalCut(OsiColCut!System.Runtime.CompilerServices.IsConst*)">
Make given column cut into a global cut
</member>
        <member name="M:CbcModel.makeGlobalCut(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Make given cut into a global cut
</member>
        <member name="M:CbcModel.makeGlobalCut(OsiRowCut!System.Runtime.CompilerServices.IsConst*)">
Make given cut into a global cut
</member>
        <member name="M:CbcModel.makeGlobalCuts(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Make given rows (L or G) into global cuts and remove from lp
</member>
        <member name="M:CbcModel.resolve(CbcNodeInfo*,System.Int32,System.Double*,System.Double*,System.Double*)">
\brief Reoptimise an LP relaxation

      Invoke the solver's %resolve() method.
      whereFrom -
      0 - initial continuous
      1 - resolve on branch (before new cuts)
      2 - after new cuts
      3  - obsolete code or something modified problem in unexpected way
      10 - after strong branching has fixed variables at root
      11 - after strong branching has fixed variables in tree

      returns 1 feasible, 0 infeasible, -1 feasible but skip cuts

</member>
        <member name="M:CbcModel.doOneNode(CbcModel*,CbcNode**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcNode**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Do one node - broken out for clarity?
        also for parallel (when baseModel!=this)
        Returns 1 if solution found
        node NULL on return if no branches left
        newNode NULL if no new node created

</member>
        <member name="M:CbcModel.addUpdateInformation(CbcObjectUpdateData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Adds an update information object
</member>
        <member name="M:CbcModel.setPreProcess(CglPreProcess*)">
Set CglPreProcess used before branch and bound
</member>
        <member name="M:CbcModel.preProcess">
Returns CglPreProcess used before branch and bound
</member>
        <member name="M:CbcModel.resizeWhichGenerator(System.Int32,System.Int32)">
Update size of whichGenerator
</member>
        <member name="M:CbcModel.solveOneNode(System.Int32,CbcNode*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Input one node output N nodes to put on tree and optional solution update
        This should be able to operate in parallel so is given a solver and is const(ish)
        However we will need to keep an array of solver_ and bases and more
        status is 0 for normal, 1 if solution
        Calling code should always push nodes back on tree

</member>
        <member name="M:CbcModel.parallelCuts(CbcBaseModel*,OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcNode*,OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Generate one round of cuts - parallel mode
        returns -
        0 - normal
        1 - must keep going
        2 - set numberTries to zero
        -1 - infeasible

</member>
        <member name="M:CbcModel.serialCuts(OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcNode*,OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Generate one round of cuts - serial mode
      returns -
      0 - normal
      1 - must keep going
      2 - set numberTries to zero
      -1 - infeasible

</member>
        <member name="M:CbcModel.solveWithCuts(OsiCuts*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,CbcNode*)">
\brief Evaluate a subproblem using cutting planes and heuristics

      The method invokes a main loop which generates cuts, applies heuristics,
      and reoptimises using the solver's native %resolve() method.
      It returns true if the subproblem remains feasible at the end of the
      evaluation.

</member>
        <member name="M:CbcModel.initialSolve">
@name Solve methods
\brief Solve the initial LP relaxation

      Invoke the solver's %initialSolve() method.

</member>
        <member name="F:CbcLastDblParam">
Just a marker, so that a static sized array can store parameters. 
</member>
        <member name="F:CbcSmallChange">
Small non-zero change on a branch to be used as guess
</member>
        <member name="F:CbcLargestChange">
Largest non-zero change on a branch
</member>
        <member name="F:CbcSumChange">
Sum of non-zero changes on a branch
</member>
        <member name="F:CbcSmallestChange">
Smallest non-zero change on a branch
</member>
        <member name="F:CbcHeuristicFractionGap">
Stop doing heuristics when the gap between the objective value of the
            best known solution and the best bound on the objective of any solution
            is less than this fraction of of the absolute value of best known
            solution.

          Code stops if either this test or CbcAllowableGap test succeeds

</member>
        <member name="F:CbcHeuristicGap">
Stop doing heuristics when the gap between the objective value of the
            best known solution and the best bound on the objective of any solution
            is less than this.

          This is an absolute value. Conversion from a percentage is left to the
          client.

</member>
        <member name="F:CbcStartSeconds">
\brief The time at start of model.
               So that other pieces of code can access 
</member>
        <member name="F:CbcCurrentMinimizationObjectiveValue">
Current minimization objective value
</member>
        <member name="F:CbcCurrentObjectiveValue">
Current objective value
</member>
        <member name="F:CbcOptimizationDirection">
Optimization direction - stored for speed
</member>
        <member name="F:CbcCurrentCutoff">
Cutoff - stored for speed
</member>
        <member name="F:CbcMaximumSeconds">
\brief The maximum number of seconds before terminating.
               A double should be adequate! 
</member>
        <member name="F:CbcAllowableFractionGap">
Stop when the gap between the objective value of the best known solution
          and the best bound on the objective of any solution is less than this
          fraction of of the absolute value of best known solution.

          Code stops if either this test or CbcAllowableGap test succeeds

</member>
        <member name="F:CbcAllowableGap">
Stop when the gap between the objective value of the best known solution
          and the best bound on the objective of any solution is less than this.

          This is an absolute value. Conversion from a percentage is left to the
          client.

</member>
        <member name="F:CbcCutoffIncrement">
The amount by which to tighten the objective function cutoff when
            a new solution is discovered. 
</member>
        <member name="F:CbcInfeasibilityWeight">
The objective is assumed to worsen by this amount for each
            integer infeasibility. 
</member>
        <member name="F:CbcIntegerTolerance">
The maximum amount the value of an integer variable can vary from
            integer and still be considered feasible. 
</member>
        <member name="F:CbcLastIntParam">
Just a marker, so that a static sized array can store parameters. 
</member>
        <member name="F:CbcNumberBranches">
Number of branches (may be more than number of nodes as may
            include strong branching) 
</member>
        <member name="F:CbcPrinting">
Adjusts printout
            1 does different node message with number unsatisfied on last branch

</member>
        <member name="F:CbcFathomDiscipline">
Fathoming discipline

          Controls objective function comparisons for purposes of fathoming by bound
          or determining monotonic variables.

          If 1, action is taken only when the current objective is strictly worse
          than the target. Implementation is handled by adding a small tolerance to
          the target.

</member>
        <member name="F:CbcMaxNumSol">
The maximum number of solutions before terminating 
</member>
        <member name="F:CbcMaxNumNode">
The maximum number of nodes before terminating 
</member>
        <member name="F:ClpDualRowPivot.type_">
Type of row pivot algorithm
</member>
        <member name="F:ClpDualRowPivot.model_">
@name Protected member data
Pointer to model
</member>
        <member name="M:ClpDualRowPivot.type">
Returns type (above 63 is extra information)
</member>
        <member name="M:ClpDualRowPivot.setModel(ClpSimplex*)">
Sets model (normally to NULL)
</member>
        <member name="M:ClpDualRowPivot.model">
@name Other
Returns model
</member>
        <member name="M:ClpDualRowPivot.clone(System.Boolean)">
Clone
</member>
        <member name="M:ClpDualRowPivot.Dispose">
Destructor
</member>
        <member name="M:ClpDualRowPivot.op_Assign(ClpDualRowPivot!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:ClpDualRowPivot.#ctor(ClpDualRowPivot!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:ClpDualRowPivot.#ctor">
@name Constructors and destructors
Default Constructor
</member>
        <member name="M:ClpDualRowPivot.maximumPivotsChanged">
Called when maximum pivots changes
</member>
        <member name="M:ClpDualRowPivot.looksOptimal">
Returns true if would not find any row
</member>
        <member name="M:ClpDualRowPivot.clearArrays">
Gets rid of all arrays (may be empty)
</member>
        <member name="M:ClpDualRowPivot.unrollWeights">
Gets rid of last update (may be empty)
</member>
        <member name="M:ClpDualRowPivot.checkAccuracy">
checks accuracy and may re-initialize (may be empty)
</member>
        <member name="M:ClpDualRowPivot.saveWeights(ClpSimplex*,System.Int32)">
Saves any weights round factorization as pivot rows may change
         Will be empty unless steepest edge (will save model)
         May also recompute infeasibility stuff
         1) before factorization
         2) after good factorization (if weights empty may initialize)
         3) after something happened but no factorization
            (e.g. check for infeasible)
         4) as 2 but restore weights from previous snapshot
         5) for strong branching - initialize to 1 , infeasibilities
	 6) scale back
         7) for strong branching - initialize full weights , infeasibilities

</member>
        <member name="M:ClpDualRowPivot.updatePrimalSolution(CoinIndexedVector*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Updates primal solution (and maybe list of candidates)
         Uses input vector which it deletes
         Computes change in objective function
         Would be faster if we kept basic regions, but on other hand it
         means everything is always in sync

</member>
        <member name="M:ClpDualRowPivot.updateWeights(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Updates weights and returns pivot alpha.
         Also does FT update 
</member>
        <member name="M:ClpDualRowPivot.pivotRow">
@name Algorithmic methods
Returns pivot row, -1 if none
</member>
        <member name="T:ClpDualRowPivot">
Dual Row Pivot Abstract Base Class

Abstract Base Class for describing an interface to an algorithm
to choose row pivot in dual simplex algorithm.  For some algorithms
e.g. Dantzig choice then some functions may be null.


</member>
        <member name="M:CbcMessage.#ctor(CoinMessages.Language)">
@name Constructors etc 
Constructor 
</member>
        <member name="T:CBC_Message">
This deals with Cbc messages (as against Clp messages etc).
    CoinMessageHandler.hpp is the general part of message handling.
    All it has are enum's for the various messages.
    CbcMessage.cpp has text in various languages.

    It is trivial to use the .hpp and .cpp file as a basis for
    messages for other components.

</member>
        <member name="F:CbcRowCuts.hash_">
Hash table
</member>
        <member name="F:CbcCountRowCut.whichCutGenerator_">
Which generator created this cut 
	(add 10000 if globally valid)
	if -1 then from global cut pool
	-2 cut branch
        -3 unknown

</member>
        <member name="F:CbcCountRowCut.numberPointingToThis_">
Number of other CbcNodeInfo objects pointing to this cut
</member>
        <member name="F:CbcCountRowCut.ownerCut_">
Index of cut in owner's cut set
(\link CbcNodeInfo::cuts_ cuts_ \endlink).
</member>
        <member name="F:CbcCountRowCut.owner_">
Backward pointer to owning CbcNodeInfo
</member>
        <member name="M:CbcCountRowCut.op_Assign(CbcCountRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Standard assignment is illegal (reference counts would be incorrect)
</member>
        <member name="M:CbcCountRowCut.#ctor(CbcCountRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Standard copy is illegal (reference counts would be incorrect)
</member>
        <member name="M:CbcCountRowCut.canDropCut(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Returns true if can drop cut if slack basic
</member>
        <member name="M:CbcCountRowCut.whichCutGenerator">
Which generator for cuts - as user order
</member>
        <member name="M:CbcCountRowCut.numberPointingToThis">
Number of other CbcNodeInfo objects pointing to this row cut
</member>
        <member name="M:CbcCountRowCut.setInfo(CbcNodeInfo*,System.Int32)">
\brief Set the information associating this cut with a node

      An CbcNodeInfo object and an index in the cut set of the node.
      For locally valid cuts, the node will be the  search tree node where the
      cut was generated. For globally valid cuts, it's the node where the cut
      was activated.

</member>
        <member name="M:CbcCountRowCut.decrement(System.Int32)">
Decrement the number of references and return the number left.
</member>
        <member name="M:CbcCountRowCut.increment(System.Int32)">
Increment the number of references
</member>
        <member name="M:CbcCountRowCut.Dispose">
Destructor

      \note The destructor will reach out (via #owner_) and NULL the
      reference to the cut in the owner's
      \link CbcNodeInfo::cuts_ cuts_ \endlink list.

</member>
        <member name="M:CbcCountRowCut.#ctor(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcNodeInfo*,System.Int32,System.Int32,System.Int32)">
`Copy' constructor using an OsiRowCut and an CbcNodeInfo
</member>
        <member name="M:CbcCountRowCut.#ctor(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
`Copy' constructor using an OsiRowCut
</member>
        <member name="M:CbcCompareBase.sayThreaded">
Say threaded
</member>
        <member name="M:CbcCompareBase.equalityTest(CbcNode*,CbcNode*)">
Further test if everything else equal
</member>
        <member name="M:CbcCompareBase.alternateTest(CbcNode*,CbcNode*)">
This is alternate test function
</member>
        <member name="M:CbcCompareBase.test(CbcNode*,CbcNode*)">
This is test function
</member>
        <member name="M:CbcCompareBase.clone">
Clone
</member>
        <member name="M:CbcCompareBase.generateCpp(_iobuf*)">
Create C++ lines to get to current state
</member>
        <member name="M:CbcCompareBase.fullScan">
Returns true if wants code to do scan with alternate criterion
        NOTE - this is temporarily disabled

</member>
        <member name="F:CbcNode.state_">
State
        1 - on tree
        2 - active

</member>
        <member name="F:CbcNode.nodeNumber_">
The node number
</member>
        <member name="F:CbcNode.numberUnsatisfied_">
The number of objects unsatisfied at this node.
</member>
        <member name="F:CbcNode.depth_">
Depth of the node in the search tree
</member>
        <member name="F:CbcNode.branch_">
Branching object for this node
</member>
        <member name="F:CbcNode.sumInfeasibilities_">
Sum of "infeasibilities" reported by each object
</member>
        <member name="F:CbcNode.guessedObjectiveValue_">
Guessed satisfied Objective value
</member>
        <member name="F:CbcNode.objectiveValue_">
Objective value
</member>
        <member name="F:CbcNode.nodeInfo_">
Information to make basis and bounds
</member>
        <member name="M:CbcNode.checkInfo">
Debug
</member>
        <member name="M:CbcNode.print">
Print
</member>
        <member name="M:CbcNode.setState(System.Int32)">
Set state (really for debug)
</member>
        <member name="M:CbcNode.getState">
Get state (really for debug)
</member>
        <member name="M:CbcNode.setActive(System.Boolean)">
Sets true if active
</member>
        <member name="M:CbcNode.active">
Returns true if active
</member>
        <member name="M:CbcNode.setOnTree(System.Boolean)">
Sets true if on tree
</member>
        <member name="M:CbcNode.onTree">
Returns true if on tree
</member>
        <member name="M:CbcNode.nodeNumber">
The node number
</member>
        <member name="M:CbcNode.setBranchingObject(OsiBranchingObject*)">
Set branching object for this node (takes ownership)
</member>
        <member name="M:CbcNode.modifiableBranchingObject">
Modifiable branching object for this node
</member>
        <member name="M:CbcNode.branchingObject">
Branching object for this node
</member>
        <member name="M:CbcNode.setSumInfeasibilities(System.Double)">
Set sum of "infeasibilities" reported by each object
</member>
        <member name="M:CbcNode.sumInfeasibilities">
Get sum of "infeasibilities" reported by each object
</member>
        <member name="M:CbcNode.setNumberUnsatisfied(System.Int32)">
Set the number of objects unsatisfied at this node.
</member>
        <member name="M:CbcNode.numberUnsatisfied">
Get the number of objects unsatisfied at this node.
</member>
        <member name="M:CbcNode.setDepth(System.Int32)">
Set depth in branch-and-cut search tree
</member>
        <member name="M:CbcNode.depth">
Depth in branch-and-cut search tree
</member>
        <member name="M:CbcNode.numberBranches">
Number of arms defined for the attached OsiBranchingObject.
</member>
        <member name="M:CbcNode.checkIsCutoff(System.Double)">
Double checks in case node can change its mind!
        Returns objective value
        Can change objective etc 
</member>
        <member name="M:CbcNode.branch(OsiSolverInterface*)">
Does next branch and updates state
</member>
        <member name="M:CbcNode.initializeInfo">
Initialize reference counts in attached CbcNodeInfo

      This is a convenience routine, which will initialize the reference counts
      in the attached CbcNodeInfo object based on the attached
      OsiBranchingObject.

      \sa CbcNodeInfo::initializeInfo(int).

</member>
        <member name="M:CbcNode.nullNodeInfo">
Nulls out node info
</member>
        <member name="M:CbcNode.decrementParentCuts(CbcModel*,System.Int32)">
Decrement all active cut counts in chain starting at parent
</member>
        <member name="M:CbcNode.decrementCuts(System.Int32)">
Decrement active cut counts
</member>
        <member name="M:CbcNode.Dispose">
Destructor
</member>
        <member name="M:CbcNode.op_Assign(CbcNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcNode.#ctor(CbcNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcNode.#ctor(CbcModel*,CbcNode*)">
Construct and increment parent reference count
</member>
        <member name="M:CbcNode.#ctor">
Default Constructor
</member>
        <member name="T:CbcNode">
Information required while the node is live

  When a subproblem is initially created, it is represented by an CbcNode
  object and an attached CbcNodeInfo object.

  The CbcNode contains information (depth, branching instructions), that's
  needed while the subproblem remains `live', <i>i.e.</i>, while the
  subproblem is not fathomed and there are branch arms still be be
  evaluated.  The CbcNode is deleted when the last branch arm has been
  evaluated.

  The CbcNodeInfo object contains the information needed to maintain the
  search tree and recreate the subproblem for the node. It remains in
  existence until there are no nodes remaining in the subtree rooted at this
  node.

</member>
        <member name="M:CbcPartialNodeInfo.op_Assign(CbcPartialNodeInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="F:CbcPartialNodeInfo.numberChangedBounds_">
Number of bound changes
</member>
        <member name="F:CbcPartialNodeInfo.variables_">
Which variable (top bit if upper bound changing)
</member>
        <member name="F:CbcPartialNodeInfo.basisDiff_">
Basis diff information
</member>
        <member name="M:CbcPartialNodeInfo.numberChangedBounds">
Number of bound changes
</member>
        <member name="M:CbcPartialNodeInfo.variables">
Which variable (top bit if upper bound changing)
</member>
        <member name="M:CbcPartialNodeInfo.basisDiff">
Basis diff information
</member>
        <member name="M:CbcPartialNodeInfo.clone">
Clone
</member>
        <member name="M:CbcPartialNodeInfo.buildRowBasis(CoinWarmStartBasis*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Builds up row basis backwards (until original model).
        Returns NULL or previous one to apply .
        Depends on Free being 0 and impossible for cuts

</member>
        <member name="M:CbcPartialNodeInfo.applyBounds(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Just apply bounds to one variable - force means overwrite by lower,upper (1=&gt;infeasible)
</member>
        <member name="M:CbcPartialNodeInfo.applyToModel(CbcModel*,CoinWarmStartBasis**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcCountRowCut**,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Modify model according to information at node

        The routine modifies the model according to bound and basis change
        information at node and adds any cuts to the addCuts array.

</member>
        <member name="T:CbcPartialNodeInfo">
\brief Holds information for recreating a subproblem by incremental change
	   from the parent.

  A CbcPartialNodeInfo object contains changes to the bounds and basis, and
  additional cuts, required to recreate a subproblem by modifying and
  augmenting the parent subproblem.

</member>
        <member name="M:CbcFullNodeInfo.op_Assign(CbcFullNodeInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="F:CbcFullNodeInfo.basis_">
Full basis

      This MUST BE A POINTER to avoid cutting extra information in derived
      warm start classes.

</member>
        <member name="M:CbcFullNodeInfo.mutableUpper">
Mutable upper bounds
</member>
        <member name="M:CbcFullNodeInfo.setColUpper(System.Int32,System.Double)">
Set a bound
</member>
        <member name="M:CbcFullNodeInfo.upper">
Upper bounds
</member>
        <member name="M:CbcFullNodeInfo.mutableLower">
Mutable lower bounds
</member>
        <member name="M:CbcFullNodeInfo.setColLower(System.Int32,System.Double)">
Set a bound
</member>
        <member name="M:CbcFullNodeInfo.lower">
Lower bounds
</member>
        <member name="M:CbcFullNodeInfo.clone">
Clone
</member>
        <member name="M:CbcFullNodeInfo.#ctor(CbcModel*,System.Int32)">
Constructor from continuous or satisfied

</member>
        <member name="M:CbcFullNodeInfo.buildRowBasis(CoinWarmStartBasis*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Builds up row basis backwards (until original model).
        Returns NULL or previous one to apply .
        Depends on Free being 0 and impossible for cuts

</member>
        <member name="M:CbcFullNodeInfo.applyBounds(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Just apply bounds to one variable - force means overwrite by lower,upper (1=&gt;infeasible)
</member>
        <member name="M:CbcFullNodeInfo.applyToModel(CbcModel*,CoinWarmStartBasis**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcCountRowCut**,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Modify model according to information at node

        The routine modifies the model according to bound information at node,
        creates a new basis according to information at node, but with the size
        passed in through basis, and adds any cuts to the addCuts array.

      \note The basis passed in via basis is solely a vehicle for passing in
        the desired basis size. It will be deleted and a new basis returned.

</member>
        <member name="M:CbcNodeInfo.setParentBasedData">
routine common to constructors
</member>
        <member name="M:CbcNodeInfo.op_Assign(CbcNodeInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Illegal Assignment operator
</member>
        <member name="F:CbcNodeInfo.active_">
Active node information.
        1 - bounds
        2 - cuts
        4 - basis!

</member>
        <member name="F:CbcNodeInfo.numberBranchesLeft_">
Number of branch arms left to explore at this node

      \todo There seems to be redundancy between this field and
        CbcBranchingObject::numberBranchesLeft_. It'd be good to sort out if
        both are necessary.

</member>
        <member name="F:CbcNodeInfo.numberRows_">
Number of rows in problem (before these cuts).  This
        means that for top of chain it must be rows at continuous 
</member>
        <member name="F:CbcNodeInfo.cuts_">
Array of pointers to cuts
</member>
        <member name="F:CbcNodeInfo.nodeNumber_">
The node number
</member>
        <member name="F:CbcNodeInfo.numberCuts_">
Number of row cuts (this node)
</member>
        <member name="F:CbcNodeInfo.owner_">
Owner
</member>
        <member name="F:CbcNodeInfo.parentBranch_">
Copy of the branching object of the parent when the node is created
</member>
        <member name="F:CbcNodeInfo.parent_">
parent
</member>
        <member name="F:CbcNodeInfo.numberPointingToThis_">
Number of other nodes pointing to this node.

      Number of existing and potential search tree nodes pointing to this node.
      `Existing' means referenced by #parent_ of some other CbcNodeInfo.
      `Potential' means children still to be created (#numberBranchesLeft_ of
      this CbcNodeInfo).

</member>
        <member name="M:CbcNodeInfo.unsetParentBasedData">
If we need to take off parent based data
</member>
        <member name="M:CbcNodeInfo.parentBranch">
Branching object for the parent
</member>
        <member name="M:CbcNodeInfo.setSymmetryWorked">
Say symmetry worked at this node)
</member>
        <member name="M:CbcNodeInfo.symmetryWorked">
Get symmetry value (true worked at this node)
</member>
        <member name="M:CbcNodeInfo.unmark">
Unmark
</member>
        <member name="M:CbcNodeInfo.mark">
Mark
</member>
        <member name="M:CbcNodeInfo.marked">
Say if marked
</member>
        <member name="M:CbcNodeInfo.allActivated">
Say if normal
</member>
        <member name="M:CbcNodeInfo.deactivate(System.Int32)">
Deactivate node information.
        1 - bounds
        2 - cuts
        4 - basis!
	8 - just marked
	16 - symmetry branching worked

</member>
        <member name="M:CbcNodeInfo.nodeNumber">
The node number
</member>
        <member name="M:CbcNodeInfo.nullOwner">
Set owner null
</member>
        <member name="M:CbcNodeInfo.numberCuts">
Number of row cuts (this node)
</member>
        <member name="M:CbcNodeInfo.cuts">
Array of pointers to cuts
</member>
        <member name="M:CbcNodeInfo.incrementParentCuts(CbcModel*,System.Int32)">
Increment all active cut counts in parent chain
</member>
        <member name="M:CbcNodeInfo.decrementParentCuts(CbcModel*,System.Int32)">
Decrement all active cut counts in chain starting at parent
</member>
        <member name="M:CbcNodeInfo.incrementCuts(System.Int32)">
Increment active cut counts
</member>
        <member name="M:CbcNodeInfo.decrementCuts(System.Int32)">
Decrement active cut counts
</member>
        <member name="M:CbcNodeInfo.deleteCut(System.Int32)">
Really delete a cut
</member>
        <member name="M:CbcNodeInfo.deleteCuts(System.Int32,CbcCountRowCut**)">
Delete cuts (decrements counts)
        Slow unless cuts in same order as saved

</member>
        <member name="M:CbcNodeInfo.nullParent">
Set parent null
</member>
        <member name="M:CbcNodeInfo.parent">
Parent of this
</member>
        <member name="M:CbcNodeInfo.throwAway">
Say thrown away
</member>
        <member name="M:CbcNodeInfo.branchedOn">
Say one branch taken
</member>
        <member name="M:CbcNodeInfo.incrementNumberPointingToThis">
Increment number of objects pointing to this
</member>
        <member name="M:CbcNodeInfo.setNumberPointingToThis(System.Int32)">
Set number of objects pointing to this
</member>
        <member name="M:CbcNodeInfo.numberPointingToThis">
Return number of objects pointing to this
</member>
        <member name="M:CbcNodeInfo.setNumberBranchesLeft(System.Int32)">
Set number of branches left in object
</member>
        <member name="M:CbcNodeInfo.numberBranchesLeft">
Return number of branches left in object
</member>
        <member name="M:CbcNodeInfo.initializeInfo(System.Int32)">
Initialize reference counts

      Initialize the reference counts used for tree maintenance.

</member>
        <member name="M:CbcNodeInfo.decrement(System.Int32)">
Decrement number of references and return number left
</member>
        <member name="M:CbcNodeInfo.increment(System.Int32)">
Increment number of references
</member>
        <member name="M:CbcNodeInfo.allBranchesGone">
Called when number branches left down to zero
</member>
        <member name="M:CbcNodeInfo.clone">
Clone
</member>
        <member name="M:CbcNodeInfo.buildRowBasis(CoinWarmStartBasis*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Builds up row basis backwards (until original model).
        Returns NULL or previous one to apply .
        Depends on Free being 0 and impossible for cuts

</member>
        <member name="M:CbcNodeInfo.applyBounds(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Just apply bounds to one variable - force means overwrite by lower,upper (1=&gt;infeasible)
</member>
        <member name="M:CbcNodeInfo.applyToModel(CbcModel*,CoinWarmStartBasis**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CbcCountRowCut**,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Modify model according to information at node

        The routine modifies the model according to bound and basis
        information at node and adds any cuts to the addCuts array.

</member>
        <member name="M:CbcNodeInfo.Dispose">
Destructor

      Note that the destructor will recursively delete the parent if this
      nodeInfo is the last child.

</member>
        <member name="M:CbcNodeInfo.#ctor(CbcNodeInfo*,CbcNode*)">
Construct with parent and owner

      As for `construct with parent', and attached to \p owner.

</member>
        <member name="M:CbcNodeInfo.#ctor(CbcNodeInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcCompareRanges(System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare two ranges. The two bounds arrays are both of size two and
    describe closed intervals. Return the appropriate CbcRangeCompare value
    (first argument being the sub/superset if that's the case). In case of
    overlap (and if \c replaceIfOverlap is true) replace the content of thisBd
    with the intersection of the ranges.

</member>
        <member name="F:CbcObjectUpdateData.cutoff_">
Current cutoff
</member>
        <member name="F:CbcObjectUpdateData.originalObjective_">
Objective value before branching
</member>
        <member name="F:CbcObjectUpdateData.branchingValue_">
Branching value
</member>
        <member name="F:CbcObjectUpdateData.intDecrease_">
Decrease in number unsatisfied
</member>
        <member name="F:CbcObjectUpdateData.status_">
Status 0 Optimal, 1 infeasible, 2 unknown
</member>
        <member name="F:CbcObjectUpdateData.change_">
Change in objective
</member>
        <member name="F:CbcObjectUpdateData.objectNumber_">
Object number
</member>
        <member name="F:CbcObjectUpdateData.way_">
Branch as defined by instance of CbcObject
</member>
        <member name="F:CbcObjectUpdateData.object_">
data
Object
</member>
        <member name="M:CbcObjectUpdateData.Dispose">
Destructor
</member>
        <member name="M:CbcObjectUpdateData.op_Assign(CbcObjectUpdateData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcObjectUpdateData.#ctor(CbcObjectUpdateData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcObjectUpdateData.#ctor(CbcObject*,System.Int32,System.Double,System.Int32,System.Int32,System.Double)">
Useful constructor
</member>
        <member name="M:CbcObjectUpdateData.#ctor">
Default Constructor
</member>
        <member name="M:CbcConsequence.applyToSolver(OsiSolverInterface*,System.Int32)">
Apply to an LP solver.  Action depends on state

</member>
        <member name="M:CbcConsequence.Dispose">
Destructor
</member>
        <member name="M:CbcConsequence.clone">
Clone
</member>
        <member name="T:CbcConsequence">
Abstract base class for consequent bounds.
    When a variable is branched on it normally interacts with other variables by
    means of equations.  There are cases where we want to step outside LP and do something
    more directly e.g. fix bounds.  This class is for that.

    At present it need not be virtual as only instance is CbcFixVariable, but ...


</member>
        <member name="M:CbcBranchDecision.op_Assign(CbcBranchDecision!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment is illegal
</member>
        <member name="F:CbcBranchDecision.model_">
Pointer to model
</member>
        <member name="M:CbcBranchDecision.setChooseMethod(OsiChooseVariable!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set (clone) chooseMethod
</member>
        <member name="M:CbcBranchDecision.cbcModel">
Model
</member>
        <member name="M:CbcBranchDecision.generateCpp(_iobuf*)">
Create C++ lines to get to current state
</member>
        <member name="M:CbcBranchDecision.setBestCriterion(System.Double)">
Sets or gets best criterion so far 
</member>
        <member name="M:CbcBranchDecision.updateInformation(OsiSolverInterface*,CbcNode!System.Runtime.CompilerServices.IsConst*)">
Pass in information on branch just done.
        assumes object can get information from solver 
</member>
        <member name="M:CbcBranchDecision.saveBranchingObject(OsiBranchingObject*)">
Saves a clone of current branching object.  Can be used to update
        information on object causing branch - after branch 
</member>
        <member name="M:CbcBranchDecision.whichMethod">
Says whether this method can handle both methods -
        1 better, 2 best, 3 both 
</member>
        <member name="M:CbcBranchDecision.bestBranch(CbcBranchingObject**,System.Int32,System.Int32,System.Double*,System.Int32*,System.Double*,System.Int32*,System.Double)">
\brief Compare N branching objects. Return index of best
        and sets way of branching in chosen object.

      Either this or betterBranch is used depending which user wants.

</member>
        <member name="M:CbcBranchDecision.betterBranch(CbcBranchingObject*,CbcBranchingObject*,System.Double,System.Int32,System.Double,System.Int32)">
\brief Compare two branching objects. Return nonzero if branching
           using \p thisOne is better than branching using \p bestSoFar.

      If \p bestSoFar is NULL, the routine should return a nonzero value.
      This routine is used only after strong branching.
      Either this or bestBranch is used depending which user wants.


</member>
        <member name="M:CbcBranchDecision.initialize(CbcModel*)">
Initialize <i>e.g.</i> before starting to choose a branch at a node
</member>
        <member name="M:CbcBranchDecision.clone">
Clone
</member>
        <member name="M:CbcBranchDecision.Dispose">
Destructor
</member>
        <member name="M:CbcBranchDecision.#ctor">
Default Constructor
</member>
        <member name="T:CbcModel">
Abstract branching decision base class

  In the abstract, an CbcBranchDecision object is expected to be able to
  compare two possible branching choices.

  The #betterBranch() method is the crucial routine. It is expected to be able
  to compare two \link CbcBranchingObject CbcBranchingObjects \endlink.

  See CbcObject for an overview of the three classes (CbcObject,
  CbcBranchingObject, and CbcBranchDecision) which make up cbc's branching
  model.

</member>
        <member name="F:CbcBranchingObject.way_">
The state of the branching object.

      Specifies the active arm of the branching object. Coded as -1 to take
      the `down' arm, +1 for the `up' arm. `Down' and `up' are defined based on
      the natural meaning (floor and ceiling, respectively) for a simple integer.
      The precise meaning is defined in the derived class.

</member>
        <member name="F:CbcBranchingObject.variable_">
Branching variable (0 is first integer)
</member>
        <member name="F:CbcBranchingObject.originalCbcObject_">
Pointer back to object which created
</member>
        <member name="F:CbcBranchingObject.model_">
The model that owns this branching object
</member>
        <member name="M:CbcBranchingObject.compareBranchingObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Compare the \c this with \c brObj. \c this and \c brObj must be of the
        same type and must have the same original object, but they may have
        different feasible regions.
        Return the appropriate CbcRangeCompare value (first argument being the
        sub/superset if that's the case). In case of overlap (and if \c
        replaceIfOverlap is true) replace the current branching object with one
        whose feasible region is the overlap.

</member>
        <member name="M:CbcBranchingObject.compareOriginalObject(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Compare the original object of \c this with the original object of \c
        brObj. Assumes that there is an ordering of the original objects.
        This method should be invoked only if \c this and brObj are of the same
        type.
        Return negative/0/positive depending on whether \c this is
        smaller/same/larger than the argument.

</member>
        <member name="M:CbcBranchingObject.type">
Return the type (an integer identifier) of \c this.
        See definition of CbcBranchObjType above for possibilities

</member>
        <member name="M:CbcBranchingObject.setOriginalObject(CbcObject*)">
Set pointer back to object which created
</member>
        <member name="M:CbcBranchingObject.object">
Return pointer back to object which created
</member>
        <member name="M:CbcBranchingObject.model">
Return model
</member>
        <member name="M:CbcBranchingObject.setModel(CbcModel*)">
update model
</member>
        <member name="M:CbcBranchingObject.way(System.Int32)">
Set the state of the branching object.

      See #way()

</member>
        <member name="M:CbcBranchingObject.way">
Get the state of the branching object

      Returns a code indicating the active arm of the branching object.
      The precise meaning is defined in the derived class.

      \sa #way_

</member>
        <member name="M:CbcBranchingObject.variable">
\brief Index identifying the associated CbcObject within its class.

      The name is misleading, and typically the index will <i>not</i> refer
      directly to a variable.
      Rather, it identifies an CbcObject within the class of similar
      CbcObjects

      <i>E.g.</i>, for an CbcSimpleInteger, variable() is the index of the
      integer variable in the set of integer variables (<i>not</i> the index of
      the variable in the set of all variables).

</member>
        <member name="M:CbcBranchingObject.print">
\brief Print something about branch - only if log level high

</member>
        <member name="M:CbcBranchingObject.previousBranch">
Reset every information so that the branching object appears to point to
        the previous child. This method does not need to modify anything in any
        solver. 
</member>
        <member name="M:CbcBranchingObject.tighten(OsiSolverInterface*)">
Change (tighten) bounds in object to reflect bounds in solver.
	Return true if now fixed 
</member>
        <member name="M:CbcBranchingObject.fix(OsiSolverInterface*,System.Double*,System.Double*,System.Int32)">
Update bounds in solver as in 'branch' and update given bounds.
        branchState is -1 for 'down' +1 for 'up' 
</member>
        <member name="M:CbcBranchingObject.branch(OsiSolverInterface*)">
\brief Execute the actions required to branch, as specified by the
           current state of the branching object, and advance the object's
           state.  Mainly for diagnostics, whether it is true branch or
           strong branching is also passed.
           Returns change in guessed objective on next branch

</member>
        <member name="M:CbcBranchingObject.branch">
\brief Execute the actions required to branch, as specified by the
           current state of the branching object, and advance the object's
           state.  Mainly for diagnostics, whether it is true branch or
           strong branching is also passed.
           Returns change in guessed objective on next branch

</member>
        <member name="M:CbcBranchingObject.setNumberBranches(System.Int32)">
Set number of branches to do
</member>
        <member name="M:CbcBranchingObject.resetNumberBranchesLeft">
Reset number of branches left to original
</member>
        <member name="M:CbcBranchingObject.fillStrongInfo(CbcStrongInfo*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Some branchingObjects may claim to be able to skip
        strong branching.  If so they have to fill in CbcStrongInfo.
        The object mention in incoming CbcStrongInfo must match.
        Returns nonzero if skip is wanted 
</member>
        <member name="M:CbcBranchingObject.Dispose">
Destructor
</member>
        <member name="M:CbcBranchingObject.clone">
Clone
</member>
        <member name="M:CbcBranchingObject.op_Assign(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CbcBranchingObject.#ctor(CbcBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CbcBranchingObject.#ctor(CbcModel*,System.Int32,System.Int32,System.Double)">
Constructor
</member>
        <member name="M:CbcBranchingObject.#ctor">
Default Constructor
</member>
        <member name="T:CbcBranchingObject">
\brief Abstract branching object base class
    Now just difference with OsiBranchingObject

  In the abstract, an CbcBranchingObject contains instructions for how to
  branch. We want an abstract class so that we can describe how to branch on
  simple objects (<i>e.g.</i>, integers) and more exotic objects
  (<i>e.g.</i>, cliques or hyperplanes).

  The #branch() method is the crucial routine: it is expected to be able to
  step through a set of branch arms, executing the actions required to create
  each subproblem in turn. The base class is primarily virtual to allow for
  a wide range of problem modifications.

  See CbcObject for an overview of the three classes (CbcObject,
  CbcBranchingObject, and CbcBranchDecision) which make up cbc's branching
  model.

</member>
        <member name="F:CbcObject.preferredWay_">
If -1 down always chosen first, +1 up always, 0 normal
</member>
        <member name="F:CbcObject.position_">
Position in object list
</member>
        <member name="F:CbcObject.id_">
Identifier (normally column number in matrix)
</member>
        <member name="F:CbcObject.model_">
data
Model
</member>
        <member name="M:CbcObject.initializeForBranching(CbcModel*)">
Initialize for branching
</member>
        <member name="M:CbcObject.redoSequenceEtc(CbcModel*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Redoes data when sequence numbers change
</member>
        <member name="M:CbcObject.setPreferredWay(System.Int32)">
Set -1 down always chosen first, +1 up always, 0 normal
</member>
        <member name="M:CbcObject.preferredWay">
If -1 down always chosen first, +1 up always, 0 normal
</member>
        <member name="M:CbcObject.model">
Return model
</member>
        <member name="M:CbcObject.setModel(CbcModel*)">
update model
</member>
        <member name="M:CbcObject.setPosition(System.Int32)">
Set position in object_ list
</member>
        <member name="M:CbcObject.position">
Get position in object_ list
</member>
        <member name="M:CbcObject.optionalObject">
Return true if optional branching object
        i.e. code would work without it 
</member>
        <member name="M:CbcObject.setId(System.Int32)">
Set identifier (normally column number in matrix)
        but 1000000000 to 1100000000 means optional branching object
        i.e. code would work without it 
</member>
        <member name="M:CbcObject.id">
Identifier (normally column number in matrix)
</member>
        <member name="M:CbcObject.updateInformation(CbcObjectUpdateData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Update object by CbcObjectUpdateData
</member>
        <member name="M:CbcObject.createUpdateInformation(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,CbcNode!System.Runtime.CompilerServices.IsConst*,CbcBranchingObject!System.Runtime.CompilerServices.IsConst*)">
Pass in information on branch just done and create CbcObjectUpdateData instance.
        If object does not need data then backward pointer will be NULL.
        Assumes can get information from solver 
</member>
        <member name="M:CbcObject.floorCeiling(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Returns floor and ceiling i.e. closest valid points

</member>
        <member name="M:CbcObject.resetBounds(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Reset variable bounds to their original values.

      Bounds may be tightened, so it may be good to be able to set this info in object.

</member>
        <member name="M:CbcObject.notPreferredNewFeasible">
\brief Given a valid solution (with reduced costs, etc.),
        return a branching object which would give a new feasible
        point in a bad direction.

        If the method cannot generate a feasible point (because there aren't
        any, or because it isn't bright enough to find one), it should
        return null.

</member>
        <member name="M:CbcObject.preferredNewFeasible">
\brief Given a valid solution (with reduced costs, etc.),
        return a branching object which would give a new feasible
        point in a good direction.

        If the method cannot generate a feasible point (because there aren't
        any, or because it isn't bright enough to find one), it should
        return null.

</member>
        <member name="M:CbcObject.solverBranch">
Create an OsiSolverBranch object

        This returns NULL if branch not represented by bound changes

</member>
        <member name="M:CbcObject.createOsiBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Create an Osibranching object and indicate which way to branch first.

        The branching object has to know how to create branches (fix
        variables, etc.)

</member>
        <member name="M:CbcObject.createCbcBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Create a branching object and indicate which way to branch first.

        The branching object has to know how to create branches (fix
        variables, etc.)

</member>
        <member name="M:CbcObject.feasibleRegion(OsiSolverInterface*)">
For the variable(s) referenced by the object,
        look at the current solution and set bounds to match the solution.
        Returns measure of how much it had to move solution to make feasible

</member>
        <member name="M:CbcObject.feasibleRegion(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*)">
Dummy one for compatibility
</member>
        <member name="M:CbcObject.feasibleRegion">
For the variable(s) referenced by the object,
        look at the current solution and set bounds to match the solution.

</member>
        <member name="M:CbcObject.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility of the object

        This is some measure of the infeasibility of the object. It should be
        scaled to be in the range [0.0, 0.5], with 0.0 indicating the object
        is satisfied.

        The preferred branching direction is returned in preferredWay,

        This is used to prepare for strong branching but should also think of
        case when no strong branching

        The object may also compute an estimate of cost of going "up" or "down".
        This will probably be based on pseudo-cost ideas

</member>
        <member name="M:CbcObject.Dispose">
Destructor
</member>
        <member name="M:CbcObject.clone">
Clone
</member>
        <member name="F:CoinSearchTreeManager.recentlyReevaluatedSearchStrategy_">
variable used to test whether we need to reevaluate search strategy 
</member>
        <member name="F:CoinSearchTreeManager.hasUB_">
Whether there is an upper bound or not. The upper bound may have come
	as input, not necessarily from a solution 
</member>
        <member name="M:CoinSearchTreeBase.pop">
pop will advance the \c next pointer among the siblings on the top and
	then moves the top to its correct position. #realpop is the method
	that actually removes the element from the heap 
</member>
        <member name="T:CoinSearchTreeCompareBest">
Best first search 
</member>
        <member name="T:CoinSearchTreeCompareDepth">
Depth First Search. 
</member>
        <member name="T:CoinSearchTreeComparePreferred">
Function objects to compare search tree nodes. The comparison function
    must return true if the first argument is "better" than the second one,
    i.e., it should be processed first. 
Depth First Search. 
</member>
        <member name="M:CoinTreeSiblings.advanceNode">
returns false if cannot be advanced 
</member>
        <member name="F:CoinTreeNode.true_lower_bound_">
A true lower bound on the node. May be -infinity. For normal
	branch-and-cut problems the LP relaxation value is OK. It is different
	when column generation is done. 
</member>
        <member name="F:CoinTreeNode.quality_">
Some quality for the node. For normal branch-and-cut problems the LP
	relaxation value will do just fine. It is probably an OK approximation
	even if column generation is done. 
</member>
        <member name="F:CoinTreeNode.fractionality_">
A measure of fractionality, e.g., the number of unsatisfied
	integrality requirements 
</member>
        <member name="F:CoinTreeNode.depth_">
The depth of the node in the tree
</member>
        <member name="T:CoinTreeNode">
A class from which the real tree nodes should be derived from. Some of the
    data that undoubtedly exist in the real tree node is replicated here for
    fast access. This class is used in the various comparison functions. 
</member>
        <member name="F:OsiCuts.colCutPtrs_">
Vector of column cuts pointers
</member>
        <member name="F:OsiCuts.rowCutPtrs_">
@name Private member data 
Vector of row cuts pointers
</member>
        <member name="M:OsiCuts.gutsOfDestructor">
Delete internal data
</member>
        <member name="M:OsiCuts.gutsOfCopy(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Private methods 
Copy internal data
</member>
        <member name="M:OsiCuts.OsiCutCompare.op_FunctionCall(OsiCut!System.Runtime.CompilerServices.IsConst*,OsiCut!System.Runtime.CompilerServices.IsConst*)">
Function for sorting cuts by effectiveness
</member>
        <member name="M:OsiCuts.Dispose">
Destructor
</member>
        <member name="M:OsiCuts.op_Assign(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiCuts.#ctor(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiCuts.#ctor">
@name Constructors and destructors 
Default constructor
</member>
        <member name="M:OsiCuts.end">
Get iterator to end of collection

Get const iterator to end of collection
</member>
        <member name="M:OsiCuts.begin">
@name Iterators 
     Example of using an iterator to sum effectiveness
     of all cuts in the collection.
     <pre>
     double sumEff=0.0;
     for ( OsiCuts::iterator it=cuts.begin(); it!=cuts.end(); ++it )
           sumEff+= (*it)-&gt;effectiveness();
     </pre>

Get iterator to beginning of collection

Get const iterator to beginning of collection
</member>
        <member name="M:OsiCuts.sort">
@name Sorting collection 
Cuts with greatest effectiveness are first.
</member>
        <member name="M:OsiCuts.rowCutPtrAndZap(System.Int32)">
Get pointer to i'th row cut and remove ptr from collection

Get pointer to i'th row cut and remove ptr from collection
</member>
        <member name="M:OsiCuts.eraseColCut(System.Int32)">
Remove i'th column cut from collection
</member>
        <member name="M:OsiCuts.eraseRowCut(System.Int32)">
@name Deleting cut from collection 
Remove i'th row cut from collection
</member>
        <member name="M:OsiCuts.mostEffectiveCutPtr">
Get const pointer to the most effective cut

Get pointer to the most effective cut
</member>
        <member name="M:OsiCuts.colCut(System.Int32)">
Get reference to i'th column cut

Get const reference to i'th column cut
</member>
        <member name="M:OsiCuts.rowCut(System.Int32)">
Get reference to i'th row cut

Get const reference to i'th row cut
</member>
        <member name="M:OsiCuts.colCutPtr(System.Int32)">
Get pointer to i'th column cut

Get const pointer to i'th column cut
</member>
        <member name="M:OsiCuts.rowCutPtr(System.Int32)">
@name Get a cut from collection 
Get pointer to i'th row cut

Get const pointer to i'th row cut
</member>
        <member name="M:OsiCuts.printCuts">
@name Debug stuff 
Print cuts in collection
</member>
        <member name="M:OsiCuts.sizeCuts">
Number of cuts in collection
</member>
        <member name="M:OsiCuts.sizeColCuts">
Number of column cuts in collection
</member>
        <member name="M:OsiCuts.sizeRowCuts">
@name Number of cuts in collection 
Number of row cuts in collection
</member>
        <member name="M:OsiCuts.insert(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Insert a set of cuts 
</member>
        <member name="M:OsiCuts.insert(OsiColCut**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Insert a column cut.
    
      The OsiCuts object takes control of the cut object.
      On return \c ccPtr is NULL.

</member>
        <member name="M:OsiCuts.insert(OsiRowCut**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Insert a row cut.
    
      The OsiCuts object takes control of the cut object.
      On return, \c rcPtr is NULL.

</member>
        <member name="M:OsiCuts.insert(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Insert a column cut 
</member>
        <member name="M:OsiCuts.insertIfNotDuplicate(OsiRowCut*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinRelFltEq)">
\brief Insert a row cut unless it is a duplicate - cut may get sorted.
       Duplicate is defined as CoinRelFltEq says same
</member>
        <member name="M:OsiCuts.insertIfNotDuplicate(OsiRowCut*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinAbsFltEq)">
\brief Insert a row cut unless it is a duplicate - cut may get sorted.
       Duplicate is defined as CoinAbsFltEq says same
</member>
        <member name="M:OsiCuts.insert(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\name Inserting a cut into collection 
\brief Insert a row cut 
</member>
        <member name="T:OsiCuts.const_iterator">
Const Iterator

      This is a class for iterating over the collection of cuts.

</member>
        <member name="T:OsiCuts.iterator">
@name Iterator classes

Iterator

      This is a class for iterating over the collection of cuts.

</member>
        <member name="T:OsiCuts">
Collections of row cuts and column cuts

</member>
        <member name="F:OsiColCut.ubs_">
Upper bounds
</member>
        <member name="F:OsiColCut.lbs_">
@name Private member data 
Lower bounds
</member>
        <member name="M:OsiColCut.print">
@name Debug stuff 
Print cuts in collection
</member>
        <member name="M:OsiColCut.Dispose">
Destructor
</member>
        <member name="M:OsiColCut.clone">
Clone
</member>
        <member name="M:OsiColCut.#ctor">
Default Constructor
</member>
        <member name="M:OsiColCut.#ctor(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiColCut.op_Assign(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Constructors and destructors 
Assignment operator
</member>
        <member name="M:OsiColCut.violated(System.Double!System.Runtime.CompilerServices.IsConst*)">
Returns infeasibility of the cut with respect to solution 
      passed in i.e. is positive if cuts off that solution.  
      solution is getNumCols() long..

</member>
        <member name="M:OsiColCut.op_Inequality(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
not equal
</member>
        <member name="M:OsiColCut.op_Equality(OsiColCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Comparison operators  
equal - true if lower bounds, upper bounds, 
  and OsiCut are equal.

</member>
        <member name="M:OsiColCut.ubs">
Get column upper bounds
</member>
        <member name="M:OsiColCut.lbs">
@name Getting column bounds 
Get column lower bounds
</member>
        <member name="M:OsiColCut.setUbs(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set column upper bounds from a packed vector
</member>
        <member name="M:OsiColCut.setUbs(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Set column upper bounds
</member>
        <member name="M:OsiColCut.setLbs(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set column lower bounds from a packed vector
</member>
        <member name="M:OsiColCut.setLbs(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
@name Setting column bounds 
Set column lower bounds
</member>
        <member name="F:OsiRowCut2.whichRow_">
@name Private member data 
Which row
</member>
        <member name="M:OsiRowCut2.Dispose">
Destructor
</member>
        <member name="M:OsiRowCut2.#ctor(System.Int32)">
Default Constructor
</member>
        <member name="M:OsiRowCut2.clone">
Clone
</member>
        <member name="M:OsiRowCut2.#ctor(OsiRowCut2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiRowCut2.op_Assign(OsiRowCut2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Constructors and destructors 
Assignment operator
</member>
        <member name="M:OsiRowCut2.setWhichRow(System.Int32)">
Set row
</member>
        <member name="M:OsiRowCut2.whichRow">
@name Which row 
Get row
</member>
        <member name="T:OsiRowCut2">
Row Cut Class which refers back to row which created it.
    It may be useful to strengthen a row rather than add a cut.  To do this
    we need to know which row is strengthened.  This trivial extension
    to OsiRowCut does that.


</member>
        <member name="F:OsiRowCut.ub_">
Row upper bound
</member>
        <member name="F:OsiRowCut.lb_">
Row lower bound
</member>
        <member name="F:OsiRowCut.row_">
@name Private member data 
Row elements
</member>
        <member name="M:OsiRowCut.print">
@name Debug stuff 
Print cuts in collection
</member>
        <member name="M:OsiRowCut.Dispose">
Destructor
</member>
        <member name="M:OsiRowCut.#ctor(System.Double,System.Double,System.Int32,System.Int32,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
\brief Ownership Constructor

      This constructor assumes ownership of the vectors passed as parameters
      for indices and elements. \p colIndices and \p elements will be NULL
      on return.

</member>
        <member name="M:OsiRowCut.#ctor">
Default Constructor
</member>
        <member name="M:OsiRowCut.clone">
Clone
</member>
        <member name="M:OsiRowCut.#ctor(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiRowCut.op_Assign(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Constructors and destructors 
Assignment operator
</member>
        <member name="M:OsiRowCut.sortIncrIndex">
Allow access row sorting function
</member>
        <member name="M:OsiRowCut.op_DivisionAssignment(System.Double)">
divide every vector entry by <code>value</code></member>
        <member name="M:OsiRowCut.op_MultiplicationAssignment(System.Double)">
multiply every vector entry by <code>value</code></member>
        <member name="M:OsiRowCut.op_SubtractionAssignment(System.Double)">
subtract <code>value</code> from every vector entry
</member>
        <member name="M:OsiRowCut.op_AdditionAssignment(System.Double)">
@name Arithmetic operators. Apply CoinPackedVector methods to the vector 
add <code>value</code> to every vector entry
</member>
        <member name="M:OsiRowCut.violated(System.Double!System.Runtime.CompilerServices.IsConst*)">
Returns infeasibility of the cut with respect to solution 
	passed in i.e. is positive if cuts off that solution.  
	solution is getNumCols() long..

</member>
        <member name="M:OsiRowCut.op_Inequality(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
not equal
</member>
        <member name="M:OsiRowCut.op_Equality(OsiRowCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Comparison operators  
equal - true if lower bound, upper bound, row elements,
        and OsiCut are equal.

</member>
        <member name="M:OsiRowCut.mutableRow">
Get row elements for changing
</member>
        <member name="M:OsiRowCut.row">
Get row elements
</member>
        <member name="M:OsiRowCut.setRow(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set row elements from a packed vector
</member>
        <member name="M:OsiRowCut.setRow(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
@name Row elements  
Set row elements
</member>
        <member name="M:OsiRowCut.range">
Get range (ub - lb for 'R' rows, 0 otherwise)
</member>
        <member name="M:OsiRowCut.rhs">
Get right-hand side
</member>
        <member name="M:OsiRowCut.sense">
@name Row rhs, sense, range 
Get sense ('E', 'G', 'L', 'N', 'R')
</member>
        <member name="M:OsiRowCut.setUb(System.Double)">
Set upper bound
</member>
        <member name="M:OsiRowCut.ub">
Get upper bound
</member>
        <member name="M:OsiRowCut.setLb(System.Double)">
Set lower bound
</member>
        <member name="M:OsiRowCut.lb">
@name Row bounds 
Get lower bound
</member>
        <member name="F:OsiCut.globallyValid_">
If cut has global validity i.e. can be used anywhere in tree
</member>
        <member name="F:OsiCut.effectiveness_">
@name Private member data 
Effectiveness
</member>
        <member name="M:OsiCut.Dispose">
Destructor
</member>
        <member name="M:OsiCut.op_Assign(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiCut.#ctor(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiCut.#ctor">
@name Constructors and destructors 
Default Constructor
</member>
        <member name="M:OsiCut.violated(System.Double!System.Runtime.CompilerServices.IsConst*)">
Returns infeasibility of the cut with respect to solution 
      passed in i.e. is positive if cuts off that solution.  
      solution is getNumCols() long..

</member>
        <member name="M:OsiCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns true if cut is consistent when considering the solver
      interface's model.  For example, it might check to ensure
      that a column index is not greater than the number of columns
      in the model. Assumes consistent() is true.

</member>
        <member name="M:OsiCut.consistent">
@name Sanity checks on cut 
Returns true if the cut is consistent with respect to itself,
      without considering any
      data in the model. For example, it might check to ensure
      that a column index is not negative.

</member>
        <member name="M:OsiCut.op_GreaterThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
less than. True if this.effectiveness &gt; rhs.effectiveness
</member>
        <member name="M:OsiCut.op_Inequality(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
not equal
</member>
        <member name="M:OsiCut.op_Equality(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Comparison operators  
equal. 2 cuts are equal if there effectiveness are equal
</member>
        <member name="M:OsiCut.print">
@name Debug stuff 
Print cuts in collection
</member>
        <member name="M:OsiCut.globallyValidAsInteger">
Get globallyValid
</member>
        <member name="M:OsiCut.setGloballyValidAsInteger(System.Int32)">
Set globallyValid as integer (nonzero true)
</member>
        <member name="M:OsiCut.globallyValid">
Get globallyValid
</member>
        <member name="M:OsiCut.setGloballyValid(System.Boolean)">
@name GloballyValid 
Set globallyValid (nonzero true)
</member>
        <member name="M:OsiCut.effectiveness">
Get effectiveness
</member>
        <member name="M:OsiCut.setEffectiveness(System.Double)">
@name Effectiveness 
Set effectiveness
</member>
        <member name="M:CoinPackedVectorUnitTest">
A function that tests the methods in the CoinPackedVector class. The
    only reason for it not to be a member method is that this way it doesn't
    have to be compiled into the library. And that's a gain, because the
    library should be compiled with optimization on, but this method should be
    compiled with debugging. 
</member>
        <member name="M:op_Division(System.Double,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the element-wise ratio of a a constant and packed vector
</member>
        <member name="M:op_Multiply(System.Double,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the element-wise product of a constant and a packed vector
</member>
        <member name="M:op_Subtraction(System.Double,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the difference of a constant and a packed vector
</member>
        <member name="M:op_Addition(System.Double,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the sum of a constant and a packed vector
</member>
        <member name="M:op_Division(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Return the element-wise ratio of a packed vector and a constant
</member>
        <member name="M:op_Multiply(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Return the element-wise product of a packed vector and a constant
</member>
        <member name="M:op_Subtraction(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Return the difference of a packed vector and a constant
</member>
        <member name="M:sortedSparseDotProduct(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the dot product of two sorted CoinPackedVector objects.
 The vectors should be sorted in ascending order of indices.
</member>
        <member name="M:sparseDotProduct(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns the dot product of two CoinPackedVector objects whose elements are
doubles.  Use this version if the vectors are *not* guaranteed to be sorted.
</member>
        <member name="M:op_Division(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the element-wise ratio of two packed vectors
</member>
        <member name="M:op_Multiply(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the element-wise product of two packed vectors
</member>
        <member name="M:op_Subtraction(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the difference of two packed vectors
</member>
        <member name="M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the sum of two packed vectors
</member>
        <member name="F:CoinPackedVector.capacity_">
Amount of memory allocated for indices_, origIndices_, and elements_.
</member>
        <member name="F:CoinPackedVector.origIndices_">
original unsorted indices
</member>
        <member name="F:CoinPackedVector.nElements_">
Size of indices and elements vectors
</member>
        <member name="F:CoinPackedVector.elements_">
Vector elements
</member>
        <member name="F:CoinPackedVector.indices_">
@name Private member data 
Vector indices
</member>
        <member name="M:CoinPackedVector.gutsOfSetVector(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@name Private methods 
Copy internal date
</member>
        <member name="M:CoinPackedVector.Dispose">
Destructor 
</member>
        <member name="M:CoinPackedVector.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor <em>from a PackedVectorBase</em>. 
</member>
        <member name="M:CoinPackedVector.#ctor(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinPackedVector.#ctor(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Alternate Constructors - construct full storage with indices 0 through
       size-1. 
</member>
        <member name="M:CoinPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double,System.Boolean)">
Alternate Constructors - set elements to same scalar value 
</member>
        <member name="M:CoinPackedVector.#ctor(System.Int32,System.Int32,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
\brief Alternate Constructors - set elements to vector of doubles

     This constructor takes ownership of the vectors passed as parameters.
     \p inds and \p elems will be NULL on return.

</member>
        <member name="M:CoinPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
\brief Alternate Constructors - set elements to vector of doubles
   
     This constructor copies the vectors provided as parameters.

</member>
        <member name="M:CoinPackedVector.#ctor(System.Boolean)">
@name Constructors and destructors 
Default constructor 
</member>
        <member name="M:CoinPackedVector.capacity">
capacity returns the size which could be accomodated without
       having to reallocate storage.

</member>
        <member name="M:CoinPackedVector.reserve(System.Int32)">
@name Memory usage 
Reserve space.
       If one knows the eventual size of the packed vector,
       then it may be more efficient to reserve the space.

</member>
        <member name="M:CoinPackedVector.sortOriginalOrder">
Sort in original order.
       If the vector has been sorted, then this method restores
       to its orignal sort order.

</member>
        <member name="M:CoinPackedVector.op_DivisionAssignment(System.Double)">
divide every entry by <code>value</code></member>
        <member name="M:CoinPackedVector.op_MultiplicationAssignment(System.Double)">
multiply every entry by <code>value</code></member>
        <member name="M:CoinPackedVector.op_SubtractionAssignment(System.Double)">
subtract <code>value</code> from every entry
</member>
        <member name="M:CoinPackedVector.op_AdditionAssignment(System.Double)">
@name Arithmetic operators. 
add <code>value</code> to every entry
</member>
        <member name="M:CoinPackedVector.truncate(System.Int32)">
Resize the packed vector to be the first newSize elements.
       Problem with truncate: what happens with origIndices_ ??? 
</member>
        <member name="M:CoinPackedVector.swap(System.Int32,System.Int32)">
Swap values in positions i and j of indices and elements
</member>
        <member name="M:CoinPackedVector.append(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Append a CoinPackedVector to the end
</member>
        <member name="M:CoinPackedVector.insert(System.Int32,System.Double)">
Insert an element into the vector
</member>
        <member name="M:CoinPackedVector.setElement(System.Int32,System.Double)">
Set an existing element in the packed vector
       The first argument is the "index" into the elements() array

</member>
        <member name="M:CoinPackedVector.setFullNonZero(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Indices are not specified and are taken to be 0,1,...,size-1,
    but only where non zero
</member>
        <member name="M:CoinPackedVector.setFull(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Indices are not specified and are taken to be 0,1,...,size-1 
</member>
        <member name="M:CoinPackedVector.setConstant(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double,System.Boolean)">
Elements set to have the same scalar value 
</member>
        <member name="M:CoinPackedVector.setVector(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Set vector size, indices, and elements.
       Size is the length of both the indices and elements vectors.
       The indices and elements vectors are copied into this class instance's
       member data. The last argument specifies whether this vector will have
       to be checked for duplicate indices whenever that can happen. 
</member>
        <member name="M:CoinPackedVector.assignVector(System.Int32,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Assign the ownership of the arguments to this vector.
       Size is the length of both the indices and elements vectors.
       The indices and elements vectors are copied into this class instance's
       member data. The last argument indicates whether this vector will have
       to be tested for duplicate indices.

</member>
        <member name="M:CoinPackedVector.clear">
@name Set methods 
Reset the vector (as if were just created an empty vector)
</member>
        <member name="M:CoinPackedVector.getOriginalPosition">
Get pointer to int * vector of original postions.
       If the packed vector has not been sorted then this
       function returns the vector: 0, 1, 2, ..., size()-1. 
</member>
        <member name="M:CoinPackedVector.getVectorElements">
Get element values
</member>
        <member name="M:CoinPackedVector.getVectorIndices">
Get indices of elements
</member>
        <member name="M:CoinPackedVector.getVectorNumElements">
Get the size
</member>
        <member name="M:CoinPackedVector.getElements">
Get element values

Get element values
</member>
        <member name="M:CoinPackedVector.getIndices">
Get indices of elements

Get indices of elements
</member>
        <member name="M:CoinPackedVector.getNumElements">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinPackedVector">
Sparse Vector

Stores vector of indices and associated element values.
Supports sorting of vector while maintaining the original indices.

Here is a sample usage:
@verbatim
    const int ne = 4;
    int inx[ne] =   {  1,   4,  0,   2 }
    double el[ne] = { 10., 40., 1., 50. }

    // Create vector and set its value
    CoinPackedVector r(ne,inx,el);

    // access each index and element
    assert( r.indices ()[0]== 1  );
    assert( r.elements()[0]==10. );
    assert( r.indices ()[1]== 4  );
    assert( r.elements()[1]==40. );
    assert( r.indices ()[2]== 0  );
    assert( r.elements()[2]== 1. );
    assert( r.indices ()[3]== 2  );
    assert( r.elements()[3]==50. );

    // access original position of index
    assert( r.originalPosition()[0]==0 );
    assert( r.originalPosition()[1]==1 );
    assert( r.originalPosition()[2]==2 );
    assert( r.originalPosition()[3]==3 );

    // access as a full storage vector
    assert( r[ 0]==1. );
    assert( r[ 1]==10.);
    assert( r[ 2]==50.);
    assert( r[ 3]==0. );
    assert( r[ 4]==40.);

    // sort Elements in increasing order
    r.sortIncrElement();

    // access each index and element
    assert( r.indices ()[0]== 0  );
    assert( r.elements()[0]== 1. );
    assert( r.indices ()[1]== 1  );
    assert( r.elements()[1]==10. );
    assert( r.indices ()[2]== 4  );
    assert( r.elements()[2]==40. );
    assert( r.indices ()[3]== 2  );
    assert( r.elements()[3]==50. );    

    // access original position of index    
    assert( r.originalPosition()[0]==2 );
    assert( r.originalPosition()[1]==0 );
    assert( r.originalPosition()[2]==1 );
    assert( r.originalPosition()[3]==3 );

    // access as a full storage vector
    assert( r[ 0]==1. );
    assert( r[ 1]==10.);
    assert( r[ 2]==50.);
    assert( r[ 3]==0. );
    assert( r[ 4]==40.);

    // Restore orignal sort order
    r.sortOriginalOrder();
    
    assert( r.indices ()[0]== 1  );
    assert( r.elements()[0]==10. );
    assert( r.indices ()[1]== 4  );
    assert( r.elements()[1]==40. );
    assert( r.indices ()[2]== 0  );
    assert( r.elements()[2]== 1. );
    assert( r.indices ()[3]== 2  );
    assert( r.elements()[3]==50. );

    // Tests for equality and equivalence
    CoinPackedVector r1;
    r1=r;
    assert( r==r1 );
    assert( r.equivalent(r1) );
    r.sortIncrElement();
    assert( r!=r1 );
    assert( r.equivalent(r1) );

    // Add packed vectors.
    // Similarly for subtraction, multiplication,
    // and division.
    CoinPackedVector add = r + r1;
    assert( add[0] ==  1.+ 1. );
    assert( add[1] == 10.+10. );
    assert( add[2] == 50.+50. );
    assert( add[3] ==  0.+ 0. );
    assert( add[4] == 40.+40. );

    assert( r.sum() == 10.+40.+1.+50. );
@endverbatim

</member>
        <member name="F:OsiLotsizeBranchingObject.up_">
Lower [0] and upper [1] bounds for the up arm (way_ = 1)
</member>
        <member name="F:OsiLotsizeBranchingObject.down_">
Lower [0] and upper [1] bounds for the down arm (way_ = -1)
</member>
        <member name="M:OsiLotsizeBranchingObject.print(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
\brief Print something about branch - only if log level high

</member>
        <member name="M:OsiLotsizeBranchingObject.branch(OsiSolverInterface*)">
\brief Sets the bounds for the variable according to the current arm
	     of the branch and advances the object state to the next arm.
	     state. 
	     Returns change in guessed objective on next branch

</member>
        <member name="M:OsiLotsizeBranchingObject.Dispose">
Destructor
</member>
        <member name="M:OsiLotsizeBranchingObject.clone">
Clone
</member>
        <member name="M:OsiLotsizeBranchingObject.op_Assign(OsiLotsizeBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiLotsizeBranchingObject.#ctor(OsiLotsizeBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiLotsizeBranchingObject.#ctor">
Default constructor
</member>
        <member name="T:OsiLotsizeBranchingObject">
Lotsize branching object

  This object can specify a two-way branch on an integer variable. For each
  arm of the branch, the upper and lower bounds on the variable can be
  independently specified.
  
  Variable_ holds the index of the integer variable in the integerVariable_
  array of the model.

</member>
        <member name="F:OsiLotsize.range_">
Current range
</member>
        <member name="F:OsiLotsize.bound_">
Ranges
</member>
        <member name="F:OsiLotsize.numberRanges_">
Number of points
</member>
        <member name="F:OsiLotsize.rangeType_">
Type - 1 points, 2 ranges
</member>
        <member name="F:OsiLotsize.columnNumber_">
data
Column number in model
</member>
        <member name="M:OsiLotsize.canDoHeuristics">
\brief Return true if object can take part in normal heuristics

</member>
        <member name="M:OsiLotsize.canHandleShadowPrices">
Return true if knows how to deal with Pseudo Shadow Prices
</member>
        <member name="M:OsiLotsize.downEstimate">
Return "down" estimate (default 1.0e-5)
</member>
        <member name="M:OsiLotsize.upEstimate">
Return "up" estimate (default 1.0e-5)
</member>
        <member name="M:OsiLotsize.resetSequenceEtc(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Change column numbers after preprocessing

</member>
        <member name="M:OsiLotsize.bound">
Ranges
</member>
        <member name="M:OsiLotsize.numberRanges">
Number of points
</member>
        <member name="M:OsiLotsize.rangeType">
Type - 1 points, 2 ranges
</member>
        <member name="M:OsiLotsize.originalLowerBound">
Original bounds
</member>
        <member name="M:OsiLotsize.floorCeiling(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Returns floor and ceiling

</member>
        <member name="M:OsiLotsize.findRange(System.Double,System.Double)">
Finds range of interest so value is feasible in range range_ or infeasible 
      between hi[range_] and lo[range_+1].  Returns true if feasible.

</member>
        <member name="M:OsiLotsize.resetBounds(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Reset original upper and lower bound values from the solver.
  
    Handy for updating bounds held in this object after bounds held in the
    solver have been tightened.

</member>
        <member name="M:OsiLotsize.columnNumber">
Column number if single column object -1 otherwise,
      so returns &gt;= 0
      Used by heuristics

</member>
        <member name="M:OsiLotsize.setColumnNumber(System.Int32)">
Set solver column number
</member>
        <member name="M:OsiLotsize.createBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object

    The preferred direction is set by \p way, 0 for down, 1 for up.

</member>
        <member name="M:OsiLotsize.feasibleRegion(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*)">
Set bounds to contain the current solution.

    More precisely, for the variable associated with this object, take the
    value given in the current solution, force it within the current bounds
    if required, then set the bounds to fix the variable at the integer
    nearest the solution value.  Returns amount it had to move variable.

</member>
        <member name="M:OsiLotsize.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:OsiLotsize.clone">
Clone
</member>
        <member name="T:OsiLotsize">
Lotsize class 
</member>
        <member name="M:OsiSOSBranchingObject.print(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
\brief Print something about branch - only if log level high

</member>
        <member name="M:OsiSOSBranchingObject.branch(OsiSolverInterface*)">
Does next branch and updates state
</member>
        <member name="M:OsiSOSBranchingObject.clone">
Clone
</member>
        <member name="T:OsiSOSBranchingObject">
Branching object for Special ordered sets


</member>
        <member name="F:OsiSOS.integerValued_">
Whether integer valued
</member>
        <member name="F:OsiSOS.sosType_">
SOS type
</member>
        <member name="F:OsiSOS.numberMembers_">
Number of members
</member>
        <member name="F:OsiSOS.weights_">
Weights
</member>
        <member name="F:OsiSOS.members_">
data
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="M:OsiSOS.mutableWeights">
Array of weights 
</member>
        <member name="M:OsiSOS.setSosType(System.Int32)">
Set SOS type
</member>
        <member name="M:OsiSOS.mutableMembers">
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="M:OsiSOS.setNumberMembers(System.Int32)">
Set number of members
</member>
        <member name="M:OsiSOS.canHandleShadowPrices">
Return true if knows how to deal with Pseudo Shadow Prices
</member>
        <member name="M:OsiSOS.setIntegerValued(System.Boolean)">
Set whether set is integer valued or not
</member>
        <member name="M:OsiSOS.canDoHeuristics">
\brief Return true if object can take part in normal heuristics

</member>
        <member name="M:OsiSOS.weights">
Array of weights 
</member>
        <member name="M:OsiSOS.setType">
SOS type
</member>
        <member name="M:OsiSOS.sosType">
SOS type
</member>
        <member name="M:OsiSOS.members">
Members (indices in range 0 ... numberColumns-1)
</member>
        <member name="M:OsiSOS.numberMembers">
Number of members
</member>
        <member name="M:OsiSOS.resetSequenceEtc(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Redoes data when sequence numbers change
</member>
        <member name="M:OsiSOS.downEstimate">
Return "down" estimate (default 1.0e-5)
</member>
        <member name="M:OsiSOS.upEstimate">
Return "up" estimate (default 1.0e-5)
</member>
        <member name="M:OsiSOS.createBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object

    The preferred direction is set by \p way, 0 for down, 1 for up.

</member>
        <member name="M:OsiSOS.feasibleRegion(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*)">
Set bounds to fix the variable at the current (integer) value.

    Given an integer value, set the lower and upper bounds to fix the
    variable. Returns amount it had to move variable.

</member>
        <member name="M:OsiSOS.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:OsiSOS.clone">
Clone
</member>
        <member name="M:OsiSOS.#ctor(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Useful constructor - which are indices
      and  weights are also given.  If null then 0,1,2..
      type is SOS type

</member>
        <member name="T:OsiSOS">
Define Special Ordered Sets of type 1 and 2.  These do not have to be
    integer - so do not appear in lists of integers.
    
    which_ points columns of matrix

</member>
        <member name="F:OsiIntegerBranchingObject.up_">
Lower [0] and upper [1] bounds for the up arm (way_ = 1)
</member>
        <member name="F:OsiIntegerBranchingObject.down_">
Lower [0] and upper [1] bounds for the down arm (way_ = -1)
</member>
        <member name="M:OsiIntegerBranchingObject.print(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
\brief Print something about branch - only if log level high

</member>
        <member name="M:OsiIntegerBranchingObject.branch(OsiSolverInterface*)">
\brief Sets the bounds for the variable according to the current arm
	     of the branch and advances the object state to the next arm.
	     state. 
	     Returns change in guessed objective on next branch

</member>
        <member name="M:OsiIntegerBranchingObject.Dispose">
Destructor
</member>
        <member name="M:OsiIntegerBranchingObject.clone">
Clone
</member>
        <member name="M:OsiIntegerBranchingObject.op_Assign(OsiIntegerBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiIntegerBranchingObject.#ctor(OsiIntegerBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiIntegerBranchingObject.#ctor">
Default constructor
</member>
        <member name="T:OsiIntegerBranchingObject">
Simple branching object for an integer variable

  This object can specify a two-way branch on an integer variable. For each
  arm of the branch, the upper and lower bounds on the variable can be
  independently specified. 0 -&gt; down, 1-&gt; up.

</member>
        <member name="F:OsiSimpleInteger.columnNumber_">
Column number in solver
</member>
        <member name="F:OsiSimpleInteger.originalUpper_">
Original upper bound
</member>
        <member name="F:OsiSimpleInteger.originalLower_">
data
Original lower bound
</member>
        <member name="M:OsiSimpleInteger.canHandleShadowPrices">
Return true if knows how to deal with Pseudo Shadow Prices
</member>
        <member name="M:OsiSimpleInteger.downEstimate">
Return "down" estimate (default 1.0e-5)
</member>
        <member name="M:OsiSimpleInteger.upEstimate">
Return "up" estimate (default 1.0e-5)
</member>
        <member name="M:OsiSimpleInteger.resetSequenceEtc(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Change column numbers after preprocessing

</member>
        <member name="M:OsiSimpleInteger.resetBounds(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Reset variable bounds to their original values.
    Bounds may be tightened, so it may be good to be able to reset them to
    their original values.

</member>
        <member name="M:OsiSimpleInteger.originalLowerBound">
Original bounds
</member>
        <member name="M:OsiSimpleInteger.columnNumber">
Column number if single column object -1 otherwise,
      so returns &gt;= 0
      Used by heuristics

</member>
        <member name="M:OsiSimpleInteger.setColumnNumber(System.Int32)">
Set solver column number
</member>
        <member name="M:OsiSimpleInteger.createBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Creates a branching object

    The preferred direction is set by \p way, 0 for down, 1 for up.

</member>
        <member name="M:OsiSimpleInteger.feasibleRegion(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*)">
Set bounds to fix the variable at the current (integer) value.

    Given an integer value, set the lower and upper bounds to fix the
    variable. Returns amount it had to move variable.

</member>
        <member name="M:OsiSimpleInteger.infeasibility(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility - large is 0.5
</member>
        <member name="M:OsiSimpleInteger.Dispose">
Destructor
</member>
        <member name="M:OsiSimpleInteger.op_Assign(OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiSimpleInteger.clone">
Clone
</member>
        <member name="M:OsiSimpleInteger.#ctor(OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiSimpleInteger.#ctor(System.Int32,System.Double,System.Double)">
Useful constructor - passed solver index and original bounds
</member>
        <member name="M:OsiSimpleInteger.#ctor(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Useful constructor - passed solver index
</member>
        <member name="M:OsiSimpleInteger.#ctor">
Default Constructor
</member>
        <member name="T:OsiSimpleInteger">
Define a single integer class
</member>
        <member name="F:OsiTwoWayBranchingObject.firstBranch_">
Which way was first branch -1 = down, +1 = up
</member>
        <member name="M:OsiTwoWayBranchingObject.way">
Way returns -1 on down +1 on up
</member>
        <member name="M:OsiTwoWayBranchingObject.branch(OsiSolverInterface*)">
\brief Sets the bounds for the variable according to the current arm
	     of the branch and advances the object state to the next arm.
	     state. 
	     Returns change in guessed objective on next branch

</member>
        <member name="M:OsiTwoWayBranchingObject.Dispose">
Destructor
</member>
        <member name="M:OsiTwoWayBranchingObject.op_Assign(OsiTwoWayBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiTwoWayBranchingObject.#ctor(OsiTwoWayBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiTwoWayBranchingObject.#ctor(OsiSolverInterface*,OsiObject!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)">
Create a standard tw0-way branch object

    Specifies a simple two-way branch.
    Specify way = -1 to set the object state to perform the down arm first,
    way = 1 for the up arm.

</member>
        <member name="M:OsiTwoWayBranchingObject.#ctor">
Default constructor
</member>
        <member name="T:OsiTwoWayBranchingObject">
This just adds two-wayness to a branching object
</member>
        <member name="F:OsiBranchingInformation.owningSolution_">
TEMP
</member>
        <member name="F:OsiBranchingInformation.depth_">
Depth in tree
</member>
        <member name="F:OsiBranchingInformation.numberBranchingSolutions_">
Number of branching solutions found (i.e. exclude heuristics)
</member>
        <member name="F:OsiBranchingInformation.numberSolutions_">
Number of solutions found
</member>
        <member name="F:OsiBranchingInformation.indexRegion_">
Useful index region to go with usefulRegion_
</member>
        <member name="F:OsiBranchingInformation.usefulRegion_">
Useful region of length CoinMax(numberColumns,2*numberRows)
      This is allocated and deleted before OsiObject::infeasibility
      It is zeroed on entry and should be so on exit
      It only exists if defaultDual_&gt;=0.0

</member>
        <member name="F:OsiBranchingInformation.row_">
Row indices
</member>
        <member name="F:OsiBranchingInformation.columnLength_">
Column lengths
</member>
        <member name="F:OsiBranchingInformation.columnStart_">
Column starts
</member>
        <member name="F:OsiBranchingInformation.elementByColumn_">
Elements in column copy of matrix
</member>
        <member name="F:OsiBranchingInformation.rowUpper_">
Pointer to current upper bounds on rows
</member>
        <member name="F:OsiBranchingInformation.rowLower_">
Pointer to current lower bounds on rows
</member>
        <member name="F:OsiBranchingInformation.objective_">
Objective
</member>
        <member name="F:OsiBranchingInformation.rowActivity_">
Pointer to row activity
</member>
        <member name="F:OsiBranchingInformation.pi_">
Pointer to duals
</member>
        <member name="F:OsiBranchingInformation.hotstartSolution_">
Highly optional target (hot start) solution
</member>
        <member name="F:OsiBranchingInformation.upper_">
Pointer to current upper bounds on columns
</member>
        <member name="F:OsiBranchingInformation.solution_">
Pointer to current solution
</member>
        <member name="F:OsiBranchingInformation.lower_">
Pointer to current lower bounds on columns
</member>
        <member name="F:OsiBranchingInformation.numberColumns_">
The number of columns
</member>
        <member name="F:OsiBranchingInformation.solver_">
Pointer to solver
</member>
        <member name="F:OsiBranchingInformation.defaultDual_">
Dual to use if row bound violated (if negative then pseudoShadowPrices off)
</member>
        <member name="F:OsiBranchingInformation.timeRemaining_">
Maximum time remaining before stopping on time
</member>
        <member name="F:OsiBranchingInformation.primalTolerance_">
Primal tolerance
</member>
        <member name="F:OsiBranchingInformation.integerTolerance_">
Integer tolerance
</member>
        <member name="F:OsiBranchingInformation.direction_">
Direction 1.0 for minimization, -1.0 for maximization
</member>
        <member name="F:OsiBranchingInformation.cutoff_">
Value of objective cutoff (in minimization sense)
</member>
        <member name="F:OsiBranchingInformation.objectiveValue_">
Value of objective function (in minimization sense)
</member>
        <member name="F:OsiBranchingInformation.stateOfSearch_">
data
State of search
      0 - no solution
      1 - only heuristic solutions
      2 - branched to a solution 
      3 - no solution but many nodes

</member>
        <member name="M:OsiBranchingInformation.Dispose">
Destructor
</member>
        <member name="M:OsiBranchingInformation.clone">
Clone
</member>
        <member name="M:OsiBranchingInformation.op_Assign(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiBranchingInformation.#ctor(OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiBranchingInformation.#ctor(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
Useful Constructor 
      (normalSolver true if has matrix etc etc)
      copySolution true if constructot should make a copy

</member>
        <member name="M:OsiBranchingInformation.#ctor">
Default Constructor
</member>
        <member name="F:OsiBranchingObject.branchIndex_">
The state of the branching object. i.e. branch index
      This starts at 0 when created

</member>
        <member name="F:OsiBranchingObject.numberBranches_">
Number of branches

</member>
        <member name="F:OsiBranchingObject.originalObject_">
Pointer back to object which created
</member>
        <member name="F:OsiBranchingObject.value_">
Current value - has some meaning about branch
</member>
        <member name="M:OsiBranchingObject.print(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
\brief Print something about branch - only if log level high

</member>
        <member name="M:OsiBranchingObject.columnNumber">
For debug
</member>
        <member name="M:OsiBranchingObject.checkIsCutoff(System.Double)">
Double checks in case node can change its mind!
      Returns objective value
      Can change objective etc 
</member>
        <member name="M:OsiBranchingObject.setOriginalObject(OsiObject!System.Runtime.CompilerServices.IsConst*)">
Set pointer back to object which created
</member>
        <member name="M:OsiBranchingObject.originalObject">
Return pointer back to object which created
</member>
        <member name="M:OsiBranchingObject.value">
Current value
</member>
        <member name="M:OsiBranchingObject.setBranchingIndex(System.Int32)">
Set the state of the branching object.

</member>
        <member name="M:OsiBranchingObject.branchIndex">
Get the state of the branching object
      This is just the branch index

</member>
        <member name="M:OsiBranchingObject.boundBranch">
\brief Return true if branch should fix variables

</member>
        <member name="M:OsiBranchingObject.branch">
\brief Execute the actions required to branch, as specified by the
	     current state of the branching object, and advance the object's
	     state. 
	     Returns change in guessed objective on next branch

</member>
        <member name="M:OsiBranchingObject.branch(OsiSolverInterface*)">
\brief Execute the actions required to branch, as specified by the
	     current state of the branching object, and advance the object's
	     state. 
	     Returns change in guessed objective on next branch

</member>
        <member name="M:OsiBranchingObject.decrementNumberBranchesLeft">
Decrement the number of branch arms left for this branching object
</member>
        <member name="M:OsiBranchingObject.setNumberBranchesLeft(System.Int32)">
Set the number of branch arms left for this branching object
      Just for forcing

</member>
        <member name="M:OsiBranchingObject.incrementNumberBranchesLeft">
Increment the number of branch arms left for this branching object
</member>
        <member name="M:OsiBranchingObject.numberBranchesLeft">
The number of branch arms left for this branching object
</member>
        <member name="M:OsiBranchingObject.numberBranches">
The number of branch arms created for this branching object
</member>
        <member name="M:OsiBranchingObject.Dispose">
Destructor
</member>
        <member name="M:OsiBranchingObject.clone">
Clone
</member>
        <member name="M:OsiBranchingObject.op_Assign(OsiBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiBranchingObject.#ctor(OsiBranchingObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiBranchingObject.#ctor(OsiSolverInterface*,System.Double)">
Constructor
</member>
        <member name="M:OsiBranchingObject.#ctor">
Default Constructor
</member>
        <member name="T:OsiBranchingObject">
\brief Abstract branching object base class

  In the abstract, an OsiBranchingObject contains instructions for how to
  branch. We want an abstract class so that we can describe how to branch on
  simple objects (<i>e.g.</i>, integers) and more exotic objects
  (<i>e.g.</i>, cliques or hyperplanes).

  The #branch() method is the crucial routine: it is expected to be able to
  step through a set of branch arms, executing the actions required to create
  each subproblem in turn. The base class is primarily virtual to allow for
  a wide range of problem modifications.

  See OsiObject for an overview of the two classes (OsiObject and
  OsiBranchingObject) which make up Osi's branching
  model.

</member>
        <member name="F:OsiObject2.otherInfeasibility_">
"Infeasibility" on other way
</member>
        <member name="F:OsiObject2.preferredWay_">
Preferred way of branching - -1 off, 0 down, 1 up (for 2-way)
</member>
        <member name="M:OsiObject2.preferredWay">
Get preferred way of branching - -1 off, 0 down, 1 up (for 2-way)
</member>
        <member name="M:OsiObject2.setPreferredWay(System.Int32)">
Set preferred way of branching - -1 off, 0 down, 1 up (for 2-way)
</member>
        <member name="M:OsiObject2.Dispose">
Destructor
</member>
        <member name="M:OsiObject2.op_Assign(OsiObject2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiObject2.#ctor(OsiObject2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiObject2.#ctor">
Default Constructor
</member>
        <member name="T:OsiObject2">
Define a class to add a bit of complexity to OsiObject
This assumes 2 way branching
</member>
        <member name="F:OsiObject.priority_">
Priority
</member>
        <member name="F:OsiObject.numberWays_">
Maximum number of ways on branch
</member>
        <member name="F:OsiObject.whichWay_">
Computed preferred way to branch
</member>
        <member name="F:OsiObject.infeasibility_">
data
Computed infeasibility
</member>
        <member name="M:OsiObject.updateAfter(OsiObject!System.Runtime.CompilerServices.IsConst*,OsiObject!System.Runtime.CompilerServices.IsConst*)">
Updates stuff like pseudocosts after threads finished
</member>
        <member name="M:OsiObject.updateBefore(OsiObject!System.Runtime.CompilerServices.IsConst*)">
Updates stuff like pseudocosts before threads
</member>
        <member name="M:OsiObject.resetSequenceEtc(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Change column numbers after preprocessing

</member>
        <member name="M:OsiObject.resetBounds(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*)">
Reset variable bounds to their original values.
    Bounds may be tightened, so it may be good to be able to reset them to
    their original values.

</member>
        <member name="M:OsiObject.downEstimate">
Return "down" estimate (default 1.0e-5)
</member>
        <member name="M:OsiObject.upEstimate">
Return "up" estimate (default 1.0e-5)
</member>
        <member name="M:OsiObject.infeasibility">
Return infeasibility
</member>
        <member name="M:OsiObject.preferredWay">
Get pre-emptive preferred way of branching - -1 off, 0 down, 1 up (for 2-way)
</member>
        <member name="M:OsiObject.whichWay">
Return current preferred way to branch.  If two
      then way=0 means down and 1 means up, otherwise
      way points to preferred branch

</member>
        <member name="M:OsiObject.setWhichWay(System.Int32)">
Return preferred way to branch.  If two
      then way=0 means down and 1 means up, otherwise
      way points to preferred branch

</member>
        <member name="M:OsiObject.setNumberWays(System.Int32)">
Set maximum number of ways branch may have
</member>
        <member name="M:OsiObject.numberWays">
Return maximum number of ways branch may have
</member>
        <member name="M:OsiObject.canHandleShadowPrices">
Return true if knows how to deal with Pseudo Shadow Prices
</member>
        <member name="M:OsiObject.boundBranch">
\brief Return true if branch should only bound variables

</member>
        <member name="M:OsiObject.setPriority(System.Int32)">
Set priority
</member>
        <member name="M:OsiObject.priority">
Return Priority - note 1 is highest priority
</member>
        <member name="M:OsiObject.columnNumber">
Column number if single column object -1 otherwise,
      Used by heuristics

</member>
        <member name="M:OsiObject.canMoveToNearest">
\brief Return true if object can take part in move to nearest heuristic

</member>
        <member name="M:OsiObject.canDoHeuristics">
\brief Return true if object can take part in normal heuristics

</member>
        <member name="M:OsiObject.createBranch(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Create a branching object and indicate which way to branch first.
      
      The branching object has to know how to create branches (fix
      variables, etc.)

</member>
        <member name="M:OsiObject.feasibleRegion(OsiSolverInterface*,OsiBranchingInformation!System.Runtime.CompilerServices.IsConst*)">
For the variable(s) referenced by the object,
      look at the current solution and set bounds to match the solution.
      Returns measure of how much it had to move solution to make feasible
      Faster version

</member>
        <member name="M:OsiObject.feasibleRegion(OsiSolverInterface*)">
For the variable(s) referenced by the object,
      look at the current solution and set bounds to match the solution.
      Returns measure of how much it had to move solution to make feasible

</member>
        <member name="M:OsiObject.infeasibility(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Infeasibility of the object
      
    This is some measure of the infeasibility of the object. 0.0 
    indicates that the object is satisfied.
  
    The preferred branching direction is returned in whichWay, where for
    normal two-way branching 0 is down, 1 is up
  
    This is used to prepare for strong branching but should also think of
    case when no strong branching
  
    The object may also compute an estimate of cost of going "up" or "down".
    This will probably be based on pseudo-cost ideas

    This should also set mutable infeasibility_ and whichWay_
    This is for instant re-use for speed

    Default for this just calls infeasibility with OsiBranchingInformation
    NOTE - Convention says that an infeasibility of COIN_DBL_MAX means 
    object has worked out it can't be satisfied!

</member>
        <member name="M:OsiObject.Dispose">
Destructor
</member>
        <member name="M:OsiObject.clone">
Clone
</member>
        <member name="M:OsiObject.op_Assign(OsiObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:OsiObject.#ctor(OsiObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:OsiObject.#ctor">
Default Constructor
</member>
        <member name="T:OsiObject">
Abstract base class for `objects'.

  The branching model used in Osi is based on the idea of an <i>object</i>.
  In the abstract, an object is something that has a feasible region, can be
  evaluated for infeasibility, can be branched on (<i>i.e.</i>, there's some
  constructive action to be taken to move toward feasibility), and allows
  comparison of the effect of branching.

  This class (OsiObject) is the base class for an object. To round out the
  branching model, the class OsiBranchingObject describes how to perform a
  branch, and the class OsiBranchDecision describes how to compare two
  OsiBranchingObjects.

  To create a new type of object you need to provide three methods:
  #infeasibility(), #feasibleRegion(), and #createBranch(), described below.

  This base class is primarily virtual to allow for any form of structure.
  Any form of discontinuity is allowed.

  As there is an overhead in getting information from solvers and because
  other useful information is available there is also an OsiBranchingInformation 
  class which can contain pointers to information.
  If used it must at minimum contain pointers to current value of objective,
  maximum allowed objective and pointers to arrays for bounds and solution
  and direction of optimization.  Also integer and primal tolerance.
  
  Classes which inherit might have other information such as depth, number of
  solutions, pseudo-shadow prices etc etc.
  May be easier just to throw in here - as I keep doing

</member>
        <member name="F:ClpHashValue.lastUsed_">
Last used space
</member>
        <member name="F:ClpHashValue.maxHash_">
Maximum number of entries in hash table i.e. size
</member>
        <member name="F:ClpHashValue.numberHash_">
Number of entries in hash table
</member>
        <member name="F:ClpHashValue.hash_">
Hash table
</member>
        <member name="M:ClpHashValue.resize(System.Boolean)">
Resizes
</member>
        <member name="M:ClpHashValue.hash(System.Double)">
@name private stuff 
returns hash 
</member>
        <member name="M:ClpHashValue.op_Assign(ClpHashValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
=
</member>
        <member name="M:ClpHashValue.#ctor(ClpHashValue!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:ClpHashValue.Dispose">
Destructor 
</member>
        <member name="M:ClpHashValue.#ctor(ClpSimplex*)">
Useful constructor. 
</member>
        <member name="M:ClpHashValue.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpHashValue.numberEntries">
Number of different entries
</member>
        <member name="M:ClpHashValue.addValue(System.Double)">
Add value to list and return index
</member>
        <member name="M:ClpHashValue.index(System.Double)">
@name Useful methods 
Return index or -1 if not found
</member>
        <member name="F:ClpNodeStuff.nodeCalled_">
Node at which called
</member>
        <member name="F:ClpNodeStuff.startingDepth_">
Depth passed in
</member>
        <member name="F:ClpNodeStuff.presolveType_">
Type of presolve - 0 none, 1 crunch
</member>
        <member name="F:ClpNodeStuff.numberIterations_">
Number of iterations
</member>
        <member name="F:ClpNodeStuff.numberNodesExplored_">
Number of nodes explored
</member>
        <member name="F:ClpNodeStuff.nNodes_">
Number nodes returned (-1 if fathom aborted)
</member>
        <member name="F:ClpNodeStuff.nDepth_">
Number deep
</member>
        <member name="F:ClpNodeStuff.stateOfSearch_">
State of search from CbcModel
</member>
        <member name="F:ClpNodeStuff.numberBeforeTrust_">
Number before trust from CbcModel
</member>
        <member name="F:ClpNodeStuff.maximumNodes_">
Maximum number of nodes to do
</member>
        <member name="F:ClpNodeStuff.solverOptions_">
Options to pass to solver
         1 - create external reduced costs for columns
         2 - create external reduced costs for rows
         4 - create external row activity (columns always done)
         Above only done if feasible
         32 - just create up to nDepth_+1 nodes
         65536 - set if activated

</member>
        <member name="F:ClpNodeStuff.saveOptions_">
Save of specialOptions_ (local)
</member>
        <member name="F:ClpNodeStuff.nBound_">
Number bounds in large model
</member>
        <member name="F:ClpNodeStuff.handler_">
Cbc's message handler
</member>
        <member name="F:ClpNodeStuff.whichColumn_">
Which columns in large model
</member>
        <member name="F:ClpNodeStuff.whichRow_">
Which rows in large model
</member>
        <member name="F:ClpNodeStuff.large_">
Large model if crunched
</member>
        <member name="F:ClpNodeStuff.nodeInfo_">
Array of ClpNodes
</member>
        <member name="F:ClpNodeStuff.saveCosts_">
Copy of costs (local)
</member>
        <member name="F:ClpNodeStuff.numberUpInfeasible_">
Number of times up infeasible
</member>
        <member name="F:ClpNodeStuff.numberDownInfeasible_">
Number of times down infeasible
</member>
        <member name="F:ClpNodeStuff.numberUp_">
Number of times up
</member>
        <member name="F:ClpNodeStuff.numberDown_">
Number of times down
</member>
        <member name="F:ClpNodeStuff.priority_">
Priority
</member>
        <member name="F:ClpNodeStuff.upPseudo_">
Up pseudo costs
</member>
        <member name="F:ClpNodeStuff.downPseudo_">
Down pseudo costs
</member>
        <member name="F:ClpNodeStuff.smallChange_">
Small change in branch
</member>
        <member name="F:ClpNodeStuff.integerIncrement_">
Integer increment
</member>
        <member name="F:ClpNodeStuff.integerTolerance_">
@name Data 
Integer tolerance
</member>
        <member name="M:ClpNodeStuff.maximumSpace">
Return maximum space for nodes
</member>
        <member name="M:ClpNodeStuff.maximumNodes">
Return maximum number of nodes
</member>
        <member name="M:ClpNodeStuff.update(System.Int32,System.Int32,System.Double,System.Boolean)">
Update pseudo costs
</member>
        <member name="M:ClpNodeStuff.fillPseudoCosts(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32)">
@name Fill methods 
Fill with pseudocosts 
</member>
        <member name="M:ClpNodeStuff.zap(System.Int32)">
Zaps stuff 1 - arrays, 2 ints, 3 both
</member>
        <member name="M:ClpNodeStuff.op_Assign(ClpNodeStuff!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator =
</member>
        <member name="M:ClpNodeStuff.#ctor(ClpNodeStuff!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy methods (only copies ints etc, nulls arrays) 
The copy constructor. 
</member>
        <member name="M:ClpNodeStuff.Dispose">
Destructor 
</member>
        <member name="M:ClpNodeStuff.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="F:ClpNode.maximumIntegers_">
Maximum Integers so far
</member>
        <member name="F:ClpNode.maximumColumns_">
Maximum columns so far
</member>
        <member name="F:ClpNode.maximumRows_">
Maximum rows so far
</member>
        <member name="F:ClpNode.maximumFixed_">
Maximum number fixed by reduced cost
</member>
        <member name="F:ClpNode.flags_">
Flags - 1 duals scaled
</member>
        <member name="F:ClpNode.numberFixed_">
Number fixed by reduced cost
</member>
        <member name="F:ClpNode.depth_">
Relative depth
</member>
        <member name="F:ClpNode.numberInfeasibilities_">
Number of infeasibilities
</member>
        <member name="F:ClpNode.sequence_">
Sequence number of integer variable (-1 if none)
</member>
        <member name="F:ClpNode.branchState_">
State of branch
</member>
        <member name="F:ClpNode.fixed_">
Variables fixed by reduced costs (at end of branch) 0x10000000 added if fixed to UB
</member>
        <member name="F:ClpNode.pivotVariables_">
Pivot variables for factorization
</member>
        <member name="F:ClpNode.upper_">
Integer upper bounds (only used in fathomMany)
</member>
        <member name="F:ClpNode.lower_">
Integer lower bounds (only used in fathomMany)
</member>
        <member name="F:ClpNode.dualSolution_">
Dual solution
</member>
        <member name="F:ClpNode.primalSolution_">
Primal solution
</member>
        <member name="F:ClpNode.status_">
Status vector
</member>
        <member name="F:ClpNode.weights_">
Steepest edge weights
</member>
        <member name="F:ClpNode.factorization_">
Factorization
</member>
        <member name="F:ClpNode.estimatedSolution_">
Estimated solution value
</member>
        <member name="F:ClpNode.sumInfeasibilities_">
Sum of infeasibilities
</member>
        <member name="F:ClpNode.objectiveValue_">
Value of objective
</member>
        <member name="F:ClpNode.branchingValue_">
@name Data 
Initial value of integer variable
</member>
        <member name="M:ClpNode.op_Assign(ClpNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Operator =
</member>
        <member name="M:ClpNode.#ctor(ClpNode!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy methods (at present illegal - will abort) 
The copy constructor. 
</member>
        <member name="M:ClpNode.Dispose">
Destructor 
</member>
        <member name="M:ClpNode.gutsOfConstructor(ClpSimplex*,ClpNodeStuff!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Does work of constructor (partly so gdb will work)
</member>
        <member name="M:ClpNode.#ctor(ClpSimplex*,ClpNodeStuff!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Constructor from model
</member>
        <member name="M:ClpNode.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpNode.statusArray">
Status array
</member>
        <member name="M:ClpNode.oddArraysExist">
If odd arrays exist
</member>
        <member name="M:ClpNode.sequence">
Sequence number of integer variable (-1 if none)
</member>
        <member name="M:ClpNode.changeState">
Change state of variable i.e. go other way
</member>
        <member name="M:ClpNode.fathomed">
Return true if branch exhausted
</member>
        <member name="M:ClpNode.way">
Way for integer variable -1 down , +1 up 
</member>
        <member name="M:ClpNode.estimatedSolution">
Estimated solution value
</member>
        <member name="M:ClpNode.depth">
Relative depth
</member>
        <member name="M:ClpNode.numberInfeasibilities">
Number infeasibilities
</member>
        <member name="M:ClpNode.sumInfeasibilities">
Sum infeasibilities
</member>
        <member name="M:ClpNode.branchingValue">
Initial value of integer variable
</member>
        <member name="M:ClpNode.dualSolution">
Dual solution
</member>
        <member name="M:ClpNode.primalSolution">
Primal solution
</member>
        <member name="M:ClpNode.setObjectiveValue(System.Double)">
Set objective value
</member>
        <member name="M:ClpNode.objectiveValue">
@name Gets and sets 
Objective value
</member>
        <member name="M:ClpNode.cleanUpForCrunch">
Clean up as crunch is different model
</member>
        <member name="M:ClpNode.createArrays(ClpSimplex*)">
Create odd arrays
</member>
        <member name="M:ClpNode.fixOnReducedCosts(ClpSimplex*)">
Fix on reduced costs
</member>
        <member name="M:ClpNode.chooseVariable(ClpSimplex*,ClpNodeStuff*)">
Choose a new variable
</member>
        <member name="M:ClpNode.applyNode(ClpSimplex*,System.Int32)">
@name Useful methods 
Applies node to model
         0 - just tree bounds
         1 - tree bounds and basis etc
         2 - saved bounds and basis etc

</member>
        <member name="T:ClpFactorization">
This contains what is in a Clp "node"



This just implements CoinFactorization when an ClpMatrixBase object
    is passed.  If a network then has a dummy CoinFactorization and
    a genuine ClpNetworkBasis object

</member>
        <member name="F:ClpDisasterHandler.model_">
@name Data members
        The data members are protected to allow access for derived classes. 
Pointer to simplex
</member>
        <member name="M:ClpDisasterHandler.simplex">
Get model
</member>
        <member name="M:ClpDisasterHandler.setSimplex(ClpSimplex*)">
@name Sets/gets 
set model. 
</member>
        <member name="M:ClpDisasterHandler.clone">
Clone
</member>
        <member name="M:ClpDisasterHandler.Dispose">
Destructor 
</member>
        <member name="M:ClpDisasterHandler.#ctor(ClpSimplex*)">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpDisasterHandler.typeOfDisaster">
Type of disaster 0 can fix, 1 abort
</member>
        <member name="M:ClpDisasterHandler.saveInfo">
saves information for next attempt
</member>
        <member name="M:ClpDisasterHandler.check">
Checks if disaster
</member>
        <member name="M:ClpDisasterHandler.intoSimplex">
@name Virtual methods that the derived classe should provide.

Into simplex
</member>
        <member name="T:ClpDisasterHandler">
Base class for Clp disaster handling

This is here to allow for disaster handling.  By disaster I mean that Clp
would otherwise give up


</member>
        <member name="F:ClpEventHandler.model_">
@name Data members
        The data members are protected to allow access for derived classes. 
Pointer to simplex
</member>
        <member name="M:ClpEventHandler.simplex">
Get model
</member>
        <member name="M:ClpEventHandler.setSimplex(ClpSimplex*)">
@name Sets/gets 
set model. 
</member>
        <member name="M:ClpEventHandler.clone">
Clone
</member>
        <member name="M:ClpEventHandler.Dispose">
Destructor 
</member>
        <member name="M:ClpEventHandler.#ctor(ClpSimplex*)">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpEventHandler.eventWithInfo(ClpEventHandler.Event,System.Void*)">
This can do whatever it likes.  Return code -1 means no action.
	 This passes in something

</member>
        <member name="T:ClpEventHandler.Event">
enums for what sort of event.

         These will also be returned in ClpModel::secondaryStatus() as int

</member>
        <member name="T:ClpEventHandler">
Base class for Clp event handling

This is just here to allow for event handling.  By event I mean a Clp event
e.g. end of values pass.

One use would be to let a user handle a system event e.g. Control-C.  This could be done
by deriving a class MyEventHandler which knows about such events.  If one occurs
MyEventHandler::event() could clear event status and return 3 (stopped).

Clp would then return to user code.

As it is called every iteration this should be fine grained enough.

User can derive and construct from CbcModel  - not pretty


</member>
        <member name="M:charToStatus(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte)">
Convert character to status
</member>
        <member name="M:statusToChar(CoinWarmStartBasis.Status)">
In an example Aleksandr Kazachkov sent to me, I noticed he was
      using code as above but with char - it seemed useful
      B, F, U, L, S (S - SuperBasic)

Convert status to character.
</member>
        <member name="F:CoinWarmStartBasis.artificialStatus_">
The status of the artificial variables. 
</member>
        <member name="F:CoinWarmStartBasis.structuralStatus_">
The status of the structural variables. 
</member>
        <member name="F:CoinWarmStartBasis.maxSize_">
The maximum sise (in ints - actually 4*char) (so resize does not need to do new)
</member>
        <member name="F:CoinWarmStartBasis.numArtificial_">
The number of artificial variables
</member>
        <member name="F:CoinWarmStartBasis.numStructural_">
\name Protected data members

    \sa CoinWarmStartBasis::Status for a description of the packing used in
    the status arrays.

The number of structural variables
</member>
        <member name="M:CoinWarmStartBasis.fixFullBasis">
Returns true if full basis and fixes up (for debug)
</member>
        <member name="M:CoinWarmStartBasis.fullBasis">
Returns true if full basis (for debug)
</member>
        <member name="M:CoinWarmStartBasis.print">
Prints in readable format (for debug)
</member>
        <member name="M:CoinWarmStartBasis.op_Assign(CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment 
</member>
        <member name="M:CoinWarmStartBasis.Dispose">
Destructor 
</member>
        <member name="M:CoinWarmStartBasis.clone">
`Virtual constructor' 
</member>
        <member name="M:CoinWarmStartBasis.#ctor(CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor 
</member>
        <member name="M:CoinWarmStartBasis.#ctor">
Default constructor

    Creates a warm start object representing an empty basis
    (0 rows, 0 columns).

</member>
        <member name="M:CoinWarmStartBasis.mergeBasis(CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,std.vector&lt;CoinTriple&lt;System.Int32,System.Int32,System.Int32&gt;,std.allocator&lt;CoinTriple&lt;System.Int32,System.Int32,System.Int32&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*,std.vector&lt;CoinTriple&lt;System.Int32,System.Int32,System.Int32&gt;,std.allocator&lt;CoinTriple&lt;System.Int32,System.Int32,System.Int32&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*)">
\brief Merge entries from a source basis into this basis.

    \warning
    It's the client's responsibility to ensure validity of the merged basis,
    if that's important to the application.

    The vector xferCols (xferRows) specifies runs of entries to be taken from
    the source basis and placed in this basis. Each entry is a CoinTriple,
    with first specifying the starting source index of a run, second
    specifying the starting destination index, and third specifying the run
    length.

</member>
        <member name="M:CoinWarmStartBasis.deleteColumns(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
\brief Delete a set of columns from the basis

    \warning
    The resulting basis is guaranteed valid only if all deleted variables
    are nonbasic.

    Removal of a basic variable implies that some nonbasic variable must be
    made basic. This correction is left to the client.

</member>
        <member name="M:CoinWarmStartBasis.deleteRows(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
\brief Delete a set of rows from the basis

    \warning
    The resulting basis is guaranteed valid only if all deleted
    constraints are slack (hence the associated logicals are basic).

    Removal of a tight constraint with a nonbasic logical implies that
    some basic variable must be made nonbasic. This correction is left to
    the client.

</member>
        <member name="M:CoinWarmStartBasis.compressRows(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
\brief Delete a set of rows from the basis

    \warning
    This routine assumes that the set of indices to be deleted is sorted in
    ascending order and contains no duplicates. Use deleteRows() if this is
    not the case.

    \warning
    The resulting basis is guaranteed valid only if all deleted
    constraints are slack (hence the associated logicals are basic).

    Removal of a tight constraint with a nonbasic logical implies that
    some basic variable must be made nonbasic. This correction is left to
    the client.

</member>
        <member name="M:CoinWarmStartBasis.setArtifStatus(System.Int32,CoinWarmStartBasis.Status)">
Set the status of the specified artificial variable.
</member>
        <member name="M:CoinWarmStartBasis.getArtifStatus(System.Int32)">
Return the status of the specified artificial variable.
</member>
        <member name="M:CoinWarmStartBasis.getArtificialStatus">
As for \link getStructuralStatus() getStructuralStatus \endlink,
      but returns the status array for the artificial variables.


\c const overload for
    \link CoinWarmStartBasis::getArtificialStatus()
    	  getArtificialStatus()
    \endlink

</member>
        <member name="M:CoinWarmStartBasis.getStructuralStatus">
Return the status array for the structural variables
  
    The status information is stored using the codes defined in the
    Status enum, 2 bits per variable, packed 4 variables per byte.


\c const overload for
    \link CoinWarmStartBasis::getStructuralStatus()
    	  getStructuralStatus()
    \endlink

</member>
        <member name="M:CoinWarmStartBasis.setStructStatus(System.Int32,CoinWarmStartBasis.Status)">
Set the status of the specified structural variable.
</member>
        <member name="M:CoinWarmStartBasis.getStructStatus(System.Int32)">
Return the status of the specified structural variable.
</member>
        <member name="M:CoinWarmStartBasis.numberBasicStructurals">
Return the number of basic structurals
  
    A fast test for an all-slack basis.

</member>
        <member name="M:CoinWarmStartBasis.getNumArtificial">
Return the number of artificial variables
</member>
        <member name="M:CoinWarmStartBasis.getNumStructural">
Return the number of structural variables
</member>
        <member name="D:CoinWarmStartBasis.XferVec">
\brief Transfer vector for
	 mergeBasis(const CoinWarmStartBasis*,const XferVec*,const XferVec*)

</member>
        <member name="D:CoinWarmStartBasis.XferEntry">
\brief Transfer vector entry for
	 mergeBasis(const CoinWarmStartBasis*,const XferVec*,const XferVec*)

</member>
        <member name="F:ClpLinearObjective.numberColumns_">
number of columns
</member>
        <member name="F:ClpLinearObjective.objective_">
@name Private member data
Objective
</member>
        <member name="M:ClpLinearObjective.subsetClone(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset clone.  Duplicates are allowed
         and order is as given.

</member>
        <member name="M:ClpLinearObjective.clone">
Clone
</member>
        <member name="M:ClpLinearObjective.Dispose">
Destructor
</member>
        <member name="M:ClpLinearObjective.op_Assign(ClpLinearObjective!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:ClpLinearObjective.#ctor(ClpLinearObjective!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset constructor.  Duplicates are allowed
         and order is as given.

</member>
        <member name="M:ClpLinearObjective.#ctor(ClpLinearObjective!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:ClpLinearObjective.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Constructor from objective
</member>
        <member name="M:ClpLinearObjective.#ctor">
@name Constructors and destructors
Default Constructor
</member>
        <member name="M:ClpLinearObjective.reallyScale(System.Double!System.Runtime.CompilerServices.IsConst*)">
Scale objective
</member>
        <member name="M:ClpLinearObjective.deleteSome(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete columns in  objective
</member>
        <member name="M:ClpLinearObjective.resize(System.Int32)">
Resize objective
</member>
        <member name="M:ClpLinearObjective.objectiveValue(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Return objective value (without any ClpModel offset) (model may be NULL)
</member>
        <member name="M:ClpLinearObjective.stepLength(ClpSimplex*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns step length which gives minimum of objective for
         solution + theta * change vector up to maximum theta.

         arrays are numberColumns+numberRows
         Also sets current objective, predicted and at maximumTheta

</member>
        <member name="M:ClpLinearObjective.reducedGradient(ClpSimplex*,System.Double*,System.Boolean)">
Returns reduced gradient.Returns an offset (to be added to current one).

</member>
        <member name="M:ClpLinearObjective.gradient(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Int32)">
@name Stuff
Returns objective coefficients.
       
       Offset is always set to 0.0. All other parameters unused.

</member>
        <member name="T:ClpLinearObjective">
Linear Objective Class


</member>
        <member name="M:ClpSimplexUnitTest(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
A function that tests the methods in the ClpSimplex class. The
    only reason for it not to be a member method is that this way it doesn't
    have to be compiled into the library. And that's a gain, because the
    library should be compiled with optimization on, but this method should be
    compiled with debugging.

    It also does some testing of ClpFactorization class

</member>
        <member name="T:OsiCLPSolverInterface">
And OsiCLP
</member>
        <member name="T:OsiClpSolverInterface">
Allow OsiClp certain perks

Clp Solver Interface
    
Instantiation of OsiClpSolverInterface for the Model Algorithm.


</member>
        <member name="F:ClpSimplex.spareDoubleArray_">
Spare double array for passing information [0]!=0 switches on
</member>
        <member name="F:ClpSimplex.spareIntArray_">
Spare int array for passing information [0]!=0 switches on
</member>
        <member name="F:ClpSimplex.numberDegeneratePivots_">
Number of degenerate pivots since last perturbed
</member>
        <member name="F:ClpSimplex.progress_">
For dealing with all issues of cycling etc
</member>
        <member name="F:ClpSimplex.baseModel_">
A copy of model with certain state - normally without cuts
</member>
        <member name="F:ClpSimplex.perturbationArray_">
Perturbation array (maximumPerturbationSize_)
</member>
        <member name="F:ClpSimplex.maximumPerturbationSize_">
Maximum perturbation array size (take out when code rewritten)
</member>
        <member name="F:ClpSimplex.automaticScale_">
Automatic scaling of objective and rhs and bounds
</member>
        <member name="F:ClpSimplex.dontFactorizePivots_">
If may skip final factorize then allow up to this pivots (default 20)
</member>
        <member name="F:ClpSimplex.maximumBasic_">
Maximum number of basic variables - can be more than number of rows if GUB

</member>
        <member name="F:ClpSimplex.numberExtraRows_">
Number of extra rows.  These are ones which will be dynamically created
         each iteration.  This is for GUB but may have other uses.

</member>
        <member name="F:ClpSimplex.firstFree_">
First free/super-basic variable (-1 if none)
</member>
        <member name="F:ClpSimplex.progressFlag_">
Progress flag - at present 0 bit says artificials out, 1 free in
</member>
        <member name="F:ClpSimplex.numberChanged_">
Can be used for count of changed costs (dual) or changed bounds (primal)
</member>
        <member name="F:ClpSimplex.numberFake_">
Can be used for count of fake bounds (dual) or fake costs (primal)
</member>
        <member name="F:ClpSimplex.lastFlaggedIteration_">
So we know when to open up again
</member>
        <member name="F:ClpSimplex.lastBadIteration_">
So we know when to be cautious
</member>
        <member name="F:ClpSimplex.nonLinearCost_">
Very wasteful way of dealing with infeasibilities in primal.
         However it will allow non-linearities and use of dual
         analysis.  If it doesn't work it can easily be replaced.

</member>
        <member name="F:ClpSimplex.saveStatus_">
Saved status regions
</member>
        <member name="F:ClpSimplex.perturbation_">
Perturbation:
         -50 to +50 - perturb by this power of ten (-6 sounds good)
         100 - auto perturb if takes too long (1.0e-6 largest nonzero)
         101 - we are perturbed
         102 - don't try perturbing again
         default is 100

</member>
        <member name="F:ClpSimplex.forceFactorization_">
Now for some reliability aids
         This forces re-factorization early 
</member>
        <member name="F:ClpSimplex.changeMade_">
If change has been made (first attempt at stopping looping)
</member>
        <member name="F:ClpSimplex.disasterArea_">
Disaster handler
</member>
        <member name="F:ClpSimplex.numberTimesOptimal_">
Number of times code has tentatively thought optimal
</member>
        <member name="F:ClpSimplex.savedSolution_">
Saved version of solution
</member>
        <member name="F:ClpSimplex.factorization_">
factorization
</member>
        <member name="F:ClpSimplex.pivotVariable_">
Basic variables pivoting on which rows
</member>
        <member name="F:ClpSimplex.primalColumnPivot_">
primal column pivot choice
</member>
        <member name="F:ClpSimplex.dualRowPivot_">
dual row pivot choice
</member>
        <member name="F:ClpSimplex.numberRefinements_">
How many iterative refinements to do
</member>
        <member name="F:ClpSimplex.numberPrimalInfeasibilities_">
Number of primal infeasibilities
</member>
        <member name="F:ClpSimplex.numberDualInfeasibilitiesWithoutFree_">
Number of dual infeasibilities (without free)
</member>
        <member name="F:ClpSimplex.numberDualInfeasibilities_">
Number of dual infeasibilities
</member>
        <member name="F:ClpSimplex.columnActivityWork_">
Column activities - working copy
</member>
        <member name="F:ClpSimplex.rowActivityWork_">
Row activities - working copy
</member>
        <member name="F:ClpSimplex.solution_">
Working copy of primal solution (Owner of arrays below)
</member>
        <member name="F:ClpSimplex.reducedCostWork_">
Possible scaled reduced costs
</member>
        <member name="F:ClpSimplex.rowReducedCost_">
Reduced costs of slacks not same as duals (or - duals)
</member>
        <member name="F:ClpSimplex.dj_">
Working copy of reduced costs (Owner of arrays below)
</member>
        <member name="F:ClpSimplex.lastGoodIteration_">
Last good iteration (immediately after a re-factorization)
</member>
        <member name="F:ClpSimplex.pivotRow_">
Pivot Row
</member>
        <member name="F:ClpSimplex.directionOut_">
Direction of Out, 1 to upper bound, -1 to lower bound, 0 - superbasic
</member>
        <member name="F:ClpSimplex.sequenceOut_">
Sequence of Out variable
</member>
        <member name="F:ClpSimplex.directionIn_">
Direction of In, 1 going up, -1 going down, 0 not a clue
</member>
        <member name="F:ClpSimplex.sequenceIn_">
Sequence of In variable
</member>
        <member name="F:ClpSimplex.columnArray_">
Useful column length arrays
</member>
        <member name="F:ClpSimplex.rowArray_">
Useful row length arrays
</member>
        <member name="F:ClpSimplex.objectiveWork_">
Column objective - working copy
</member>
        <member name="F:ClpSimplex.rowObjectiveWork_">
Row objective - working copy
</member>
        <member name="F:ClpSimplex.cost_">
Working copy of objective (Owner of arrays below)
</member>
        <member name="F:ClpSimplex.columnUpperWork_">
Column upper bounds - working copy
</member>
        <member name="F:ClpSimplex.rowUpperWork_">
Row upper bounds - working copy
</member>
        <member name="F:ClpSimplex.upper_">
Working copy of upper bounds (Owner of arrays below)
</member>
        <member name="F:ClpSimplex.columnLowerWork_">
Column lower bounds - working copy
</member>
        <member name="F:ClpSimplex.rowLowerWork_">
Row lower bounds - working copy
</member>
        <member name="F:ClpSimplex.lower_">
Working copy of lower bounds (Owner of arrays below)
</member>
        <member name="F:ClpSimplex.averageInfeasibility_">
Last few infeasibilities
</member>
        <member name="F:ClpSimplex.minimumPrimalTolerance_">
Minimum primal tolerance
</member>
        <member name="F:ClpSimplex.acceptablePivot_">
Acceptable pivot value just after factorization
</member>
        <member name="F:ClpSimplex.sumOfRelaxedPrimalInfeasibilities_">
Sum of Primal infeasibilities using tolerance based on error in primals
</member>
        <member name="F:ClpSimplex.sumOfRelaxedDualInfeasibilities_">
Sum of Dual infeasibilities using tolerance based on error in duals
</member>
        <member name="F:ClpSimplex.infeasibilityCost_">
Weight assigned to being infeasible in primal
</member>
        <member name="F:ClpSimplex.sumPrimalInfeasibilities_">
Sum of primal infeasibilities
</member>
        <member name="F:ClpSimplex.sumDualInfeasibilities_">
Sum of dual infeasibilities
</member>
        <member name="F:ClpSimplex.primalTolerance_">
Current primal tolerance for algorithm
</member>
        <member name="F:ClpSimplex.dualTolerance_">
Current dual tolerance for algorithm
</member>
        <member name="F:ClpSimplex.dualOut_">
Infeasibility (dual) or ? (primal) of Out variable
</member>
        <member name="F:ClpSimplex.upperOut_">
Upper Bound on Out variable
</member>
        <member name="F:ClpSimplex.valueOut_">
Value of Out variable
</member>
        <member name="F:ClpSimplex.lowerOut_">
Lower Bound on Out variable
</member>
        <member name="F:ClpSimplex.dualIn_">
Reduced cost of In variable
</member>
        <member name="F:ClpSimplex.upperIn_">
Upper Bound on In variable
</member>
        <member name="F:ClpSimplex.valueIn_">
Value of In variable
</member>
        <member name="F:ClpSimplex.lowerIn_">
Lower Bound on In variable
</member>
        <member name="F:ClpSimplex.theta_">
Theta (pivot change)
</member>
        <member name="F:ClpSimplex.alpha_">
Alpha (pivot element)
</member>
        <member name="F:ClpSimplex.dualBound_">
Dual bound
</member>
        <member name="F:ClpSimplex.alphaAccuracy_">
For computing whether to re-factorize
</member>
        <member name="F:ClpSimplex.largestDualError_">
Largest error on basic duals
</member>
        <member name="F:ClpSimplex.largestPrimalError_">
Largest error on Ax-b
</member>
        <member name="F:ClpSimplex.largeValue_">
Large bound value (for complementarity etc)
</member>
        <member name="F:ClpSimplex.vectorMode_">
Vector mode - try and use vector instructions
</member>
        <member name="F:ClpSimplex.baseIteration_">
Iteration when we entered dual or primal
</member>
        <member name="F:ClpSimplex.moreSpecialOptions_">
More special options - see set for details
</member>
        <member name="F:ClpSimplex.bestObjectiveValue_">
"Best" objective value
</member>
        <member name="F:ClpSimplex.rowPrimalSequence_">
Sequence of worst (-1 if feasible)
</member>
        <member name="F:ClpSimplex.columnPrimalSequence_">
Sequence of worst (-1 if feasible)
</member>
        <member name="F:ClpSimplex.zeroTolerance_">
Zero tolerance
</member>
        <member name="F:ClpSimplex.bestPossibleImprovement_">
@name data.  Many arrays have a row part and a column part.
      There is a single array with both - columns then rows and
      then normally two arrays pointing to rows and columns.  The
      single array is the owner of memory

Best possible improvement using djs (primal) or
         obj change by flipping bounds to make dual feasible (dual) 
</member>
        <member name="M:ClpSimplex.resize(System.Int32,System.Int32)">
Resizes rim part of model
</member>
        <member name="M:ClpSimplex.setRowBounds(System.Int32,System.Double,System.Double)">
Set a single row lower and upper bound 
</member>
        <member name="M:ClpSimplex.setColBounds(System.Int32,System.Double,System.Double)">
Set a single column lower and upper bound 
</member>
        <member name="M:ClpSimplex.setColumnBounds(System.Int32,System.Double,System.Double)">
Set a single column lower and upper bound 
</member>
        <member name="M:ClpSimplex.setObjCoeff(System.Int32,System.Double)">
Set an objective function coefficient 
</member>
        <member name="M:ClpSimplex.setObjectiveCoefficient(System.Int32,System.Double)">
@name Changing bounds on variables and constraints 
Set an objective function coefficient 
</member>
        <member name="M:ClpSimplex.getBasics(System.Int32*)">
Get basic indices (order of indices corresponds to the
         order of elements in a vector retured by getBInvACol() and
         getBInvCol()).

</member>
        <member name="M:ClpSimplex.getBInvCol(System.Int32,System.Double*)">
Get a column of the basis inverse
</member>
        <member name="M:ClpSimplex.getBInvACol(System.Int32,System.Double*)">
Get a column of the tableau
</member>
        <member name="M:ClpSimplex.getBInvRow(System.Int32,System.Double*)">
Get a row of the basis inverse
</member>
        <member name="M:ClpSimplex.getBInvARow(System.Int32,System.Double*,System.Double*)">
@name Basis handling
Get a row of the tableau (slack part in slack if not NULL)
</member>
        <member name="M:ClpSimplex.moveInfo(ClpSimplex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Move status and solution across
</member>
        <member name="M:ClpSimplex.setEmptyFactorization">
May delete or may make clean and emptyish factorization
</member>
        <member name="M:ClpSimplex.getEmptyFactorization">
Gets clean and emptyish factorization
</member>
        <member name="M:ClpSimplex.generateCpp(_iobuf*,System.Boolean)">
Create C++ lines to get to current state
</member>
        <member name="M:ClpSimplex.baseIteration">
Iteration when we entered dual or primal
</member>
        <member name="M:ClpSimplex.maximumBasic">
Maximum number of basic variables - can be more than number of rows if GUB

</member>
        <member name="M:ClpSimplex.numberExtraRows">
Number of extra rows.  These are ones which will be dynamically created
         each iteration.  This is for GUB but may have other uses.

</member>
        <member name="M:ClpSimplex.infeasibilityRay(System.Boolean)">
Infeasibility/unbounded ray (NULL returned if none/wrong)
         Up to user to use delete [] on these arrays.  
</member>
        <member name="M:ClpSimplex.computeInternalObjectiveValue">
Compute minimization objective value from internal solution without perturbation
</member>
        <member name="M:ClpSimplex.computeObjectiveValue(System.Boolean)">
Compute objective value from solution and put in objectiveValue_
</member>
        <member name="M:ClpSimplex.rawObjectiveValue">
Raw objective value (so always minimize in primal)
</member>
        <member name="M:ClpSimplex.forceFactorization(System.Int32)">
Force re-factorization early
</member>
        <member name="M:ClpSimplex.forceFactorization">
Force re-factorization early value
</member>
        <member name="M:ClpSimplex.progress">
For dealing with all issues of cycling etc
</member>
        <member name="M:ClpSimplex.progressFlag">
Progress flag - at present 0 bit says artificials out
</member>
        <member name="M:ClpSimplex.setLastBadIteration(System.Int32)">
Set so we know when to be cautious
</member>
        <member name="M:ClpSimplex.lastBadIteration">
So we know when to be cautious
</member>
        <member name="M:ClpSimplex.allSlackBasis(System.Boolean)">
Sets up all slack basis and resets solution to
         as it was after initial load or readMps 
</member>
        <member name="M:ClpSimplex.createStatus">
Set up status array (can be used by OsiClp).
         Also can be used to set up all slack basis 
</member>
        <member name="M:ClpSimplex.setPerturbed(System.Int32)">
To say perturbed
</member>
        <member name="M:ClpSimplex.setActive(System.Int32)">
To say row active in primal pivot row choice
</member>
        <member name="M:ClpSimplex.setFlagged(System.Int32)">
To flag a variable (not inline to allow for column generation)
</member>
        <member name="M:ClpSimplex.setFakeBound(System.Int32,ClpSimplex.FakeBound)">
@name status methods 
</member>
        <member name="M:ClpSimplex.setVectorMode(System.Int32)">
Set vector mode
</member>
        <member name="M:ClpSimplex.vectorMode">
Get vector mode
</member>
        <member name="M:ClpSimplex.setNonLinearCost(ClpNonLinearCost*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set pointer to details of costs
</member>
        <member name="M:ClpSimplex.nonLinearCost">
Return pointer to details of costs
</member>
        <member name="M:ClpSimplex.bestPossibleImprovement">
Best possible improvement using djs (primal) or
         obj change by flipping bounds to make dual feasible (dual) 
</member>
        <member name="M:ClpSimplex.upperIn">
Upper Bound on In variable
</member>
        <member name="M:ClpSimplex.valueIn">
Value of In variable
</member>
        <member name="M:ClpSimplex.lowerIn">
Lower Bound on In variable
</member>
        <member name="M:ClpSimplex.theta">
Theta (pivot change)
</member>
        <member name="M:ClpSimplex.originalUpper(System.Int32)">
Return original lower bound
</member>
        <member name="M:ClpSimplex.originalLower(System.Int32)">
Return original lower bound
</member>
        <member name="M:ClpSimplex.costAddress(System.Int32)">
Return address of row or column cost
</member>
        <member name="M:ClpSimplex.upperAddress(System.Int32)">
Return address of row or column upper bound
</member>
        <member name="M:ClpSimplex.lowerAddress(System.Int32)">
Return address of row or column lower bound
</member>
        <member name="M:ClpSimplex.solutionAddress(System.Int32)">
Return address of row or column values
</member>
        <member name="M:ClpSimplex.solution(System.Int32)">
Return row or column values
</member>
        <member name="M:ClpSimplex.sequenceWithin(System.Int32)">
Returns sequence number within section
</member>
        <member name="M:ClpSimplex.isColumn(System.Int32)">
Returns 1 if sequence indicates column
</member>
        <member name="M:ClpSimplex.setTheta(System.Double)">
Set theta of out variable
</member>
        <member name="M:ClpSimplex.setUpperOut(System.Double)">
Set upper of out variable
</member>
        <member name="M:ClpSimplex.setLowerOut(System.Double)">
Set lower of out variable
</member>
        <member name="M:ClpSimplex.setDualOut(System.Double)">
Set dual value of out variable
</member>
        <member name="M:ClpSimplex.dualOut">
Dual value of Out variable
</member>
        <member name="M:ClpSimplex.setValueOut(System.Double)">
Set value of out variable
</member>
        <member name="M:ClpSimplex.upperOut">
Upper of out variable
</member>
        <member name="M:ClpSimplex.lowerOut">
Lower of out variable
</member>
        <member name="M:ClpSimplex.valueOut">
Value of Out variable
</member>
        <member name="M:ClpSimplex.setDirectionIn(System.Int32)">
Set directionIn or Out 
</member>
        <member name="M:ClpSimplex.directionIn">
Return direction In or Out 
</member>
        <member name="M:ClpSimplex.setSequenceIn(System.Int32)">
Set sequenceIn or Out 
</member>
        <member name="M:ClpSimplex.sequenceIn">
Return sequence In or Out 
</member>
        <member name="M:ClpSimplex.setInitialDenseFactorization(System.Boolean)">
Normally the first factorization does sparse coding because
         the factorization could be singular.  This allows initial dense
         factorization when it is known to be safe

</member>
        <member name="M:ClpSimplex.startPermanentArrays">
Start or reset using maximumRows_ and Columns_ - true if change
</member>
        <member name="M:ClpSimplex.solutionRegion">
Return region as single array
</member>
        <member name="M:ClpSimplex.solutionRegion(System.Int32)">
@name public methods 
Return row or column sections - not as much needed as it
         once was.  These just map into single arrays 
</member>
        <member name="M:ClpSimplex.sanityCheck">
Sanity check on input rim data (after scaling) - returns true if okay
</member>
        <member name="M:ClpSimplex.deleteRim(System.Int32)">
releases above arrays and does solution scaling out.  May also
         get rid of factorization data -
         0 get rid of nothing, 1 get rid of arrays, 2 also factorization

</member>
        <member name="M:ClpSimplex.createRim5(System.Boolean)">
Does rows and columns and objective
</member>
        <member name="M:ClpSimplex.createRim4(System.Boolean)">
Does objective
</member>
        <member name="M:ClpSimplex.createRim1(System.Boolean)">
Does rows and columns
</member>
        <member name="M:ClpSimplex.createRim(System.Int32,System.Boolean,System.Int32)">
puts in format I like (rowLower,rowUpper) also see StandardMatrix
         1 bit does rows (now and columns), (2 bit does column bounds), 4 bit does objective(s).
         8 bit does solution scaling in
         16 bit does rowArray and columnArray indexed vectors
         and makes row copy if wanted, also sets columnStart_ etc
         Also creates scaling arrays if needed.  It does scaling if needed.
         16 also moves solutions etc in to work arrays
         On 16 returns false if problem "bad" i.e. matrix or bounds bad
         If startFinishOptions is -1 then called by user in getSolution
         so do arrays but keep pivotVariable_

</member>
        <member name="M:ClpSimplex.gutsOfCopy(ClpSimplex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Does most of copying
</member>
        <member name="M:ClpSimplex.gutsOfDelete(System.Int32)">
Does most of deletion (0 = all, 1 = most, 2 most + factorization)
</member>
        <member name="M:ClpSimplex.gutsOfSolution(System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
@name protected methods 
May change basis and then returns number changed.
         Computation of solutions may be overriden by given pi and solution

</member>
        <member name="M:ClpSimplex.valueIncomingDual">
value of incoming variable (in Dual)
</member>
        <member name="M:ClpSimplex.pivotRow">
Pivot Row for use by classes e.g. steepestedge
</member>
        <member name="M:ClpSimplex.setDualIn(System.Double)">
Set reduced cost of last incoming to force error
</member>
        <member name="M:ClpSimplex.dualIn">
Reduced cost of last incoming for use by classes e.g. steepestedge
</member>
        <member name="M:ClpSimplex.alpha">
Alpha (pivot element) for use by classes e.g. steepestedge
</member>
        <member name="M:ClpSimplex.numberRefinements">
How many iterative refinements to do
</member>
        <member name="M:ClpSimplex.currentPrimalTolerance">
Current primal tolerance
</member>
        <member name="M:ClpSimplex.currentDualTolerance">
Current dual tolerance
</member>
        <member name="M:ClpSimplex.automaticScaling">
If automatic scaling on
</member>
        <member name="M:ClpSimplex.pivotVariable">
Basic variables pivoting on which rows
</member>
        <member name="M:ClpSimplex.setZeroTolerance(System.Double)">
Set zero tolerance
</member>
        <member name="M:ClpSimplex.zeroTolerance">
Get zero tolerance
</member>
        <member name="M:ClpSimplex.setLargestDualError(System.Double)">
Largest error on basic duals
</member>
        <member name="M:ClpSimplex.setLargestPrimalError(System.Double)">
Largest error on Ax-b
</member>
        <member name="M:ClpSimplex.largestDualError">
Largest error on basic duals
</member>
        <member name="M:ClpSimplex.largestPrimalError">
Largest error on Ax-b
</member>
        <member name="M:ClpSimplex.largeValue">
Large bound value (for complementarity etc)
</member>
        <member name="M:ClpSimplex.disasterHandler">
Get disaster handler
</member>
        <member name="M:ClpSimplex.setDisasterHandler(ClpDisasterHandler*)">
Objective value
Set disaster handler
</member>
        <member name="M:ClpSimplex.alphaAccuracy">
@name most useful gets and sets 
Initial value for alpha accuracy calculation (-1.0 off)
</member>
        <member name="M:ClpSimplex.cleanFactorization(System.Int32)">
Get a clean factorization - i.e. throw out singularities
	 may do more later 
</member>
        <member name="M:ClpSimplex.solveBenders(CoinStructuredModel*,ClpSolve*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Solve using Benders decomposition and maybe in parallel
</member>
        <member name="M:ClpSimplex.solveDW(CoinStructuredModel*,ClpSolve*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Solve using Dantzig-Wolfe decomposition and maybe in parallel
</member>
        <member name="M:ClpSimplex.checkBothSolutions">
This sets sum and number of infeasibilities (Dual and Primal) 
</member>
        <member name="M:ClpSimplex.checkDualSolution">
This sets largest infeasibility and most infeasible and sum
         and number of infeasibilities (Dual) 
</member>
        <member name="M:ClpSimplex.checkPrimalSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
This sets largest infeasibility and most infeasible and sum
         and number of infeasibilities (Primal) 
</member>
        <member name="M:ClpSimplex.housekeeping(System.Double)">
This does basis housekeeping and does values for in/out variables.
Can also decide to re-factorize

</member>
        <member name="M:ClpSimplex.unpackPacked(CoinIndexedVector*,System.Int32)">
Unpacks one column of the matrix into indexed array
** as packed vector
Slack if sequence&gt;= numberColumns
Also applies scaling if needed

</member>
        <member name="M:ClpSimplex.unpackPacked(CoinIndexedVector*)">
Unpacks one column of the matrix into indexed array
** as packed vector
Uses sequenceIn_
Also applies scaling if needed

</member>
        <member name="M:ClpSimplex.unpack(CoinIndexedVector*,System.Int32)">
Unpacks one column of the matrix into indexed array
Slack if sequence&gt;= numberColumns
Also applies scaling if needed

</member>
        <member name="M:ClpSimplex.unpack(CoinIndexedVector*)">
Unpacks one column of the matrix into indexed array
Uses sequenceIn_
Also applies scaling if needed

</member>
        <member name="M:ClpSimplex.add(System.Double*,System.Int32,System.Double)">
Adds multiple of a column into an array 
</member>
        <member name="M:ClpSimplex.computePrimals(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Computes primals from scratch
</member>
        <member name="M:ClpSimplex.computeDuals(System.Double*)">
Computes duals from scratch. If givenDjs then
         allows for nonzero basic djs 
</member>
        <member name="M:ClpSimplex.factorize">
Factorizes using current basis. For external use
</member>
        <member name="M:ClpSimplex.cleanStatus">
Clean up status
</member>
        <member name="M:ClpSimplex.restoreData(ClpDataSave)">
Restore data
</member>
        <member name="M:ClpSimplex.saveData">
Save data
</member>
        <member name="M:ClpSimplex.internalFactorize(System.Int32)">
Factorizes using current basis.
         solveType - 1 iterating, 0 initial, -1 external
         If 10 added then in primal values pass
         Return codes are as from ClpFactorization unless initial factorization
         when total number of singularities is returned.
         Special case is numberRows_+1 -&gt; all slack basis.

</member>
        <member name="M:ClpSimplex.returnModel(ClpSimplex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return model - updates any scalars 
</member>
        <member name="M:ClpSimplex.goodAccuracy">
Returns true if model looks OK
</member>
        <member name="M:ClpSimplex.primalColumnPivot">
primal column pivot choice
</member>
        <member name="M:ClpSimplex.dualRowPivot">
dual row pivot choice
</member>
        <member name="M:ClpSimplex.createPiecewiseLinearCosts(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Constructs a non linear cost from list of non-linearities (columns only)
         First lower of each column is taken as real lower
         Last lower is taken as real upper and cost ignored

         Returns nonzero if bad data e.g. lowers not monotonic

</member>
        <member name="M:ClpSimplex.getSolution">
Given an existing factorization computes and checks
         primal and dual solutions.  Uses current problem arrays for
         bounds.  Returns feasibility states 
</member>
        <member name="M:ClpSimplex.getSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
@name Functions less likely to be useful to casual user 
Given an existing factorization computes and checks
         primal and dual solutions.  Uses input arrays for variables at
         bounds.  Returns feasibility states 
</member>
        <member name="M:ClpSimplex.columnArray(System.Int32)">
Useful column length arrays (0,1,2,3,4,5)
</member>
        <member name="M:ClpSimplex.rowArray(System.Int32)">
Useful row length arrays (0,1,2,3,4,5)
</member>
        <member name="M:ClpSimplex.checkUnscaledSolution">
Check unscaled primal solution but allow for rounding error
</member>
        <member name="M:ClpSimplex.checkSolutionInternal">
Just check solution (for internal use) - sets sum of
         infeasibilities etc. 
</member>
        <member name="M:ClpSimplex.checkSolution(System.Int32)">
Just check solution (for external use) - sets sum of
         infeasibilities etc.
         If setToBounds 0 then primal column values not changed
         and used to compute primal row activity values.  If 1 or 2
         then status used - so all nonbasic variables set to
         indicated bound and if any values changed (or ==2)  basic values re-computed.

</member>
        <member name="M:ClpSimplex.restoreModel(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Restore model from file, returns 0 if success,
         deletes current model 
</member>
        <member name="M:ClpSimplex.saveModel(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Save model to file, returns 0 if success.  This is designed for
         use outside algorithms so does not save iterating arrays etc.
     It does not save any messaging information.
     Does not save scaling values.
     It does not know about all types of virtual functions.

</member>
        <member name="M:ClpSimplex.numberPrimalInfeasibilities">
Number of primal infeasibilities
</member>
        <member name="M:ClpSimplex.sumOfRelaxedPrimalInfeasibilities">
Sum of relaxed primal infeasibilities
</member>
        <member name="M:ClpSimplex.sumPrimalInfeasibilities">
Sum of primal infeasibilities
</member>
        <member name="M:ClpSimplex.numberDualInfeasibilitiesWithoutFree">
Number of dual infeasibilities (without free)
</member>
        <member name="M:ClpSimplex.numberDualInfeasibilities">
Number of dual infeasibilities
</member>
        <member name="M:ClpSimplex.sumOfRelaxedDualInfeasibilities">
Sum of relaxed dual infeasibilities
</member>
        <member name="M:ClpSimplex.sumDualInfeasibilities">
Sum of dual infeasibilities
</member>
        <member name="M:ClpSimplex.isObjectiveLimitTestValid">
Return true if the objective limit test can be relied upon
</member>
        <member name="M:ClpSimplex.setAlgorithm(System.Int32)">
Set algorithm
</member>
        <member name="M:ClpSimplex.algorithm">
Current (or last) algorithm
</member>
        <member name="M:ClpSimplex.perturbation">
Amount of print out:
         0 - none
         1 - just final
         2 - just factorizations
         3 - as 2 plus a bit more
         4 - verbose
         above that 8,16,32 etc just for selective debug

Perturbation:
         50  - switch on perturbation
         100 - auto perturb if takes too long (1.0e-6 largest nonzero)
         101 - we are perturbed
         102 - don't try perturbing again
         default is 100
         others are for playing

</member>
        <member name="M:ClpSimplex.infeasibilityCost">
Infeasibility cost
</member>
        <member name="M:ClpSimplex.dualBound">
Dual bound
</member>
        <member name="M:ClpSimplex.factorizationFrequency">
Factorization frequency
</member>
        <member name="M:ClpSimplex.sparseFactorization">
Sparsity on or off
</member>
        <member name="M:ClpSimplex.factorization">
factorization
</member>
        <member name="M:ClpSimplex.dualFeasible">
If problem is dual feasible
</member>
        <member name="M:ClpSimplex.primalFeasible">
@name most useful gets and sets 
If problem is primal feasible
</member>
        <member name="M:ClpSimplex.copyEnabledStuff(ClpSimplex!System.Runtime.CompilerServices.IsConst*)">
Copy across enabled stuff from one solver to another
</member>
        <member name="M:ClpSimplex.defaultFactorizationFrequency">
If user left factorization frequency then compute
</member>
        <member name="M:ClpSimplex.statusOfProblem(System.Boolean)">
Factorizes and returns true if optimal.  Used by user 
</member>
        <member name="M:ClpSimplex.startup(System.Int32,System.Int32)">
Common bits of coding for dual and primal.  Return 0 if okay,
         1 if bad matrix, 2 if very bad factorization

         startFinishOptions - bits
         1 - do not delete work areas and factorization at end
         2 - use old factorization if same number of rows
         4 - skip as much initialization of work areas as possible
             (based on whatsChanged in clpmodel.hpp) ** work in progress
         maybe other bits later


</member>
        <member name="M:ClpSimplex.pivotResultPart2(System.Int32,System.Int32)">
Do actual pivot
	 state is 0 if need tableau column, 1 if in rowArray_[1]

</member>
        <member name="M:ClpSimplex.dualPivotResultPart1">
Pivot out a variable and choose an incoing one.  Assumes dual
         feasible - will not go through a reduced cost.
         Returns step length in theta
         Return codes as before but -1 means no acceptable pivot

</member>
        <member name="M:ClpSimplex.primalPivotResult">
Pivot in a variable and choose an outgoing one.  Assumes primal
         feasible - will not go through a bound.  Returns step length in theta
         Returns ray in ray_ (or NULL if no pivot)
         Return codes as before but -1 means no acceptable pivot

</member>
        <member name="M:ClpSimplex.pivot">
@name Needed for functionality of OsiSimplexInterface 
Pivot in a variable and out a variable.  Returns 0 if okay,
         1 if inaccuracy forced re-factorization, -1 if would be singular.
         Also updates primal/dual infeasibilities.
         Assumes sequenceIn_ and pivotRow_ set and also directionIn and Out.

</member>
        <member name="M:ClpSimplex.fastCrunch(ClpNodeStuff*,System.Int32)">
Deals with crunch aspects
         mode 0 - in
              1 - out with solution
          2 - out without solution
         returns small model or NULL

</member>
        <member name="M:ClpSimplex.stopFastDual2(ClpNodeStuff*)">
Stops Fast dual2
</member>
        <member name="M:ClpSimplex.fastDual2(ClpNodeStuff*)">
Like Fast dual
</member>
        <member name="M:ClpSimplex.startFastDual2(ClpNodeStuff*)">
Starts Fast dual2
</member>
        <member name="M:ClpSimplex.doubleCheck">
Double checks OK
</member>
        <member name="M:ClpSimplex.fathomMany(System.Void*)">
Do up to N deep - returns
         -1 - no solution nNodes_ valid nodes
         &gt;= if solution and that node gives solution
         ClpNode array is 2**N long.  Values for N and
         array are in stuff (nNodes_ also in stuff) 
</member>
        <member name="M:ClpSimplex.fathom(System.Void*)">
Fathom - 1 if solution
</member>
        <member name="M:ClpSimplex.strongBranching(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double*,System.Double**,System.Int32*,System.Int32*,System.Boolean,System.Boolean,System.Int32)">
For strong branching.  On input lower and upper are new bounds
         while on output they are change in objective function values
         (&gt;1.0e50 infeasible).
         Return code is 0 if nothing interesting, -1 if infeasible both
         ways and +1 if infeasible one way (check values to see which one(s))
         Solutions are filled in as well - even down, odd up - also
         status and number of iterations

</member>
        <member name="M:ClpSimplex.unmarkHotStart(System.Void*)">
Delete the snapshot
</member>
        <member name="M:ClpSimplex.solveFromHotStart(System.Void*)">
Optimize starting from the hotstart
</member>
        <member name="M:ClpSimplex.markHotStart(System.Void**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Create a hotstart point of the optimization process
</member>
        <member name="M:ClpSimplex.setPrimalColumnPivotAlgorithm(ClpPrimalColumnPivot*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets column pivot choice algorithm in primal
</member>
        <member name="M:ClpSimplex.setDualRowPivotAlgorithm(ClpDualRowPivot*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Sets row pivot choice algorithm in dual
</member>
        <member name="M:ClpSimplex.tightenPrimalBounds(System.Double,System.Int32,System.Boolean)">
Tightens primal bounds to make dual faster.  Unless
         fixed or doTight&gt;10, bounds are slightly looser than they could be.
         This is to make dual go faster and is probably not needed
         with a presolve.  Returns non-zero if problem infeasible.

         Fudge for branch and bound - put bounds on columns of factor *
         largest value (at continuous) - should improve stability
         in branch and bound on infeasible branches (0.0 is off)

</member>
        <member name="M:ClpSimplex.copyFactorization(ClpFactorization*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copies in factorization to existing one
</member>
        <member name="M:ClpSimplex.setFactorization(ClpFactorization*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Passes in factorization
</member>
        <member name="M:ClpSimplex.getBasis">
Returns a basis (to be deleted by user)
</member>
        <member name="M:ClpSimplex.readBasis(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Read a basis from the given filename,
         returns -1 on file error, 0 if no values, 1 if values 
</member>
        <member name="M:ClpSimplex.miniSolve(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32,System.Int32)">
mini presolve and solve
</member>
        <member name="M:ClpSimplex.miniPostsolve(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Void*)">
After mini presolve
</member>
        <member name="M:ClpSimplex.removeSuperBasicSlacks(System.Int32)">
Try simple crash like techniques to remove super basic slacks
	 but only if &gt; threshold 
</member>
        <member name="M:ClpSimplex.moveTowardsPrimalFeasible">
Try simple crash like techniques to get closer to primal feasibility
	 returns final sum of infeasibilities 
</member>
        <member name="M:ClpSimplex.outDuplicateRows(System.Int32,System.Int32*,System.Boolean,System.Double,System.Double)">
Take out duplicate rows (includes scaled rows and intersections).
	 On exit whichRows has rows to delete - return code is number can be deleted 
	 or -1 if would be infeasible.
	 If tolerance is -1.0 use primalTolerance for equality rows and infeasibility
	 If cleanUp not zero then spend more time trying to leave more stable row
	 and make row bounds exact multiple of cleanUp if close enough

</member>
        <member name="M:ClpSimplex.modifyCoefficientsAndPivot(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Modifies coefficients etc and if necessary pivots in and out.
All at same status will be done (basis may go singular).
User can tell which others have been done (i.e. if status matches).
If called from outside will change status and return 0.
If called from event handler returns non-zero if user has to take action.
indices&gt;=numberColumns are slacks (obviously no coefficients)
status array is (char) Status enum

</member>
        <member name="M:ClpSimplex.primalRanging(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Int32*,System.Double*,System.Int32*)">
Primal ranging.
         This computes increase/decrease in value for each given variable and corresponding
         sequence numbers which would change basis.  Sequence numbers are 0..numberColumns
         and numberColumns.. for artificials/slacks.
         This should only be used for non-basic variabls as otherwise information is pretty useless
         For basic variables the sequence number will be that of the basic variables.

         Up to user to provide correct length arrays where each array is of length numberCheck.
         which contains list of variables for which information is desired.  All other
         arrays will be filled in by function.  If fifth entry in which is variable 7 then fifth entry in output arrays
         will be information for variable 7.

         Returns non-zero if infeasible unbounded etc

</member>
        <member name="M:ClpSimplex.dualRanging(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Int32*,System.Double*,System.Int32*,System.Double*,System.Double*)">
Dual ranging.
         This computes increase/decrease in cost for each given variable and corresponding
         sequence numbers which would change basis.  Sequence numbers are 0..numberColumns
         and numberColumns.. for artificials/slacks.
         For non-basic variables the information is trivial to compute and the change in cost is just minus the
         reduced cost and the sequence number will be that of the non-basic variables.
         For basic variables a ratio test is between the reduced costs for non-basic variables
         and the row of the tableau corresponding to the basic variable.
         The increase/decrease value is always &gt;= 0.0

         Up to user to provide correct length arrays where each array is of length numberCheck.
         which contains list of variables for which information is desired.  All other
         arrays will be filled in by function.  If fifth entry in which is variable 7 then fifth entry in output arrays
         will be information for variable 7.

         If valueIncrease/Decrease not NULL (both must be NULL or both non NULL) then these are filled with
         the value of variable if such a change in cost were made (the existing bounds are ignored)

         Returns non-zero if infeasible unbounded etc

</member>
        <member name="M:ClpSimplex.cleanPrimalSolution(System.Double)">
Clean primal solution
	 If you expect solution to only have exact multiples of "exactMultiple" then
	 this tries moving solution values to nearest multiple.  If still feasible
	 then the solution is replaced.

	 This is designed for the case where values should be integral, but Clp may
	 have values at e.g. 1.0e-13
	 Returns 0 if successful, n if n rhs violated
	 The dual version may be written if this gets used.

</member>
        <member name="M:ClpSimplex.cleanup(System.Int32)">
        When scaling is on it is possible that the scaled problem
        is feasible but the unscaled is not.  Clp returns a secondary
        status code to that effect.  This option allows for a cleanup.
        If you use it I would suggest 1.
        This only affects actions when scaled optimal
        0 - no action
        1 - clean up using dual if primal infeasibility
        2 - clean up using dual if dual infeasibility
        3 - clean up using dual if primal or dual infeasibility
        11,12,13 - as 1,2,3 but use primal

        return code as dual/primal

</member>
        <member name="M:ClpSimplex.loadProblem(CoinStructuredModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
This loads a model from a CoinStructuredModel object - returns number of errors.
         If originalOrder then keep to order stored in blocks,
         otherwise first column/rows correspond to first block - etc.
         If keepSolution true and size is same as current then
         keeps current status and solution

</member>
        <member name="M:ClpSimplex.solve(CoinStructuredModel*)">
Solve using structure of model and maybe in parallel
</member>
        <member name="M:ClpSimplex.reducedGradient(System.Int32)">
Solves non-linear using reduced gradient.  Phase = 0 get feasible,
         =1 use solution 
</member>
        <member name="M:ClpSimplex.barrier(System.Boolean)">
Solves using barrier (assumes you have good cholesky factor code).
         Does crossover to simplex if asked
</member>
        <member name="M:ClpSimplex.nonlinearSLP(System.Int32,ClpConstraint**,System.Int32,System.Double)">
Solves problem with nonlinear constraints using SLP - may be used as crash
         for other algorithms when number of iterations small.
         Also exits if all problematical variables are changing
         less than deltaTolerance

</member>
        <member name="M:ClpSimplex.nonlinearSLP(System.Int32,System.Double)">
Solves nonlinear problem using SLP - may be used as crash
         for other algorithms when number of iterations small.
         Also exits if all problematical variables are changing
         less than deltaTolerance

</member>
        <member name="M:ClpSimplex.primal(System.Int32,System.Int32)">
Primal algorithm - see ClpSimplexPrimal.hpp for method.
         ifValuesPass==2 just does values pass and then stops.

         startFinishOptions - bits
         1 - do not delete work areas and factorization at end
         2 - use old factorization if same number of rows
         4 - skip as much initialization of work areas as possible
             (based on whatsChanged in clpmodel.hpp) ** work in progress
         maybe other bits later

</member>
        <member name="M:ClpSimplex.dual(System.Int32,System.Int32)">
Dual algorithm - see ClpSimplexDual.hpp for method.
         ifValuesPass==2 just does values pass and then stops.

         startFinishOptions - bits
         1 - do not delete work areas and factorization at end
         2 - use old factorization if same number of rows
         4 - skip as much initialization of work areas as possible
             (based on whatsChanged in clpmodel.hpp) ** work in progress
         maybe other bits later

</member>
        <member name="M:ClpSimplex.initialBarrierNoCrossSolve">
Barrier initial solve, not to be followed by crossover
</member>
        <member name="M:ClpSimplex.initialBarrierSolve">
Barrier initial solve
</member>
        <member name="M:ClpSimplex.initialPrimalSolve">
Primal initial solve
</member>
        <member name="M:ClpSimplex.initialDualSolve">
Dual initial solve
</member>
        <member name="M:ClpSimplex.initialSolve">
Default initial solve
</member>
        <member name="M:ClpSimplex.initialSolve(ClpSolve*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Functions most useful to user 
General solve algorithm which can do presolve.
         See  ClpSolve.hpp for options

</member>
        <member name="M:ClpSimplex.loadNonLinear(System.Void*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ClpConstraint***!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Load nonlinear part of problem from AMPL info
         Returns 0 if linear
         1 if quadratic objective
         2 if quadratic constraints
         3 if nonlinear objective
         4 if nonlinear constraints
         -1 on failure

</member>
        <member name="M:ClpSimplex.getbackSolution(ClpSimplex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Puts solution back into small model
</member>
        <member name="M:ClpSimplex.passInEventHandler(ClpEventHandler!System.Runtime.CompilerServices.IsConst*)">
Pass in Event handler (cloned and deleted at end)
</member>
        <member name="M:ClpSimplex.borrowModel(ClpModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Borrow model.  This is so we dont have to copy large amounts
         of data around.  It assumes a derived class wants to overwrite
         an empty model with a real one - while it does an algorithm.
         This is same as ClpModel one, but sets scaling on etc. 
</member>
        <member name="M:ClpSimplex.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)">
Write the problem into an Lp file of the given filename.
	  If objSense is non zero then -1.0 forces the code to write a
	  maximization objective and +1.0 to write a minimization one.
	  If 0.0 then solver can do what it wants.
</member>
        <member name="M:ClpSimplex.readLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
Read file in LP format from file with name filename.
See class CoinLpIO for description of this format.
</member>
        <member name="M:ClpSimplex.readGMPL(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Read GMPL files from the given filenames
</member>
        <member name="M:ClpSimplex.readMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
Read an mps file from the given filename
</member>
        <member name="M:ClpSimplex.loadProblem(CoinModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
This loads a model from a coinModel object - returns number of errors.
         If keepSolution true and size is same as current then
         keeps current status and solution

</member>
        <member name="M:ClpSimplex.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
This one is for after presolve to save memory
</member>
        <member name="M:ClpSimplex.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Just like the other loadProblem() method except that the matrix is
       given in a standard column major ordered format (without gaps). 
</member>
        <member name="M:ClpSimplex.Dispose">
Destructor
</member>
        <member name="M:ClpSimplex.op_Assign(ClpSimplex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. This copies the data
</member>
        <member name="M:ClpSimplex.setToBaseModel(ClpSimplex*)">
Reset to base model (just size and arrays needed)
         If model NULL use internal copy

</member>
        <member name="M:ClpSimplex.baseModel">
See if we have base model
</member>
        <member name="M:ClpSimplex.deleteBaseModel">
Switch off base model
</member>
        <member name="M:ClpSimplex.makeBaseModel">
Save a copy of model with certain state - normally without cuts
</member>
        <member name="M:ClpSimplex.setPersistenceFlag(System.Int32)">
Array persistence flag
         If 0 then as now (delete/new)
         1 then only do arrays if bigger needed
         2 as 1 but give a bit extra if bigger needed

</member>
        <member name="M:ClpSimplex.originalModel(ClpSimplex*)">
This copies back stuff from miniModel and then deletes miniModel.
         Only to be used with mini constructor 
</member>
        <member name="M:ClpSimplex.#ctor(ClpSimplex*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
This constructor modifies original ClpSimplex and stores
         original stuff in created ClpSimplex.  It is only to be used in
         conjunction with originalModel 
</member>
        <member name="M:ClpSimplex.#ctor(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean)">
Subproblem constructor.  A subset of whole model is created from the
         row and column lists given.  The new order is given by list order and
         duplicates are allowed.  Name and integer information can be dropped
         Can optionally modify rhs to take into account variables NOT in list
         in this case duplicates are not allowed (also see getbackSolution)

</member>
        <member name="M:ClpSimplex.#ctor(ClpModel!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean,System.Boolean)">
Subproblem constructor.  A subset of whole model is created from the
         row and column lists given.  The new order is given by list order and
         duplicates are allowed.  Name and integer information can be dropped
         Can optionally modify rhs to take into account variables NOT in list
         in this case duplicates are not allowed (also see getbackSolution)

</member>
        <member name="M:ClpSimplex.#ctor(ClpModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Copy constructor from model. May scale depending on mode
         -1 leave mode as is
         0 -off, 1 equilibrium, 2 geometric, 3, auto, 4 dynamic(later)

</member>
        <member name="M:ClpSimplex.#ctor(ClpSimplex!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Copy constructor. May scale depending on mode
         -1 leave mode as is
         0 -off, 1 equilibrium, 2 geometric, 3, auto, 4 dynamic(later)

</member>
        <member name="M:ClpSimplex.#ctor(System.Boolean)">
@name Constructors and destructor and copy 
Default constructor
</member>
        <member name="T:ClpSimplex.Status">
enums for status of various sorts.
         First 4 match CoinWarmStartBasis,
         isFixed means fixed at lower bound and out of basis

</member>
        <member name="T:ClpSimplex">
This solves LPs using the simplex method

    It inherits from ClpModel and all its arrays are created at
    algorithm time. Originally I tried to work with model arrays
    but for simplicity of coding I changed to single arrays with
    structural variables then row variables.  Some coding is still
    based on old style and needs cleaning up.

    For a description of algorithms:

    for dual see ClpSimplexDual.hpp and at top of ClpSimplexDual.cpp
    for primal see ClpSimplexPrimal.hpp and at top of ClpSimplexPrimal.cpp

    There is an algorithm data member.  + for primal variations
    and - for dual variations


</member>
        <member name="F:CoinPartitionedVector.numberPartitions_">
Number of partitions (0 means off)
</member>
        <member name="F:CoinPartitionedVector.numberElementsPartition_">
Size of indices in a partition
</member>
        <member name="F:CoinPartitionedVector.startPartition_">
@name Private member data 
Starts
</member>
        <member name="M:CoinPartitionedVector.Dispose">
Destructor 
</member>
        <member name="M:CoinPartitionedVector.op_Assign(CoinPartitionedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinPartitionedVector.#ctor(CoinPartitionedVector!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinPartitionedVector.#ctor(CoinPartitionedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinPartitionedVector.#ctor(System.Int32)">
Alternate Constructors - just size 
</member>
        <member name="M:CoinPartitionedVector.#ctor(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Alternate Constructors - construct full storage with indices 0 through
       size-1. 
</member>
        <member name="M:CoinPartitionedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double)">
Alternate Constructors - set elements to same scalar value 
</member>
        <member name="M:CoinPartitionedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Alternate Constructors - set elements to vector of doubles 
</member>
        <member name="M:CoinPartitionedVector.#ctor">
@name Constructors and destructors (not all wriiten) 
Default constructor 
</member>
        <member name="M:CoinPartitionedVector.sort">
@name Sorting 
Sort the indexed storage vector (increasing indices). 
</member>
        <member name="M:CoinPartitionedVector.scan(System.Int32,System.Double)">
Scan dense region and set up indices (returns number found)
</member>
        <member name="M:CoinPartitionedVector.checkClean">
For debug check vector is clean i.e. elements match indices
</member>
        <member name="M:CoinPartitionedVector.checkClear">
For debug check vector is clear i.e. no elements
</member>
        <member name="M:CoinPartitionedVector.clearPartition(System.Int32)">
Clear a partition.
</member>
        <member name="M:CoinPartitionedVector.clearAndKeep">
Reset the vector (as if were just created an empty vector). Keeps partitions
</member>
        <member name="M:CoinPartitionedVector.clearAndReset">
Reset the vector (as if were just created an empty vector). Gets rid of partitions
</member>
        <member name="M:CoinPartitionedVector.setPartitions(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Setup partitions (needs end as well)
</member>
        <member name="M:CoinPartitionedVector.reserve(System.Int32)">
Reserve space.

</member>
        <member name="M:CoinPartitionedVector.compact">
Add up number of elements in partitions and pack and get rid of partitions
</member>
        <member name="M:CoinPartitionedVector.computeNumberElements">
Add up number of elements in partitions
</member>
        <member name="M:CoinPartitionedVector.setTempNumElementsPartition(System.Int32,System.Int32)">
Set the size of a partition (just for a tiny while)
</member>
        <member name="M:CoinPartitionedVector.setNumElementsPartition(System.Int32,System.Int32)">
@name Set methods 
Set the size of a partition
</member>
        <member name="M:CoinPartitionedVector.startPartitions">
Get starts
</member>
        <member name="M:CoinPartitionedVector.startPartition(System.Int32)">
Get starts
</member>
        <member name="M:CoinPartitionedVector.getNumElements">
Get the size
</member>
        <member name="M:CoinPartitionedVector.getNumPartitions">
Get number of partitions
</member>
        <member name="M:CoinPartitionedVector.getNumElements(System.Int32)">
@name Get methods. 
Get the size of a partition
</member>
        <member name="F:CoinArbitraryArrayWithLength.lengthInBytes_">
@name Private member data 
Length in bytes
</member>
        <member name="M:CoinArbitraryArrayWithLength.op_Assign(CoinArbitraryArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinArbitraryArrayWithLength.#ctor(CoinArbitraryArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinArbitraryArrayWithLength.#ctor(CoinArbitraryArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinArbitraryArrayWithLength.#ctor(System.Int32,System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinArbitraryArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinArbitraryArrayWithLength.#ctor(System.Int32)">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinArbitraryArrayWithLength.conditionalNew(System.Int32,System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinArbitraryArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinArbitraryArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinArbitraryArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinArbitraryArrayWithLength">
arbitrary version
</member>
        <member name="M:CoinVoidStarArrayWithLength.op_Assign(CoinVoidStarArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinVoidStarArrayWithLength.#ctor(CoinVoidStarArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinVoidStarArrayWithLength.#ctor(CoinVoidStarArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinVoidStarArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinVoidStarArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinVoidStarArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinVoidStarArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinVoidStarArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinVoidStarArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinVoidStarArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinVoidStarArrayWithLength">
void * version
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.op_Assign(CoinUnsignedIntArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.#ctor(CoinUnsignedIntArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.#ctor(CoinUnsignedIntArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinUnsignedIntArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinUnsignedIntArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinUnsignedIntArrayWithLength">
unsigned int * version
</member>
        <member name="M:CoinBigIndexArrayWithLength.op_Assign(CoinBigIndexArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinBigIndexArrayWithLength.#ctor(CoinBigIndexArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinBigIndexArrayWithLength.#ctor(CoinBigIndexArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinBigIndexArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinBigIndexArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinBigIndexArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinBigIndexArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinBigIndexArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinBigIndexArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinBigIndexArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinBigIndexArrayWithLength">
CoinBigIndex * version
</member>
        <member name="M:CoinIntArrayWithLength.op_Assign(CoinIntArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinIntArrayWithLength.#ctor(CoinIntArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinIntArrayWithLength.#ctor(CoinIntArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinIntArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinIntArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinIntArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinIntArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinIntArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinIntArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinIntArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinIntArrayWithLength">
int * version
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.op_Assign(CoinFactorizationLongDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.#ctor(CoinFactorizationLongDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.#ctor(CoinFactorizationLongDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinFactorizationLongDoubleArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinFactorizationLongDoubleArrayWithLength">
CoinFactorizationLongDouble * version
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.op_Assign(CoinFactorizationDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.#ctor(CoinFactorizationDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.#ctor(CoinFactorizationDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinFactorizationDoubleArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinFactorizationDoubleArrayWithLength">
CoinFactorizationDouble * version
</member>
        <member name="M:CoinDoubleArrayWithLength.op_Assign(CoinDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinDoubleArrayWithLength.#ctor(CoinDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinDoubleArrayWithLength.#ctor(CoinDoubleArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinDoubleArrayWithLength.#ctor(System.Int32,System.Int32)">
Alternate Constructor - length in bytes 
      mode -  0 size_ set to size
      1 size_ set to size and zeroed

</member>
        <member name="M:CoinDoubleArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinDoubleArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinDoubleArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinDoubleArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinDoubleArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinDoubleArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinDoubleArrayWithLength">
double * version
</member>
        <member name="F:CoinArrayWithLength.alignment_">
Alignment wanted (power of 2)
</member>
        <member name="F:CoinArrayWithLength.offset_">
Offset of array
</member>
        <member name="F:CoinArrayWithLength.size_">
Size of array in bytes
</member>
        <member name="F:CoinArrayWithLength.array_">
@name Private member data 
Array
</member>
        <member name="M:CoinArrayWithLength.getCapacity(System.Int32,System.Int32)">
Get enough space (if more needed then do at least needed)
</member>
        <member name="M:CoinArrayWithLength.reallyFreeArray">
Really get rid of array with alignment
</member>
        <member name="M:CoinArrayWithLength.getArray(System.Int32)">
Get array with alignment
</member>
        <member name="M:CoinArrayWithLength.Dispose">
Destructor 
</member>
        <member name="M:CoinArrayWithLength.allocate(CoinArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Assignment with length - does not copy 
</member>
        <member name="M:CoinArrayWithLength.copy(CoinArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Assignment with length (if -1 use internal length) 
</member>
        <member name="M:CoinArrayWithLength.op_Assign(CoinArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinArrayWithLength.#ctor(CoinArrayWithLength!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinArrayWithLength.#ctor(CoinArrayWithLength!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinArrayWithLength.#ctor(System.Int32)">
Alternate Constructor - length in bytes - size_ -1 
</member>
        <member name="M:CoinArrayWithLength.#ctor">
@name Constructors and destructors 
Default constructor - NULL
</member>
        <member name="M:CoinArrayWithLength.conditionalDelete">
Conditionally deletes
</member>
        <member name="M:CoinArrayWithLength.conditionalNew(System.Int32)">
@name Condition methods 
Conditionally gets new array
</member>
        <member name="M:CoinArrayWithLength.extend(System.Int32)">
Extend a persistent array keeping data (size in bytes)
</member>
        <member name="M:CoinArrayWithLength.swap(CoinArrayWithLength*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Swaps memory between two members
</member>
        <member name="M:CoinArrayWithLength.clear">
Zero out array
</member>
        <member name="M:CoinArrayWithLength.setPersistence(System.Int32,System.Int32)">
Does what is needed to set persistence
</member>
        <member name="M:CoinArrayWithLength.switchOn(System.Int32)">
Set the size to -2 and alignment
</member>
        <member name="M:CoinArrayWithLength.switchOff">
Set the size to -1
</member>
        <member name="M:CoinArrayWithLength.setSize(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinArrayWithLength.array">
Get Array
</member>
        <member name="M:CoinArrayWithLength.capacity">
Get the capacity (just read it)
</member>
        <member name="M:CoinArrayWithLength.switchedOn">
See if persistence already on
</member>
        <member name="M:CoinArrayWithLength.rawSize">
Get the size
</member>
        <member name="M:CoinArrayWithLength.getSize">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinArrayWithLength">
Pointer with length in bytes
    
    This has a pointer to an array and the number of bytes in array.
    If number of bytes==-1 then
    CoinConditionalNew deletes existing pointer and returns new pointer
    of correct size (and number bytes still -1).
    CoinConditionalDelete deletes existing pointer and NULLs it.
    So behavior is as normal (apart from New deleting pointer which will have
    no effect with good coding practices.
    If number of bytes &gt;=0 then
    CoinConditionalNew just returns existing pointer if array big enough
    otherwise deletes existing pointer, allocates array with spare 1%+64 bytes
    and updates number of bytes
    CoinConditionalDelete sets number of bytes = -size-2 and then array 
    returns NULL

</member>
        <member name="M:CoinIndexedVectorUnitTest">
A function that tests the methods in the CoinIndexedVector class. The
    only reason for it not to be a member method is that this way it doesn't
    have to be compiled into the library. And that's a gain, because the
    library should be compiled with optimization on, but this method should be
    compiled with debugging. 
</member>
        <member name="F:CoinIndexedVector.packedMode_">
If true then is operating in packed mode
</member>
        <member name="F:CoinIndexedVector.offset_">
 Offset to get where new allocated array
</member>
        <member name="F:CoinIndexedVector.capacity_">
Amount of memory allocated for indices_, and elements_.
</member>
        <member name="F:CoinIndexedVector.nElements_">
Size of indices and packed elements vectors
</member>
        <member name="F:CoinIndexedVector.elements_">
Vector elements
</member>
        <member name="F:CoinIndexedVector.indices_">
@name Private member data 
Vector indices
</member>
        <member name="M:CoinIndexedVector.gutsOfSetVector(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
@name Private methods 
Copy internal data
</member>
        <member name="M:CoinIndexedVector.Dispose">
Destructor 
</member>
        <member name="M:CoinIndexedVector.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor <em>from a PackedVectorBase</em>. 
</member>
        <member name="M:CoinIndexedVector.#ctor(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*)">
Copy constructor.2 
</member>
        <member name="M:CoinIndexedVector.#ctor(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinIndexedVector.#ctor(System.Int32)">
Alternate Constructors - just size 
</member>
        <member name="M:CoinIndexedVector.#ctor(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Alternate Constructors - construct full storage with indices 0 through
       size-1. 
</member>
        <member name="M:CoinIndexedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double)">
Alternate Constructors - set elements to same scalar value 
</member>
        <member name="M:CoinIndexedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Alternate Constructors - set elements to vector of doubles 
</member>
        <member name="M:CoinIndexedVector.#ctor">
@name Constructors and destructors 
Default constructor 
</member>
        <member name="M:CoinIndexedVector.packedMode">
Gets packed mode
</member>
        <member name="M:CoinIndexedVector.setPackedMode(System.Boolean)">
Sets packed mode
</member>
        <member name="M:CoinIndexedVector.capacity">
capacity returns the size which could be accomodated without
       having to reallocate storage.

</member>
        <member name="M:CoinIndexedVector.reserve(System.Int32)">
@name Memory usage 
Reserve space.
       If one knows the eventual size of the indexed vector,
       then it may be more efficient to reserve the space.

</member>
        <member name="M:CoinIndexedVector.op_DivisionAssignment(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The element-wise ratio of two indexed vectors (0.0/0.0 =&gt; 0.0) (0 vanishes)
</member>
        <member name="M:CoinIndexedVector.op_MultiplicationAssignment(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The element-wise product of two indexed vectors
</member>
        <member name="M:CoinIndexedVector.op_SubtractionAssignment(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The difference of two indexed vectors
</member>
        <member name="M:CoinIndexedVector.op_AdditionAssignment(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The sum of two indexed vectors
</member>
        <member name="M:CoinIndexedVector.op_Division(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the element-wise ratio of two indexed vectors (0.0/0.0 =&gt; 0.0) (0 vanishes)
</member>
        <member name="M:CoinIndexedVector.op_Multiply(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the element-wise product of two indexed vectors
</member>
        <member name="M:CoinIndexedVector.op_Subtraction(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return the difference of two indexed vectors
</member>
        <member name="M:CoinIndexedVector.sort">
@name Sorting 
Sort the indexed storage vector (increasing indices). 
</member>
        <member name="M:CoinIndexedVector.getMinIndex">
Get value of minimum index
</member>
        <member name="M:CoinIndexedVector.getMaxIndex">
@name Index methods 
Get value of maximum index
</member>
        <member name="M:CoinIndexedVector.isApproximatelyEqual(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Equal with a tolerance (returns -1 or position of inequality).
</member>
        <member name="M:CoinIndexedVector.op_Inequality(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Not equal
</member>
        <member name="M:CoinIndexedVector.op_Equality(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Equal. Returns true if vectors have same length and corresponding
       element of each vector is equal. 
</member>
        <member name="M:CoinIndexedVector.op_Inequality(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Not equal
</member>
        <member name="M:CoinIndexedVector.op_Equality(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Comparison operators on two indexed vectors 
Equal. Returns true if vectors have same length and corresponding
       element of each vector is equal. 
</member>
        <member name="M:CoinIndexedVector.op_DivisionAssignment(System.Double)">
divide every entry by <code>value</code> (** 0 vanishes)
</member>
        <member name="M:CoinIndexedVector.op_MultiplicationAssignment(System.Double)">
multiply every entry by <code>value</code></member>
        <member name="M:CoinIndexedVector.op_SubtractionAssignment(System.Double)">
subtract <code>value</code> from every entry
</member>
        <member name="M:CoinIndexedVector.op_AdditionAssignment(System.Double)">
@name Arithmetic operators. 
add <code>value</code> to every entry
</member>
        <member name="M:CoinIndexedVector.print">
 Print out
</member>
        <member name="M:CoinIndexedVector.truncate(System.Int32)">
Throw away all entries in rows &gt;= newSize
</member>
        <member name="M:CoinIndexedVector.swap(System.Int32,System.Int32)">
Swap values in positions i and j of indices and elements
</member>
        <member name="M:CoinIndexedVector.append(CoinIndexedVector*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
Append a CoinIndexedVector to the end and modify indices
</member>
        <member name="M:CoinIndexedVector.append(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Append a CoinIndexedVector to the end (with extra space)
</member>
        <member name="M:CoinIndexedVector.append(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Append a CoinPackedVector to the end
</member>
        <member name="M:CoinIndexedVector.expand">
This is mainly for testing - goes from packed to indexed
</member>
        <member name="M:CoinIndexedVector.createOneUnpackedElement(System.Int32,System.Double)">
Create unpacked singleton
</member>
        <member name="M:CoinIndexedVector.createUnpacked(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Create unpacked array
</member>
        <member name="M:CoinIndexedVector.createPacked(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Create packed array
</member>
        <member name="M:CoinIndexedVector.scanAndPack">
These are same but pack down
</member>
        <member name="M:CoinIndexedVector.scan(System.Double)">
Scan dense region and set up indices (returns number found).
      Only ones &gt;= tolerance 
</member>
        <member name="M:CoinIndexedVector.scan">
Scan dense region and set up indices (returns number found)
</member>
        <member name="M:CoinIndexedVector.checkClean">
For debug check vector is clean i.e. elements match indices
</member>
        <member name="M:CoinIndexedVector.checkClear">
For debug check vector is clear i.e. no elements
</member>
        <member name="M:CoinIndexedVector.setPacked">
Mark as packed
</member>
        <member name="M:CoinIndexedVector.cleanAndPackSafe(System.Double)">
Same but packs down and is safe (i.e. if order is odd)
</member>
        <member name="M:CoinIndexedVector.cleanAndPack(System.Double)">
Same but packs down
</member>
        <member name="M:CoinIndexedVector.zero(System.Int32)">
Makes nonzero tiny.
       This version does no checking 
</member>
        <member name="M:CoinIndexedVector.quickAddNonZero(System.Int32,System.Double)">
Insert or if exists add an element into the vector
       Any resulting zero elements will be made tiny.
       This knows element is nonzero
       This version does no checking 
</member>
        <member name="M:CoinIndexedVector.quickAdd(System.Int32,System.Double)">
Insert or if exists add an element into the vector
       Any resulting zero elements will be made tiny.
       This version does no checking 
</member>
        <member name="M:CoinIndexedVector.add(System.Int32,System.Double)">
Insert or if exists add an element into the vector
       Any resulting zero elements will be made tiny 
</member>
        <member name="M:CoinIndexedVector.quickInsert(System.Int32,System.Double)">
Insert a nonzero element into the vector
</member>
        <member name="M:CoinIndexedVector.insert(System.Int32,System.Double)">
Insert an element into the vector
</member>
        <member name="M:CoinIndexedVector.setElement(System.Int32,System.Double)">
Set an existing element in the indexed vector
       The first argument is the "index" into the elements() array

</member>
        <member name="M:CoinIndexedVector.setFull(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*)">
Indices are not specified and are taken to be 0,1,...,size-1 
</member>
        <member name="M:CoinIndexedVector.setConstant(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double)">
Elements set to have the same scalar value 
</member>
        <member name="M:CoinIndexedVector.setVector(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Set vector size, indices, and elements.
       Size is the length of the unpacked elements vector.
       The indices and elements vectors are copied into this class instance's
       member data. We do not check for duplicate indices 
</member>
        <member name="M:CoinIndexedVector.setVector(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Set vector numberIndices, indices, and elements.
       NumberIndices is the length of both the indices and elements vectors.
       The indices and elements vectors are copied into this class instance's
       member data. Assumed to have no duplicates 
</member>
        <member name="M:CoinIndexedVector.returnVector">
Return ownership of the arguments to this vector.
       State after is empty .

</member>
        <member name="M:CoinIndexedVector.borrowVector(System.Int32,System.Int32,System.Int32*,System.Double*)">
Borrow ownership of the arguments to this vector.
       Size is the length of the unpacked elements vector. 
</member>
        <member name="M:CoinIndexedVector.copy(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Copy the contents of one vector into another.  If multiplier is 1
       It is the equivalent of = but if vectors are same size does
       not re-allocate memory just clears and copies 
</member>
        <member name="M:CoinIndexedVector.op_Assign(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinIndexedVector.reallyClear">
Clear even if in a bad way
</member>
        <member name="M:CoinIndexedVector.empty">
Reset the vector (as if were just created an empty vector)
</member>
        <member name="M:CoinIndexedVector.clear">
Reset the vector (as if were just created an empty vector).  This leaves arrays!
</member>
        <member name="M:CoinIndexedVector.setNumElements(System.Int32)">
@name Set methods 
Set the size
</member>
        <member name="M:CoinIndexedVector.op_Subscript(System.Int32)">
Access the i'th element of the full storage vector.

</member>
        <member name="M:CoinIndexedVector.setIndexVector(System.Int32*)">
For very temporary use when user needs to borrow an index vector
</member>
        <member name="M:CoinIndexedVector.setDenseVector(System.Double*)">
For very temporary use when user needs to borrow a dense vector
</member>
        <member name="M:CoinIndexedVector.denseVector">
Get the vector as a dense vector. This is normal storage method.
       The user should not not delete [] this.

</member>
        <member name="M:CoinIndexedVector.getIndices">
Get indices of elements

Get element values
Get indices of elements
</member>
        <member name="M:CoinIndexedVector.getNumElements">
@name Get methods. 
Get the size
</member>
        <member name="T:CoinIndexedVector">
Indexed Vector

This stores values unpacked but apart from that is a bit like CoinPackedVector.
It is designed to be lightweight in normal use.

It now has a "packed" mode when it is even more like CoinPackedVector

Indices array has capacity_ extra chars which are zeroed and can
be used for any purpose - but must be re-zeroed

Stores vector of indices and associated element values.
Supports sorting of indices.  

Does not support negative indices.

Does NOT support testing for duplicates

*** getElements is no longer supported

Here is a sample usage:
@verbatim
    const int ne = 4;
    int inx[ne] =   {  1,   4,  0,   2 }
    double el[ne] = { 10., 40., 1., 50. }

    // Create vector and set its valuex1
    CoinIndexedVector r(ne,inx,el);

    // access as a full storage vector
    assert( r[ 0]==1. );
    assert( r[ 1]==10.);
    assert( r[ 2]==50.);
    assert( r[ 3]==0. );
    assert( r[ 4]==40.);

    // sort Elements in increasing order
    r.sortIncrElement();

    // access each index and element
    assert( r.getIndices ()[0]== 0  );
    assert( r.getIndices ()[1]== 1  );
    assert( r.getIndices ()[2]== 4  );
    assert( r.getIndices ()[3]== 2  );

    // access as a full storage vector
    assert( r[ 0]==1. );
    assert( r[ 1]==10.);
    assert( r[ 2]==50.);
    assert( r[ 3]==0. );
    assert( r[ 4]==40.);

    // Tests for equality and equivalence
    CoinIndexedVector r1;
    r1=r;
    assert( r==r1 );
    assert( r.equivalent(r1) );
    r.sortIncrElement();
    assert( r!=r1 );
    assert( r.equivalent(r1) );

    // Add indexed vectors.
    // Similarly for subtraction, multiplication,
    // and division.
    CoinIndexedVector add = r + r1;
    assert( add[0] ==  1.+ 1. );
    assert( add[1] == 10.+10. );
    assert( add[2] == 50.+50. );
    assert( add[3] ==  0.+ 0. );
    assert( add[4] == 40.+40. );

    assert( r.sum() == 10.+40.+1.+50. );
@endverbatim

</member>
        <member name="D:CoinDecrSolutionOrdered">
Sort packed vector in decreasing order of the external vector
</member>
        <member name="D:CoinIncrSolutionOrdered">
@name Typedefs for sorting the entries of a packed vector based on an
   external vector. 
Sort packed vector in increasing order of the external vector
</member>
        <member name="F:ClpSimplexProgress.oddState_">
If things are in an odd state
</member>
        <member name="F:ClpSimplexProgress.numberTimesFlagged_">
Number of times no iterations as flagged
</member>
        <member name="F:ClpSimplexProgress.numberReallyBadTimes_">
Number really bad times
</member>
        <member name="F:ClpSimplexProgress.numberBadTimes_">
Number of times it looked like loop
</member>
        <member name="F:ClpSimplexProgress.numberTimes_">
Number of times checked (so won't stop too early)
</member>
        <member name="F:ClpSimplexProgress.iterationNumber_">
Iteration number at which occurred
</member>
        <member name="F:ClpSimplexProgress.numberInfeasibilities_">
Number of infeasibilities
</member>
        <member name="F:ClpSimplexProgress.model_">
Pointer back to model so we can get information
</member>
        <member name="F:ClpSimplexProgress.in_">
For cycle checking
</member>
        <member name="F:ClpSimplexProgress.initialWeight_">
Initial weight for weights
</member>
        <member name="F:ClpSimplexProgress.realInfeasibility_">
Sum of real primal infeasibilities for primal
</member>
        <member name="F:ClpSimplexProgress.infeasibility_">
Sum of infeasibilities for algorithm
</member>
        <member name="F:ClpSimplexProgress.objective_">
@name Data  
Objective values
</member>
        <member name="M:ClpSimplexProgress.timesFlagged">
number of times flagged
</member>
        <member name="M:ClpSimplexProgress.reallyBadTimes">
number of really bad times
</member>
        <member name="M:ClpSimplexProgress.badTimes">
number of bad times
</member>
        <member name="M:ClpSimplexProgress.newOddState">
Odd state
</member>
        <member name="M:ClpSimplexProgress.clearIterationNumbers">
clears all iteration numbers (to switch off panic)
</member>
        <member name="M:ClpSimplexProgress.lastIterationNumber(System.Int32)">
Returns previous iteration number (if -1) - current if (0)
</member>
        <member name="M:ClpSimplexProgress.modifyObjective(System.Double)">
Modify objective e.g. if dual infeasible in dual
</member>
        <member name="M:ClpSimplexProgress.numberInfeasibilities(System.Int32)">
Returns number of primal infeasibilities (if -1) - current if (0)
</member>
        <member name="M:ClpSimplexProgress.lastInfeasibility(System.Int32)">
Returns real primal infeasibility (if -1) - current if (0)
</member>
        <member name="M:ClpSimplexProgress.setInfeasibility(System.Double)">
Set real primal infeasibility and move back
</member>
        <member name="M:ClpSimplexProgress.lastObjective(System.Int32)">
Returns previous objective (if -1) - current if (0)
</member>
        <member name="M:ClpSimplexProgress.cycle(System.Int32,System.Int32,System.Int32,System.Int32)">
Returns cycle length in whileIterating
</member>
        <member name="M:ClpSimplexProgress.startCheck">
Start check at beginning of whileIterating
</member>
        <member name="M:ClpSimplexProgress.looping">
@name Check progress 
Returns -1 if okay, -n+1 (n number of times bad) if bad but action taken,
         &gt;=0 if give up and use as problem status

</member>
        <member name="M:ClpSimplexProgress.fillFromModel(ClpSimplex*)">
Fill from model
</member>
        <member name="M:ClpSimplexProgress.reset">
Resets as much as possible
</member>
        <member name="M:ClpSimplexProgress.Dispose">
Destructor
</member>
        <member name="M:ClpSimplexProgress.op_Assign(ClpSimplexProgress!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. This copies the data
</member>
        <member name="M:ClpSimplexProgress.#ctor(ClpSimplexProgress!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ClpSimplexProgress.#ctor(ClpSimplex*)">
Constructor from model
</member>
        <member name="M:ClpSimplexProgress.#ctor">
@name Constructors and destructor and copy 
Default constructor
</member>
        <member name="T:ClpSimplexProgress">
For saving extra information to see if looping.
</member>
        <member name="F:ClpSolve.independentOptions_">
Extra algorithm dependent options
         0 - if set return from clpsolve if infeasible
         1 - To be copied over to presolve options
         2 - max substitution level
	 If Dantzig Wolfe/benders 0 is number blocks, 2 is #passes (notional)

</member>
        <member name="F:ClpSolve.extraInfo_">
Extra information
</member>
        <member name="F:ClpSolve.options_">
Options - last is switch for OsiClp
</member>
        <member name="F:ClpSolve.numberPasses_">
Amount of presolve
</member>
        <member name="F:ClpSolve.presolveType_">
Presolve type
</member>
        <member name="F:ClpSolve.method_">
@name data.

Solve type
</member>
        <member name="M:ClpSolve.substitution">
Largest column for substitution (normally 3)
</member>
        <member name="M:ClpSolve.presolveActions">
Set whole group
</member>
        <member name="M:ClpSolve.doKillSmall">
Whether we want to kill small substitutions
</member>
        <member name="M:ClpSolve.doSingletonColumn">
Whether we want to do singleton column part of presolve
</member>
        <member name="M:ClpSolve.doDuprow">
Whether we want to do duprow part of presolve
</member>
        <member name="M:ClpSolve.doDupcol">
Whether we want to do dupcol part of presolve
</member>
        <member name="M:ClpSolve.doImpliedFree">
Whether we want to do impliedfree part of presolve
</member>
        <member name="M:ClpSolve.doForcing">
Whether we want to do forcing part of presolve
</member>
        <member name="M:ClpSolve.doTighten">
Whether we want to do tighten part of presolve
</member>
        <member name="M:ClpSolve.doTripleton">
Whether we want to do tripleton part of presolve
</member>
        <member name="M:ClpSolve.doDoubleton">
Whether we want to do doubleton part of presolve
</member>
        <member name="M:ClpSolve.doSingleton">
Whether we want to do singleton part of presolve
</member>
        <member name="M:ClpSolve.doDual">
Whether we want to do dual part of presolve
</member>
        <member name="M:ClpSolve.setInfeasibleReturn(System.Boolean)">
Say to return at once if infeasible,
         default is to solve 
</member>
        <member name="M:ClpSolve.getExtraInfo(System.Int32)">
Extra info for idiot (or sprint)
</member>
        <member name="M:ClpSolve.setSolveType(ClpSolve.SolveType,System.Int32)">
Solve types
</member>
        <member name="M:ClpSolve.setSpecialOption(System.Int32,System.Int32,System.Int32)">
@name Functions most useful to user 
Special options - bits
     0      4 - use crash (default allslack in dual, idiot in primal)
         8 - all slack basis in primal
     2      16 - switch off interrupt handling
     3      32 - do not try and make plus minus one matrix
         64 - do not use sprint even if problem looks good

which translation is:
         which:
         0 - startup in Dual  (nothing if basis exists).:
                      0 - no basis
       	   1 - crash
       	   2 - use initiative about idiot! but no crash
         1 - startup in Primal (nothing if basis exists):
                      0 - use initiative
       	   1 - use crash
       	   2 - use idiot and look at further info
       	   3 - use sprint and look at further info
       	   4 - use all slack
       	   5 - use initiative but no idiot
       	   6 - use initiative but no sprint
       	   7 - use initiative but no crash
                      8 - do allslack or idiot
                      9 - do allslack or sprint
       	   10 - slp before
       	   11 - no nothing and primal(0)
         2 - interrupt handling - 0 yes, 1 no (for threadsafe)
         3 - whether to make +- 1matrix - 0 yes, 1 no
         4 - for barrier
                      0 - dense cholesky
       	   1 - Wssmp allowing some long columns
       	   2 - Wssmp not allowing long columns
       	   3 - Wssmp using KKT
                      4 - Using Florida ordering
       	   8 - bit set to do scaling
       	   16 - set to be aggressive with gamma/delta?
                      32 - Use KKT
         5 - for presolve
                      1 - switch off dual stuff
         6 - extra switches
                      

</member>
        <member name="M:ClpSolve.Dispose">
Destructor
</member>
        <member name="M:ClpSolve.op_Assign(ClpSolve!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. This copies the data
</member>
        <member name="M:ClpSolve.#ctor(ClpSolve!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ClpSolve.generateCpp(_iobuf*)">
Generates code for above constructor
</member>
        <member name="M:ClpSolve.#ctor(ClpSolve.SolveType,ClpSolve.PresolveType,System.Int32,System.Int32*,System.Int32*,System.Int32*)">
Constructor when you really know what you are doing
</member>
        <member name="M:ClpSolve.#ctor">
@name Constructors and destructor and copy 
Default constructor
</member>
        <member name="T:ClpSolve.SolveType">
enums for solve function 
</member>
        <member name="T:ClpSolve">
    This is a very simple class to guide algorithms.  It is used to tidy up
    passing parameters to initialSolve and maybe for output from that


</member>
        <member name="F:ClpDataSave.dualBound_">
@name data - with same names as in other classes
</member>
        <member name="M:ClpDataSave.Dispose">
Destructor
</member>
        <member name="M:ClpDataSave.op_Assign(ClpDataSave!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. This copies the data
</member>
        <member name="M:ClpDataSave.#ctor(ClpDataSave!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor.
</member>
        <member name="M:ClpDataSave.#ctor">
@name Constructors and destructor

Default constructor
</member>
        <member name="T:ClpDataSave">
This is a tiny class where data can be saved round calls.

</member>
        <member name="F:ClpModel.strParam_">
Array of string parameters
</member>
        <member name="F:ClpModel.savedColumnScale_">
Saved column scale factors
</member>
        <member name="F:ClpModel.savedRowScale_">
Saved row scale factors for matrix
</member>
        <member name="F:ClpModel.baseRowCopy_">
Base row copy
</member>
        <member name="F:ClpModel.baseMatrix_">
Base packed matrix
</member>
        <member name="F:ClpModel.maximumInternalRows_">
Maximum number of rows (internal arrays) in model
</member>
        <member name="F:ClpModel.maximumInternalColumns_">
Maximum number of columns (internal arrays) in model
</member>
        <member name="F:ClpModel.maximumRows_">
Maximum number of rows in model
</member>
        <member name="F:ClpModel.maximumColumns_">
Maximum number of columns in model
</member>
        <member name="F:ClpModel.coinMessages_">
Coin messages
</member>
        <member name="F:ClpModel.messages_">
Messages
</member>
        <member name="F:ClpModel.columnNames_">
Column names
</member>
        <member name="F:ClpModel.rowNames_">
Row names
</member>
        <member name="F:ClpModel.eventHandler_">
Event handler
</member>
        <member name="F:ClpModel.randomNumberGenerator_">
Thread specific random number generator
</member>
        <member name="F:ClpModel.defaultHandler_">
Flag to say if default handler (so delete)
</member>
        <member name="F:ClpModel.handler_">
Message handler
</member>
        <member name="F:ClpModel.specialOptions_">
For advanced options
         See get and set for meaning

</member>
        <member name="F:ClpModel.numberThreads_">
Number of threads (not very operational)
</member>
        <member name="F:ClpModel.lengthNames_">
length of names (0 means no names)
</member>
        <member name="F:ClpModel.secondaryStatus_">
Secondary status of problem
</member>
        <member name="F:ClpModel.problemStatus_">
Status of problem
</member>
        <member name="F:ClpModel.whatsChanged_">
Whats changed since last solve.  This is a work in progress
         It is designed so careful people can make go faster.
         It is only used when startFinishOptions used in dual or primal.
         Bit 1 - number of rows/columns has not changed (so work arrays valid)
             2 - matrix has not changed
             4 - if matrix has changed only by adding rows
             8 - if matrix has changed only by adding columns
            16 - row lbs not changed
            32 - row ubs not changed
            64 - column objective not changed
           128 - column lbs not changed
           256 - column ubs not changed
       512 - basis not changed (up to user to set this to 0)
             top bits may be used internally
       shift by 65336 is 3 all same, 1 all except col bounds

</member>
        <member name="F:ClpModel.solveType_">
Solve type - 1 simplex, 2 simplex interface, 3 Interior.
</member>
        <member name="F:ClpModel.numberIterations_">
Number of iterations
</member>
        <member name="F:ClpModel.intParam_">
Array of integer parameters
</member>
        <member name="F:ClpModel.trustedUserPointer_">
Trusted user pointer e.g. for heuristics
</member>
        <member name="F:ClpModel.userPointer_">
User pointer for whatever reason
</member>
        <member name="F:ClpModel.integerType_">
Integer information
</member>
        <member name="F:ClpModel.status_">
Status (i.e. basis) Region.  I know that not all algorithms need a status
         array, but it made sense for things like crossover and put
         all permanent stuff in one place.  No assumption is made
         about what is in status array (although it might be good to reserve
         bottom 3 bits (i.e. 0-7 numeric) for classic status).  This
         is number of columns + number of rows long (in that order).

</member>
        <member name="F:ClpModel.scalingFlag_">
Scale flag, 0 none, 1 equilibrium, 2 geometric, 3, auto, 4 dynamic,
         5 geometric on rows 
</member>
        <member name="F:ClpModel.inverseColumnScale_">
Inverse column scale factors for matrix (end of columnScale_)
</member>
        <member name="F:ClpModel.inverseRowScale_">
Inverse row scale factors for matrix (end of rowScale_)
</member>
        <member name="F:ClpModel.columnScale_">
Column scale factors
</member>
        <member name="F:ClpModel.rowScale_">
Row scale factors for matrix
</member>
        <member name="F:ClpModel.ray_">
Infeasible/unbounded ray
</member>
        <member name="F:ClpModel.scaledMatrix_">
Scaled packed matrix
</member>
        <member name="F:ClpModel.rowCopy_">
Row copy if wanted
</member>
        <member name="F:ClpModel.matrix_">
Packed matrix
</member>
        <member name="F:ClpModel.columnUpper_">
Column Upper
</member>
        <member name="F:ClpModel.columnLower_">
Column Lower
</member>
        <member name="F:ClpModel.rowObjective_">
Row Objective (? sign)  - may be NULL
</member>
        <member name="F:ClpModel.objective_">
Objective
</member>
        <member name="F:ClpModel.rowUpper_">
Row upper
</member>
        <member name="F:ClpModel.rowLower_">
Row lower
</member>
        <member name="F:ClpModel.reducedCost_">
Reduced costs
</member>
        <member name="F:ClpModel.dual_">
Duals
</member>
        <member name="F:ClpModel.columnActivity_">
Column activities
</member>
        <member name="F:ClpModel.rowActivity_">
Row activities
</member>
        <member name="F:ClpModel.numberColumns_">
Number of columns
</member>
        <member name="F:ClpModel.numberRows_">
Number of rows
</member>
        <member name="F:ClpModel.rhsScale_">
Scaling of rhs and bounds
</member>
        <member name="F:ClpModel.objectiveScale_">
Scaling of objective
</member>
        <member name="F:ClpModel.smallElement_">
Small element value
</member>
        <member name="F:ClpModel.objectiveValue_">
Objective value
</member>
        <member name="F:ClpModel.dblParam_">
Array of double parameters
</member>
        <member name="F:ClpModel.optimizationDirection_">
@name data 
Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore
</member>
        <member name="M:ClpModel.onStopped">
On stopped - sets secondary status
</member>
        <member name="M:ClpModel.deleteNamesAsChar(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Delete char * version of names
</member>
        <member name="M:ClpModel.columnNamesAsChar">
Create column names as char **
</member>
        <member name="M:ClpModel.rowNamesAsChar">
Create row names as char **
</member>
        <member name="M:ClpModel.stopPermanentArrays">
Stop using maximumRows_ and Columns_
</member>
        <member name="M:ClpModel.startPermanentArrays">
Start using maximumRows_ and Columns_
</member>
        <member name="M:ClpModel.permanentArrays">
If we are using maximumRows_ and Columns_
</member>
        <member name="M:ClpModel.rawObjectiveValue">
Objective value - always minimize
</member>
        <member name="M:ClpModel.gutsOfScaling">
Does much of scaling
</member>
        <member name="M:ClpModel.gutsOfLoadModel(System.Int32,System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
puts in format I like - 4 array matrix - may make row copy
</member>
        <member name="M:ClpModel.getRowBound(System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
gets lower and upper bounds on rows
</member>
        <member name="M:ClpModel.gutsOfCopy(ClpModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Does most of copying
         If trueCopy 0 then just points to arrays
         If -1 leaves as much as possible 
</member>
        <member name="M:ClpModel.gutsOfDelete(System.Int32)">
@name private or protected methods 
Does most of deletion (0 = all, 1 = most)
</member>
        <member name="M:ClpModel.generateCpp(_iobuf*)">
Create C++ lines to get to current state
</member>
        <member name="M:ClpModel.setStrParam(ClpStrParam,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set an string parameter
</member>
        <member name="M:ClpModel.setDblParam(ClpDblParam,System.Double)">
Set an double parameter
</member>
        <member name="M:ClpModel.setIntParam(ClpIntParam,System.Int32)">
@name Parameter set/get methods

        The set methods return true if the parameter was set to the given value,
        false otherwise. There can be various reasons for failure: the given
        parameter is not applicable for the solver (e.g., refactorization
        frequency for the volume algorithm), the parameter is not yet implemented
        for the solver or simply the value of the parameter is out of the range
        the solver accepts. If a parameter setting call returns false check the
        details of your solver.

        The get methods return true if the given parameter is applicable for the
        solver and is implemented. In this case the value of the parameter is
        returned in the second argument. Otherwise they return false.

        ** once it has been decided where solver sits this may be redone

Set an integer parameter
</member>
        <member name="M:ClpModel.transposeTimes(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
Return <code>y + x * scalar * A</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numRows()</code>
         @pre <code>y</code> must be of size <code>numColumns()</code></member>
        <member name="M:ClpModel.times(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
@name Matrix times vector methods
        They can be faster if scalar is +- 1
        These are covers so user need not worry about scaling
        Also for simplex I am not using basic/non-basic split 
Return <code>y + A * x * scalar</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numColumns()</code>
         @pre <code>y</code> must be of size <code>numRows()</code></member>
        <member name="M:ClpModel.emptyProblem(System.Int32*,System.Double*,System.Boolean)">
Solve a problem with no elements - return status and
         dual and primal infeasibilites 
</member>
        <member name="M:ClpModel.objectiveAsObject">
Objective methods
</member>
        <member name="M:ClpModel.getColumnName(System.Int32)">
Return name or Cnnnnnnn
</member>
        <member name="M:ClpModel.columnNames">
Column names
</member>
        <member name="M:ClpModel.getRowName(System.Int32)">
Return name or Rnnnnnnn
</member>
        <member name="M:ClpModel.rowNames">
Row names
</member>
        <member name="M:ClpModel.setLengthNames(System.Int32)">
length of names (0 means no names0
</member>
        <member name="M:ClpModel.lengthNames">
length of names (0 means no names0
</member>
        <member name="M:ClpModel.setRandomSeed(System.Int32)">
Set seed for thread specific random number generator
</member>
        <member name="M:ClpModel.mutableRandomNumberGenerator">
Thread specific random number generator
</member>
        <member name="M:ClpModel.randomNumberGenerator">
Thread specific random number generator
</member>
        <member name="M:ClpModel.eventHandler">
Event handler
</member>
        <member name="M:ClpModel.passInEventHandler(ClpEventHandler!System.Runtime.CompilerServices.IsConst*)">
Pass in Event handler (cloned and deleted at end)
</member>
        <member name="M:ClpModel.defaultHandler">
Return true if default handler
</member>
        <member name="M:ClpModel.setLogLevel(System.Int32)">
Amount of print out:
         0 - none
         1 - just final
         2 - just factorizations
         3 - as 2 plus a bit more
         4 - verbose
         above that 8,16,32 etc just for selective debug

</member>
        <member name="M:ClpModel.coinMessagesPointer">
Return pointer to Coin messages
</member>
        <member name="M:ClpModel.coinMessages">
Return Coin messages
</member>
        <member name="M:ClpModel.messagesPointer">
Return pointer to messages
</member>
        <member name="M:ClpModel.messages">
Return messages
</member>
        <member name="M:ClpModel.messageHandler">
Return handler
</member>
        <member name="M:ClpModel.setDefaultMessageHandler">
Overrides message handler with a default one
</member>
        <member name="M:ClpModel.newLanguage(CoinMessages.Language)">
Set language
</member>
        <member name="M:ClpModel.popMessageHandler(CoinMessageHandler*,System.Boolean)">
back to previous message handler
</member>
        <member name="M:ClpModel.pushMessageHandler(CoinMessageHandler*,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Pass in Message handler (not deleted at end) and return current
</member>
        <member name="M:ClpModel.passInMessageHandler(CoinMessageHandler*)">
@name Message handling 
Pass in Message handler (not deleted at end)
</member>
        <member name="M:ClpModel.numberThreads">
Number of threads (not really being used)
</member>
        <member name="M:ClpModel.whatsChanged">
What has changed in model (only for masochistic users)
</member>
        <member name="M:ClpModel.setTrustedUserPointer(ClpTrustedData*)">
Trusted user pointer
</member>
        <member name="M:ClpModel.setUserPointer(System.Void*)">
User pointer for whatever reason
</member>
        <member name="M:ClpModel.copyinStatus(System.Byte!System.Runtime.CompilerServices.IsConst*)">
Copy in status (basis) vector
</member>
        <member name="M:ClpModel.statusCopy">
Return copy of status (i.e. basis) array (char[numberRows+numberColumns]),
         use delete [] 
</member>
        <member name="M:ClpModel.statusArray">
Return address of status (i.e. basis) array (char[numberRows+numberColumns])
</member>
        <member name="M:ClpModel.statusExists">
See if status (i.e. basis) array exists (partly for OsiClp)
</member>
        <member name="M:ClpModel.internalRay">
Access internal ray storage. Users should call infeasibilityRay() or unboundedRay() instead.
</member>
        <member name="M:ClpModel.deleteRay">
just delete ray if exists
</member>
        <member name="M:ClpModel.rayExists">
just test if infeasibility or unbounded Ray exists
</member>
        <member name="M:ClpModel.ray">
For advanced users - no need to delete - sign not changed
</member>
        <member name="M:ClpModel.infeasibilityRay(System.Boolean)">
Infeasibility/unbounded ray (NULL returned if none/wrong)
         Up to user to use delete [] on these arrays.  
</member>
        <member name="M:ClpModel.integerInformation">
Integer information
</member>
        <member name="M:ClpModel.objectiveValue">
Objective value
</member>
        <member name="M:ClpModel.replaceMatrix(CoinPackedMatrix*,System.Boolean)">
Replace Clp Matrix (current is not deleted unless told to
         and new is used) So up to user to delete current.  This was used where
         matrices were being rotated.  This version changes CoinPackedMatrix
         to ClpPackedMatrix.  ClpModel takes ownership.

</member>
        <member name="M:ClpModel.replaceMatrix(ClpMatrixBase*,System.Boolean)">
Replace Clp Matrix (current is not deleted unless told to
         and new is used)
         So up to user to delete current.  This was used where
         matrices were being rotated. ClpModel takes ownership.

</member>
        <member name="M:ClpModel.swapScaledMatrix(ClpPackedMatrix*)">
Swaps pointer to scaled ClpPackedMatrix
</member>
        <member name="M:ClpModel.setClpScaledMatrix(ClpPackedMatrix*)">
Sets pointer to scaled ClpPackedMatrix
</member>
        <member name="M:ClpModel.clpScaledMatrix">
Scaled ClpPackedMatrix
</member>
        <member name="M:ClpModel.clpMatrix">
Clp Matrix
</member>
        <member name="M:ClpModel.setNewRowCopy(ClpMatrixBase*)">
Set new row matrix
</member>
        <member name="M:ClpModel.rowCopy">
Row Matrix
</member>
        <member name="M:ClpModel.getSmallElementValue">
Small element value - elements less than this set to zero,
        default is 1.0e-20 
</member>
        <member name="M:ClpModel.getNumElements">
Number of elements in matrix
</member>
        <member name="M:ClpModel.matrix">
Matrix (if not ClpPackedmatrix be careful about memory leak
</member>
        <member name="M:ClpModel.columnUpper">
Column Upper
</member>
        <member name="M:ClpModel.columnLower">
Column Lower
</member>
        <member name="M:ClpModel.rowObjective">
Row Objective
</member>
        <member name="M:ClpModel.objective">
Objective
</member>
        <member name="M:ClpModel.scalingFlag">
Gets scalingFlag
</member>
        <member name="M:ClpModel.unscale">
If we constructed a "really" scaled model then this reverses the operation.
         Quantities may not be exactly as they were before due to rounding errors 
</member>
        <member name="M:ClpModel.scaling(System.Int32)">
Sets or unsets scaling, 0 -off, 1 equilibrium, 2 geometric, 3 auto, 4 auto-but-as-initialSolve-in-bab
</member>
        <member name="M:ClpModel.rhsScale">
Scaling of rhs and bounds
</member>
        <member name="M:ClpModel.objectiveScale">
Scaling of objective
</member>
        <member name="M:ClpModel.rowScale">
Scaling
</member>
        <member name="M:ClpModel.setRowBounds(System.Int32,System.Double,System.Double)">
Set a single row lower and upper bound 
</member>
        <member name="M:ClpModel.setColBounds(System.Int32,System.Double,System.Double)">
Set a single column lower and upper bound 
</member>
        <member name="M:ClpModel.setColumnBounds(System.Int32,System.Double,System.Double)">
Set a single column lower and upper bound 
</member>
        <member name="M:ClpModel.setObjCoeff(System.Int32,System.Double)">
Set an objective function coefficient 
</member>
        <member name="M:ClpModel.setObjectiveCoefficient(System.Int32,System.Double)">
@name Changing bounds on variables and constraints 
Set an objective function coefficient 
</member>
        <member name="M:ClpModel.rowUpper">
Row upper
</member>
        <member name="M:ClpModel.rowLower">
Row lower
</member>
        <member name="M:ClpModel.dualColumnSolution">
Reduced costs
</member>
        <member name="M:ClpModel.dualRowSolution">
Dual row solution
</member>
        <member name="M:ClpModel.primalColumnSolution">
Primal column solution
</member>
        <member name="M:ClpModel.primalRowSolution">
Primal row solution
</member>
        <member name="M:ClpModel.optimizationDirection">
Direction of optimization (1 - minimize, -1 - maximize, 0 - ignore
</member>
        <member name="M:ClpModel.isIterationLimitReached">
Iteration limit reached?
</member>
        <member name="M:ClpModel.isDualObjectiveLimitReached">
Is the given dual objective limit reached?
</member>
        <member name="M:ClpModel.isPrimalObjectiveLimitReached">
Is the given primal objective limit reached?
</member>
        <member name="M:ClpModel.isProvenDualInfeasible">
Is dual infeasiblity proven?
</member>
        <member name="M:ClpModel.isProvenPrimalInfeasible">
Is primal infeasiblity proven?
</member>
        <member name="M:ClpModel.isProvenOptimal">
Is optimality proven?
</member>
        <member name="M:ClpModel.isAbandoned">
Are there a numerical difficulties?
</member>
        <member name="M:ClpModel.secondaryStatus">
Secondary status of problem - may get extended
         0 - none
         1 - primal infeasible because dual limit reached OR (probably primal
         infeasible but can't prove it  - main status was 4)
         2 - scaled problem optimal - unscaled problem has primal infeasibilities
         3 - scaled problem optimal - unscaled problem has dual infeasibilities
         4 - scaled problem optimal - unscaled problem has primal and dual infeasibilities
         5 - giving up in primal with flagged variables
         6 - failed due to empty problem check
         7 - postSolve says not optimal
         8 - failed due to bad element check
         9 - status was 3 and stopped on time
	 10 - status was 3 but stopped as primal feasible
	 11 - status was 1/2 from presolve found infeasible or unbounded
         100 up - translation of enum from ClpEventHandler

</member>
        <member name="M:ClpModel.setProblemStatus(System.Int32)">
Set problem status
</member>
        <member name="M:ClpModel.status">
Status of problem:
         -1 - unknown e.g. before solve or if postSolve says not optimal
         0 - optimal
         1 - primal infeasible
         2 - dual infeasible
         3 - stopped on iterations or time
         4 - stopped due to errors
         5 - stopped by event handler (virtual int ClpEventHandler::event())

</member>
        <member name="M:ClpModel.hitMaximumIterations">
Returns true if hit maximum iterations (or time)
</member>
        <member name="M:ClpModel.maximumSeconds">
Maximum time in seconds (from when set called)
</member>
        <member name="M:ClpModel.maximumIterations">
Maximum number of iterations
</member>
        <member name="M:ClpModel.solveType">
Solve type - 1 simplex, 2 simplex interface, 3 Interior.
</member>
        <member name="M:ClpModel.numberIterations">
Number of iterations
</member>
        <member name="M:ClpModel.presolveTolerance">
Presolve tolerance to use
</member>
        <member name="M:ClpModel.objectiveOffset">
Objective offset
</member>
        <member name="M:ClpModel.dualObjectiveLimit">
Dual objective limit
</member>
        <member name="M:ClpModel.primalObjectiveLimit">
Primal objective limit
</member>
        <member name="M:ClpModel.dualTolerance">
Dual tolerance to use
</member>
        <member name="M:ClpModel.primalTolerance">
Primal tolerance to use
</member>
        <member name="M:ClpModel.getNumCols">
Number of columns
</member>
        <member name="M:ClpModel.numberRows">
@name gets and sets 
Number of rows
</member>
        <member name="M:ClpModel.createCoinModel">
This creates a coinModel object

</member>
        <member name="M:ClpModel.findNetwork(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Double)">
Find a network subset.
         rotate array should be numberRows.  On output
         -1 not in network
          0 in network as is
          1 in network with signs swapped
         Returns number of network rows

</member>
        <member name="M:ClpModel.setColumnName(System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set name of col
</member>
        <member name="M:ClpModel.setRowName(System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Set name of row
</member>
        <member name="M:ClpModel.copyColumnNames(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Copies in Column names - modifies names first .. last-1
</member>
        <member name="M:ClpModel.copyRowNames(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)">
Copies in Row names - modifies names first .. last-1
</member>
        <member name="M:ClpModel.copyColumnNames(std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
Copies in Column names - modifies names first .. last-1
</member>
        <member name="M:ClpModel.copyRowNames(std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
Copies in Row names - modifies names first .. last-1
</member>
        <member name="M:ClpModel.copyNames(std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!Syste">
Copies in names
</member>
        <member name="M:ClpModel.dropNames">
Drops names - makes lengthnames 0 and names empty
</member>
        <member name="M:ClpModel.copy(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*,ClpMatrixBase**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy contents - resizing if necessary - otherwise re-use memory
</member>
        <member name="M:ClpModel.cleanMatrix(System.Double)">
Really clean up matrix (if ClpPackedMatrix).
         a) eliminate all duplicate AND small elements in matrix
         b) remove all gaps and set extraGap_ and extraMajor_ to 0.0
         c) reallocate arrays and make max lengths equal to lengths
         d) orders elements
         returns number of elements eliminated or -1 if not ClpPackedMatrix

</member>
        <member name="M:ClpModel.createEmptyMatrix">
Create empty ClpPackedMatrix
</member>
        <member name="M:ClpModel.returnModel(ClpModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Return model - nulls all arrays so can be deleted safely
         also updates any scalars 
</member>
        <member name="M:ClpModel.borrowModel(ClpModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Borrow model.  This is so we don't have to copy large amounts
         of data around.  It assumes a derived class wants to overwrite
         an empty model with a real one - while it does an algorithm 
</member>
        <member name="M:ClpModel.chgObjCoefficients(System.Double!System.Runtime.CompilerServices.IsConst*)">
Change objective coefficients 
</member>
        <member name="M:ClpModel.chgColumnUpper(System.Double!System.Runtime.CompilerServices.IsConst*)">
Change column upper bounds 
</member>
        <member name="M:ClpModel.chgColumnLower(System.Double!System.Runtime.CompilerServices.IsConst*)">
Change column lower bounds 
</member>
        <member name="M:ClpModel.chgRowUpper(System.Double!System.Runtime.CompilerServices.IsConst*)">
Change row upper bounds 
</member>
        <member name="M:ClpModel.chgRowLower(System.Double!System.Runtime.CompilerServices.IsConst*)">
Change row lower bounds 
</member>
        <member name="M:ClpModel.modifyCoefficient(System.Int32,System.Int32,System.Double,System.Boolean)">
Modify one element of a matrix
</member>
        <member name="M:ClpModel.addColumns(CoinModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Add columns from a model object.  returns
         -1 if object in bad state (i.e. has row information)
         otherwise number of errors
         modelObject non const as can be regularized as part of build
         If tryPlusMinusOne then will try adding as +-1 matrix
         if no matrix exists.

</member>
        <member name="M:ClpModel.addColumns(CoinBuild!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Add columns from a build object
         If tryPlusMinusOne then will try adding as +-1 matrix
         if no matrix exists.
         Returns number of errors e.g. duplicates

</member>
        <member name="M:ClpModel.addColumns(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Add columns
</member>
        <member name="M:ClpModel.addColumn(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double,System.Double)">
Add one column
</member>
        <member name="M:ClpModel.deleteRowsAndColumns(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Deletes rows AND columns (keeps old sizes)
</member>
        <member name="M:ClpModel.deleteColumns(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Deletes columns
</member>
        <member name="M:ClpModel.addRows(CoinModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Add rows from a model object.  returns
         -1 if object in bad state (i.e. has column information)
         otherwise number of errors.

         modelObject non const as can be regularized as part of build
         If tryPlusMinusOne then will try adding as +-1 matrix
         if no matrix exists.

</member>
        <member name="M:ClpModel.addRows(CoinBuild!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean)">
Add rows from a build object.
         If tryPlusMinusOne then will try adding as +-1 matrix
         if no matrix exists.
         Returns number of errors e.g. duplicates

</member>
        <member name="M:ClpModel.addRows(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Add rows
</member>
        <member name="M:ClpModel.addRows(System.Int32,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Add rows
</member>
        <member name="M:ClpModel.addRow(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double)">
Add one row
</member>
        <member name="M:ClpModel.deleteRows(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Deletes rows
</member>
        <member name="M:ClpModel.synchronizeMatrix">
Makes sure matrix dimensions are at least model dimensions
</member>
        <member name="M:ClpModel.resize(System.Int32,System.Int32)">
Resizes rim part of model
</member>
        <member name="M:ClpModel.isInteger(System.Int32)">
Return true if the index-th variable is an integer variable 
</member>
        <member name="M:ClpModel.setInteger(System.Int32)">
Set the index-th variable to be an integer variable 
</member>
        <member name="M:ClpModel.setContinuous(System.Int32)">
Set the index-th variable to be a continuous variable 
</member>
        <member name="M:ClpModel.deleteIntegerInformation">
Drop integer informations
</member>
        <member name="M:ClpModel.copyInIntegerInformation(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Copy in integer informations
</member>
        <member name="M:ClpModel.readGMPL(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
Read GMPL files from the given filenames
</member>
        <member name="M:ClpModel.readMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
Read an mps file from the given filename
</member>
        <member name="M:ClpModel.setRowObjective(System.Double!System.Runtime.CompilerServices.IsConst*)">
This just loads up a row objective
</member>
        <member name="M:ClpModel.deleteQuadraticObjective">
Get rid of quadratic objective
</member>
        <member name="M:ClpModel.loadQuadraticObjective(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Load up quadratic objective.  This is stored as a CoinPackedMatrix 
</member>
        <member name="M:ClpModel.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
This one is for after presolve to save memory
</member>
        <member name="M:ClpModel.loadProblem(CoinModel*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
This loads a model from a coinModel object - returns number of errors.

         modelObject not const as may be changed as part of process
         If tryPlusMinusOne then will try adding as +-1 matrix

</member>
        <member name="M:ClpModel.loadProblem(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Just like the other loadProblem() method except that the matrix is
       given in a standard column major ordered format (without gaps). 
</member>
        <member name="M:ClpModel.Dispose">
Destructor
</member>
        <member name="M:ClpModel.#ctor(ClpModel!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Boolean)">
Subproblem constructor.  A subset of whole model is created from the
         row and column lists given.  The new order is given by list order and
         duplicates are allowed.  Name and integer information can be dropped

</member>
        <member name="M:ClpModel.op_Assign(ClpModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. This copies the data
</member>
        <member name="M:ClpModel.#ctor(ClpModel!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Copy constructor. May scale depending on mode
         -1 leave mode as is
         0 -off, 1 equilibrium, 2 geometric, 3, auto, 4 auto-but-as-initialSolve-in-bab

</member>
        <member name="M:ClpModel.#ctor(System.Boolean)">
@name Constructors and destructor
        Note - copy methods copy ALL data so can chew up memory
        until other copy is freed

Default constructor
</member>
        <member name="T:CoinBuild">
This is the base class for Linear and quadratic Models
    This knows nothing about the algorithm, but it seems to
    have a reasonable amount of information

    I would welcome suggestions for what should be in this and
    how it relates to OsiSolverInterface.  Some methods look
    very similar.


</member>
        <member name="F:ClpObjective.activated_">
Whether activated
</member>
        <member name="F:ClpObjective.type_">
Type of objective - linear is 1
</member>
        <member name="F:ClpObjective.offset_">
@name Protected member data
Value of non-linear part of objective
</member>
        <member name="M:ClpObjective.nonlinearOffset">
Objective offset
</member>
        <member name="M:ClpObjective.setActivated(System.Int32)">
Set whether activated
</member>
        <member name="M:ClpObjective.activated">
Whether activated
</member>
        <member name="M:ClpObjective.setType(System.Int32)">
Sets type (above 63 is extra information)
</member>
        <member name="M:ClpObjective.type">
@name Other
Returns type (above 63 is extra information)
</member>
        <member name="M:ClpObjective.subsetClone(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset clone.  Duplicates are allowed
         and order is as given.
         Derived classes need not provide this as it may not always make
         sense 
</member>
        <member name="M:ClpObjective.clone">
Clone
</member>
        <member name="M:ClpObjective.Dispose">
Destructor
</member>
        <member name="M:ClpObjective.op_Assign(ClpObjective!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:ClpObjective.#ctor(ClpObjective!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:ClpObjective.#ctor">
@name Constructors and destructors
Default Constructor
</member>
        <member name="M:ClpObjective.newXValues">
Say we have new primal solution - so may need to recompute
</member>
        <member name="M:ClpObjective.markNonlinear(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*)">
Given a zeroed array sets nonlinear columns to 1.
         Returns number of nonlinear columns

</member>
        <member name="M:ClpObjective.reallyScale(System.Double!System.Runtime.CompilerServices.IsConst*)">
Scale objective
</member>
        <member name="M:ClpObjective.deleteSome(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete columns in  objective
</member>
        <member name="M:ClpObjective.resize(System.Int32)">
Resize objective
</member>
        <member name="M:ClpObjective.objectiveValue(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Return objective value (without any ClpModel offset) (model may be NULL)
</member>
        <member name="M:ClpObjective.stepLength(ClpSimplex*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns step length which gives minimum of objective for
         solution + theta * change vector up to maximum theta.

         arrays are numberColumns+numberRows
         Also sets current objective, predicted  and at maximumTheta

</member>
        <member name="M:ClpObjective.reducedGradient(ClpSimplex*,System.Double*,System.Boolean)">
Returns reduced gradient.Returns an offset (to be added to current one).

</member>
        <member name="M:ClpObjective.gradient(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Int32)">
@name Stuff
Returns gradient.  If Linear then solution may be NULL,
         also returns an offset (to be added to current one)
         If refresh is false then uses last solution
         Uses model for scaling
         includeLinear 0 - no, 1 as is, 2 as feasible

</member>
        <member name="T:ClpObjective">
Objective Abstract Base Class

Abstract Base Class for describing an objective function


</member>
        <member name="F:ClpLastStrParam">
Just a marker, so that we can allocate a static sized array to store
         parameters. 
</member>
        <member name="F:ClpProbName">
Name of the problem. This is the found on the Name card of
         an mps file. 
</member>
        <member name="F:ClpLastDblParam">
Just a marker, so that we can allocate a static sized array to store
         parameters. 
</member>
        <member name="F:ClpPresolveTolerance">
Tolerance to use in presolve
</member>
        <member name="F:ClpMaxWallSeconds">
Maximum wallclock running time in seconds - after, this action is as max iterations
</member>
        <member name="F:ClpMaxSeconds">
Maximum time in seconds - after, this action is as max iterations
</member>
        <member name="F:ClpObjOffset">
Objective function constant. This the value of the constant term in
         the objective function. 
</member>
        <member name="F:ClpPrimalTolerance">
The maximum amount the primal constraints can be violated and still be
         considered feasible. 
</member>
        <member name="F:ClpDualTolerance">
The maximum amount the dual constraints can be violated and still be
         considered feasible. 
</member>
        <member name="F:ClpPrimalObjectiveLimit">
Primal objective limit. This is to be used as a termination
         criteria in methods where the primal objective monotonically changes
         (e.g., primal simplex) 
</member>
        <member name="F:ClpDualObjectiveLimit">
Set Dual objective limit. This is to be used as a termination criteria
         in methods where the dual objective monotonically changes (dual
         simplex). 
</member>
        <member name="T:ClpIntParam">
This is where to put any useful stuff.


</member>
        <member name="F:ClpLastIntParam">
Just a marker, so that we can allocate a static sized array to store
         parameters. 
</member>
        <member name="F:ClpNameDiscipline">
The name discipline; specifies how the solver will handle row and
         column names.
       - 0: Auto names: Names cannot be set by the client. Names of the form
        Rnnnnnnn or Cnnnnnnn are generated on demand when a name for a
        specific row or column is requested; nnnnnnn is derived from the row
        or column index. Requests for a vector of names return a vector with
        zero entries.
       - 1: Lazy names: Names supplied by the client are retained. Names of the
        form Rnnnnnnn or Cnnnnnnn are generated on demand if no name has been
        supplied by the client. Requests for a vector of names return a
        vector sized to the largest index of a name supplied by the client;
        some entries in the vector may be null strings.
       - 2: Full names: Names supplied by the client are retained. Names of the
        form Rnnnnnnn or Cnnnnnnn are generated on demand if no name has been
        supplied by the client. Requests for a vector of names return a
        vector sized to match the constraint system, and all entries will
        contain either the name specified by the client or a generated name.

</member>
        <member name="F:ClpMaxNumIterationHotStart">
The maximum number of iterations Clp can execute in hotstart before
         terminating 
</member>
        <member name="F:ClpMaxNumIteration">
The maximum number of iterations Clp can execute in the simplex methods

</member>
        <member name="F:ClpPackedMatrix3.ifActive_">
If active
</member>
        <member name="F:ClpPackedMatrix3.block_">
Blocks (ordinary start at 0 and go to first block)
</member>
        <member name="F:ClpPackedMatrix3.temporary_">
Temporary work area (aligned)
</member>
        <member name="F:ClpPackedMatrix3.element_">
Elements
</member>
        <member name="F:ClpPackedMatrix3.row_">
Rows
</member>
        <member name="F:ClpPackedMatrix3.start_">
Starts for odd/long vectors??
</member>
        <member name="F:ClpPackedMatrix3.column_">
Column indices and reverse lookup (within block)
</member>
        <member name="F:ClpPackedMatrix3.maxBlockSize_">
Maximum size of any block
</member>
        <member name="F:ClpPackedMatrix3.numberElements_">
Number of elements (including gaps)
</member>
        <member name="F:ClpPackedMatrix3.numberColumnsWithGaps_">
Number of columns including gaps
</member>
        <member name="F:ClpPackedMatrix3.numberColumns_">
Number of columns
</member>
        <member name="F:ClpPackedMatrix3.numberBlocks_">
Get temporary array (aligned)
@name Data members
        The data members are protected to allow access for derived classes. 
Number of blocks
</member>
        <member name="M:ClpPackedMatrix3.redoInfeasibilities(ClpSimplex!System.Runtime.CompilerServices.IsConst*,ClpPrimalColumnSteepest*,System.Int32)">
type - 1 redo infeasible, 2 choose sequenceIn, 3 both
returns sequenceIn (or -1) for type 2

</member>
        <member name="M:ClpPackedMatrix3.checkBlocks(ClpSimplex!System.Runtime.CompilerServices.IsConst*)">
Debug - check blocks 
</member>
        <member name="M:ClpPackedMatrix3.swapOne(System.Int32,System.Int32,System.Int32)">
Part of above
</member>
        <member name="M:ClpPackedMatrix3.swapOne(ClpSimplex!System.Runtime.CompilerServices.IsConst*,ClpPackedMatrix!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Swap one variable
</member>
        <member name="M:ClpPackedMatrix3.sortBlocks(ClpSimplex!System.Runtime.CompilerServices.IsConst*)">
@name Sort methods 
Sort blocks 
</member>
        <member name="M:ClpPackedMatrix3.#ctor(ClpPackedMatrix3!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:ClpPackedMatrix3.Dispose">
Destructor 
</member>
        <member name="M:ClpPackedMatrix3.#ctor(ClpSimplex*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*)">
Constructor from copy. 
</member>
        <member name="M:ClpPackedMatrix3.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpPackedMatrix3.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*)">
This version does dualColumn0
Updates two arrays for steepest
</member>
        <member name="F:ClpPackedMatrix2.work_">
work arrays
</member>
        <member name="F:ClpPackedMatrix2.column_">
columns within block
</member>
        <member name="F:ClpPackedMatrix2.rowStart_">
Row starts
</member>
        <member name="F:ClpPackedMatrix2.count_">
Counts of elements in each part of row
</member>
        <member name="F:ClpPackedMatrix2.offset_">
Column offset for each block (plus one at end)
</member>
        <member name="F:ClpPackedMatrix2.numberRows_">
Number of rows
</member>
        <member name="F:ClpPackedMatrix2.numberBlocks_">
@name Data members
        The data members are protected to allow access for derived classes. 
Number of blocks
</member>
        <member name="M:ClpPackedMatrix2.#ctor(ClpPackedMatrix2!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:ClpPackedMatrix2.Dispose">
Destructor 
</member>
        <member name="M:ClpPackedMatrix2.#ctor(ClpSimplex*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*)">
Constructor from copy. 
</member>
        <member name="M:ClpPackedMatrix2.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpPackedMatrix2.usefulInfo">
Returns true if copy has useful information
</member>
        <member name="F:ClpPackedMatrix.columnCopy_">
Special column copy
</member>
        <member name="F:ClpPackedMatrix.rowCopy_">
Special row copy
</member>
        <member name="F:ClpPackedMatrix.flags_">
Flags -
         1 - has zero elements
         2 - has gaps
         4 - has special row copy
         8 - has special column copy
         16 - wants special column copy

</member>
        <member name="F:ClpPackedMatrix.numberActiveColumns_">
number of active columns (normally same as number of columns)
</member>
        <member name="F:ClpPackedMatrix.matrix_">
@name Data members
        The data members are protected to allow access for derived classes. 
Data
</member>
        <member name="M:ClpPackedMatrix.checkFlags(System.Int32)">
Check validity
</member>
        <member name="M:ClpPackedMatrix.clearCopies">
Gets rid of special copies
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesByRowEQ1(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by row n == 1 if packed
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesByRowEQ2(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by row n == 2 if packed
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesByRowGE3a(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Int32*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by row n &gt; 2 if packed - returns number nonzero
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesByRowGE3(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by row n &gt; 2 if packed - returns number nonzero
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesByRowGEK(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Int32,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by row n &gt; K if packed - returns number nonzero
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesScaled(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by column when scaled and skipping
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesUnscaled(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by column when not scaled and skipping
         and doing part of dualColumn 
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesUnscaled(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Byte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by column when not scaled and skipping
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesScaled(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by column when scaled
</member>
        <member name="M:ClpPackedMatrix.gutsOfTransposeTimesUnscaled(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst)">
Meat of transposeTimes by column when not scaled
</member>
        <member name="M:ClpPackedMatrix.correctSequence(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Correct sequence in and out to give true value
</member>
        <member name="M:ClpPackedMatrix.specialColumnCopy(ClpSimplex*)">
make special column copy
</member>
        <member name="M:ClpPackedMatrix.specialRowCopy(ClpSimplex*,ClpMatrixBase!System.Runtime.CompilerServices.IsConst*)">
make special row copy
</member>
        <member name="M:ClpPackedMatrix.subsetClone(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset clone (without gaps).  Duplicates are allowed
         and order is as given 
</member>
        <member name="M:ClpPackedMatrix.copy(ClpPackedMatrix!System.Runtime.CompilerServices.IsConst*)">
Copy contents - resizing if necessary - otherwise re-use memory
</member>
        <member name="M:ClpPackedMatrix.clone">
Clone
</member>
        <member name="M:ClpPackedMatrix.#ctor(CoinPackedMatrix*)">
This takes over ownership (for space reasons) 
</member>
        <member name="M:ClpPackedMatrix.#ctor(ClpPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset constructor (without gaps).  Duplicates are allowed
         and order is as given 
</member>
        <member name="M:ClpPackedMatrix.#ctor(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The copy constructor from an CoinPackedMatrix. 
</member>
        <member name="M:ClpPackedMatrix.#ctor(ClpPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Copy method 
The copy constructor. 
</member>
        <member name="M:ClpPackedMatrix.Dispose">
Destructor 
</member>
        <member name="M:ClpPackedMatrix.#ctor">
@name Constructors, destructor 
Default constructor. 
</member>
        <member name="M:ClpPackedMatrix.setNumberActiveColumns(System.Int32)">
Set number of active columns (normally same as number of columns)
</member>
        <member name="M:ClpPackedMatrix.numberActiveColumns">
number of active columns (normally same as number of columns)
</member>
        <member name="M:ClpPackedMatrix.checkGaps">
Sets flags_ correctly
</member>
        <member name="M:ClpPackedMatrix.flags">
Flags
</member>
        <member name="M:ClpPackedMatrix.wantsSpecialColumnCopy">
Do we want special column copy
</member>
        <member name="M:ClpPackedMatrix.zeros">
Are there zeros?
</member>
        <member name="M:ClpPackedMatrix.releaseSpecialColumnCopy">
Say we don't want special column copy
</member>
        <member name="M:ClpPackedMatrix.makeSpecialColumnCopy">
Say we want special column copy
</member>
        <member name="M:ClpPackedMatrix.setMatrixNull">
Just sets matrix_ to NULL so it can be used elsewhere.
         used in GUB

</member>
        <member name="M:ClpPackedMatrix.matrix">
@name Other 
Returns CoinPackedMatrix (non const)
</member>
        <member name="M:ClpPackedMatrix.useEffectiveRhs(ClpSimplex*)">
Sets up an effective RHS
</member>
        <member name="M:ClpPackedMatrix.subsetTimes2(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Double,System.Double,System.UInt32*,System.Double*,System.Double)">
Updates second array for steepest and does devex weights
</member>
        <member name="M:ClpPackedMatrix.transposeTimes2(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Double*,System.Double*,System.Double,System.Double,System.UInt32*,System.Double*,System.Double)">
Updates two arrays for steepest and does devex weights 
	 Returns nonzero if updates reduced cost and infeas -
	 new infeas in dj1 
</member>
        <member name="M:ClpPackedMatrix.canCombine(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*)">
Returns true if can combine transposeTimes and subsetTransposeTimes
         and if it would be faster 
</member>
        <member name="M:ClpPackedMatrix.subsetTransposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)">
Return <code>x *A</code> in <code>z</code> but
     just for indices in y.
     Note - z always packed mode 
</member>
        <member name="M:ClpPackedMatrix.transposeTimesSubset(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
Return <code>y - pi * A</code> in <code>y</code>.
         @pre <code>pi</code> must be of size <code>numRows()</code>
         @pre <code>y</code> must be of size <code>numColumns()</code>
     This just does subset (but puts in correct place in y) 
</member>
        <member name="M:ClpPackedMatrix.transposeTimes(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
And for scaling
</member>
        <member name="M:ClpPackedMatrix.transposeTimes(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
Return <code>y + x * scalar * A</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numRows()</code>
         @pre <code>y</code> must be of size <code>numColumns()</code></member>
        <member name="M:ClpPackedMatrix.times(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
And for scaling
</member>
        <member name="M:ClpPackedMatrix.times(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
@name Matrix times vector methods 
Return <code>y + A * scalar *x</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numColumns()</code>
         @pre <code>y</code> must be of size <code>numRows()</code></member>
        <member name="M:ClpPackedMatrix.setDimensions(System.Int32,System.Int32)">
Set the dimensions of the matrix. In effect, append new empty
         columns/rows to the matrix. A negative number for either dimension
         means that that dimension doesn't change. Otherwise the new dimensions
         MUST be at least as large as the current ones otherwise an exception
         is thrown. 
</member>
        <member name="M:ClpPackedMatrix.refresh(ClpSimplex*)">
makes sure active columns correct
</member>
        <member name="M:ClpPackedMatrix.partialPricing(ClpSimplex*,System.Double,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Partial pricing
</member>
        <member name="M:ClpPackedMatrix.canDoPartialPricing">
Says whether it can do partial pricing
</member>
        <member name="M:ClpPackedMatrix.dubiousWeights(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Int32*)">
Given positive integer weights for each row fills in sum of weights
         for each column (and slack).
         Returns weights vector

</member>
        <member name="M:ClpPackedMatrix.releasePackedMatrix">
Allow any parts of a created CoinPackedMatrix to be deleted
</member>
        <member name="M:ClpPackedMatrix.add(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Int32,System.Double)">
Adds multiple of a column into an array 
</member>
        <member name="M:ClpPackedMatrix.add(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Int32,System.Double)">
Adds multiple of a column into an CoinIndexedvector
         You can use quickAdd to add to vector 
</member>
        <member name="M:ClpPackedMatrix.unpackPacked(ClpSimplex*,CoinIndexedVector*,System.Int32)">
Unpacks a column into an CoinIndexedvector
      ** in packed foramt
         Note that model is NOT const.  Bounds and objective could
         be modified if doing column generation (just for this variable) 
</member>
        <member name="M:ClpPackedMatrix.unpack(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Int32)">
Unpacks a column into an CoinIndexedvector

</member>
        <member name="M:ClpPackedMatrix.rangeOfElements(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns largest and smallest elements of both signs.
         Largest refers to largest absolute value.

</member>
        <member name="M:ClpPackedMatrix.allElementsInRange(ClpModel*,System.Double,System.Double,System.Int32)">
Checks if all elements are in valid range.  Can just
         return true if you are not paranoid.  For Clp I will
         probably expect no zeros.  Code can modify matrix to get rid of
         small elements.
         check bits (can be turned off to save time) :
         1 - check if matrix has gaps
         2 - check if zero elements
         4 - check and compress duplicates
         8 - report on large and small

</member>
        <member name="M:ClpPackedMatrix.scaledColumnCopy(ClpModel*)">
Realy really scales column copy
         Only called if scales already exist.
         Up to user ro delete 
</member>
        <member name="M:ClpPackedMatrix.createScaledMatrix(ClpSimplex*)">
Creates scaled column copy if scales exist
</member>
        <member name="M:ClpPackedMatrix.scaleRowCopy(ClpModel*)">
Scales rowCopy if column copy scaled
         Only called if scales already exist 
</member>
        <member name="M:ClpPackedMatrix.scale(ClpModel*,ClpSimplex*)">
Creates scales for column copy (rowCopy in model may be modified)
         returns non-zero if no scaling done 
</member>
        <member name="M:ClpPackedMatrix.fillBasis(ClpSimplex*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Double*)">
Fills in column part of basis
</member>
        <member name="M:ClpPackedMatrix.countBasis(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns number of elements in column part of basis
</member>
        <member name="M:ClpPackedMatrix.reverseOrderedCopy">
Returns a new matrix in reverse order without gaps 
</member>
        <member name="M:ClpPackedMatrix.modifyCoefficient(System.Int32,System.Int32,System.Double,System.Boolean)">
Modify one element of packed matrix.  An element may be added.
         This works for either ordering If the new element is zero it will be
         deleted unless keepZero true 
</member>
        <member name="M:ClpPackedMatrix.replaceVector(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst*)">
Replace the elements of a vector.  The indices remain the same.
         This is only needed if scaling and a row copy is used.
         At most the number specified will be replaced.
         The index is between 0 and major dimension of matrix 
</member>
        <member name="M:ClpPackedMatrix.appendMatrix(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Append a set of rows/columns to the end of the matrix. Returns number of errors
         i.e. if any of the new rows/columns contain an index that's larger than the
         number of columns-1/rows-1 (if numberOther&gt;0) or duplicates
         If 0 then rows, 1 if columns 
</member>
        <member name="M:ClpPackedMatrix.appendRows(System.Int32,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append Rows
</member>
        <member name="M:ClpPackedMatrix.appendCols(System.Int32,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append Columns
</member>
        <member name="M:ClpPackedMatrix.deleteRows(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the rows whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:ClpPackedMatrix.deleteCols(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the columns whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:ClpPackedMatrix.getVectorLength(System.Int32)">
The length of a single major-dimension vector. 
</member>
        <member name="M:ClpPackedMatrix.getVectorLengths">
The lengths of the major-dimension vectors. 
</member>
        <member name="M:ClpPackedMatrix.getIndices">
A vector containing the minor indices of the elements in the packed
          matrix. Note that there might be gaps in this list, entries that do not
          belong to any major-dimension vector. To get the actual elements one
          should look at this vector together with vectorStarts and
          vectorLengths. 
</member>
        <member name="M:ClpPackedMatrix.getMutableElements">
Mutable elements
</member>
        <member name="M:ClpPackedMatrix.getElements">
A vector containing the elements in the packed matrix. Note that there
         might be gaps in this list, entries that do not belong to any
         major-dimension vector. To get the actual elements one should look at
         this vector together with vectorStarts and vectorLengths. 
</member>
        <member name="M:ClpPackedMatrix.getNumRows">
Number of rows. 
</member>
        <member name="M:ClpPackedMatrix.getNumCols">
Number of columns. 
</member>
        <member name="M:ClpPackedMatrix.getNumElements">
Number of entries in the packed matrix. 
</member>
        <member name="M:ClpPackedMatrix.isColOrdered">
Whether the packed matrix is column major ordered or not. 
</member>
        <member name="M:ClpPackedMatrix.getPackedMatrix">
@name Useful methods 
Return a complete CoinPackedMatrix
</member>
        <member name="T:ClpPackedMatrix2">
This implements CoinPackedMatrix as derived from ClpMatrixBase.

    It adds a few methods that know about model as well as matrix

    For details see CoinPackedMatrix 
</member>
        <member name="F:ClpPrimalColumnSteepest.numberSwitched_">
Number of times switched from partial dantzig to 0/2
</member>
        <member name="F:ClpPrimalColumnSteepest.persistence_">
Life of weights
</member>
        <member name="F:ClpPrimalColumnSteepest.mode_">
         0 is exact devex, 1 full steepest, 2 is partial exact devex
         3 switches between 0 and 2 depending on factorization
         4 starts as partial dantzig/devex but then may switch between 0 and 2.
         5 is always partial dantzig
         By partial exact devex is meant that the weights are updated as normal
         but only part of the nonbasic variables are scanned.
         This can be faster on very easy problems.

         New dubious option is &gt;=10 which does mini-sprint


</member>
        <member name="F:ClpPrimalColumnSteepest.state_">
Status
         0) Normal
         -1) Needs initialization
         1) Weights are stored by sequence number

</member>
        <member name="F:ClpPrimalColumnSteepest.savedWeights_">
save weight array (so we can use checkpoint)
</member>
        <member name="F:ClpPrimalColumnSteepest.alternateWeights_">
alternate weight array (so we can unroll)
</member>
        <member name="F:ClpPrimalColumnSteepest.infeasible_">
square of infeasibility array (just for infeasible columns)
</member>
        <member name="F:ClpPrimalColumnSteepest.weights_">
weight array
</member>
        <member name="F:ClpPrimalColumnSteepest.devex_">
@name Protected member data
</member>
        <member name="M:ClpPrimalColumnSteepest.setPersistence(ClpPrimalColumnSteepest.Persistence)">
Set/ get persistence
</member>
        <member name="M:ClpPrimalColumnSteepest.reference(System.Int32)">
@name Private functions to deal with devex
reference would be faster using ClpSimplex's status_,
         but I prefer to keep modularity.

</member>
        <member name="M:ClpPrimalColumnSteepest.clone(System.Boolean)">
Clone
</member>
        <member name="M:ClpPrimalColumnSteepest.Dispose">
Destructor
</member>
        <member name="M:ClpPrimalColumnSteepest.op_Assign(ClpPrimalColumnSteepest!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:ClpPrimalColumnSteepest.#ctor(ClpPrimalColumnSteepest!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:ClpPrimalColumnSteepest.#ctor(System.Int32)">
@name Constructors and destructors
Default Constructor
         0 is exact devex, 1 full steepest, 2 is partial exact devex
         3 switches between 0 and 2 depending on factorization
         4 starts as partial dantzig/devex but then may switch between 0 and 2.
         By partial exact devex is meant that the weights are updated as normal
         but only part of the nonbasic variables are scanned.
         This can be faster on very easy problems.

</member>
        <member name="T:ClpPrimalColumnSteepest.Persistence">
enums for persistence

</member>
        <member name="M:ClpPrimalColumnSteepest.switchOffSprint">
Switch off sprint idea
</member>
        <member name="M:ClpPrimalColumnSteepest.numberSprintColumns(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns number of extra columns for sprint algorithm - 0 means off.
         Also number of iterations before recompute

</member>
        <member name="M:ClpPrimalColumnSteepest.alternateWeights">
alternate weight array
</member>
        <member name="M:ClpPrimalColumnSteepest.weights">
Weights
</member>
        <member name="M:ClpPrimalColumnSteepest.infeasible">
square of infeasibility array (just for infeasible columns)
</member>
        <member name="M:ClpPrimalColumnSteepest.setMode(System.Int32)">
Set mode
</member>
        <member name="M:ClpPrimalColumnSteepest.mode">
@name gets and sets 
Mode
</member>
        <member name="M:ClpPrimalColumnSteepest.maximumPivotsChanged">
Called when maximum pivots changes
</member>
        <member name="M:ClpPrimalColumnSteepest.looksOptimal">
Returns true if would not find any column
</member>
        <member name="M:ClpPrimalColumnSteepest.clearArrays">
Gets rid of all arrays
</member>
        <member name="M:ClpPrimalColumnSteepest.unrollWeights">
Gets rid of last update
</member>
        <member name="M:ClpPrimalColumnSteepest.redoInfeasibilities">
redo infeasibilities
</member>
        <member name="M:ClpPrimalColumnSteepest.saveWeights(ClpSimplex*,System.Int32)">
Save weights - this may initialize weights as well
         mode is -
         1) before factorization
         2) after factorization
         3) just redo infeasibilities
         4) restore weights
         5) at end of values pass (so need initialization)

</member>
        <member name="M:ClpPrimalColumnSteepest.initializeWeights">
Initialize weights
</member>
        <member name="M:ClpPrimalColumnSteepest.checkAccuracy(System.Int32,System.Double,CoinIndexedVector*,CoinIndexedVector*)">
Checks accuracy - just for debug
</member>
        <member name="M:ClpPrimalColumnSteepest.updateWeights(CoinIndexedVector*)">
Updates weights - part 1 - also checks accuracy
</member>
        <member name="M:ClpPrimalColumnSteepest.transposeTimes2(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*,System.Double)">
Updates two arrays for steepest
</member>
        <member name="M:ClpPrimalColumnSteepest.justSteepest(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Update weights for Steepest
</member>
        <member name="M:ClpPrimalColumnSteepest.justDevex(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Update weights for Devex
</member>
        <member name="M:ClpPrimalColumnSteepest.djsAndSteepest2(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Update djs, weights for Steepest using pivot row
</member>
        <member name="M:ClpPrimalColumnSteepest.djsAndDevex2(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Update djs, weights for Devex using pivot row
</member>
        <member name="M:ClpPrimalColumnSteepest.djsAndSteepest(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Update djs, weights for Steepest using djs
	 sets best sequence (possibly) 
</member>
        <member name="M:ClpPrimalColumnSteepest.djsAndDevex(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Update djs, weights for Devex using djs
</member>
        <member name="M:ClpPrimalColumnSteepest.partialPricing(CoinIndexedVector*,CoinIndexedVector*,System.Int32,System.Int32)">
Update djs doing partial pricing (dantzig)
</member>
        <member name="M:ClpPrimalColumnSteepest.justDjs(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
Just update djs
</member>
        <member name="M:ClpPrimalColumnSteepest.pivotColumnOldMethod(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
For quadratic or funny nonlinearities
</member>
        <member name="M:ClpPrimalColumnSteepest.pivotColumn(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
@name Algorithmic methods
Returns pivot column, -1 if none.
         The Packed CoinIndexedVector updates has cost updates - for normal LP
         that is just +-weight where a feasibility changed.  It also has
         reduced cost from last iteration in pivot row
         Parts of operation split out into separate functions for
         profiling and speed

</member>
        <member name="T:ClpPrimalColumnSteepest">
Primal Column Pivot Steepest Edge Algorithm Class

See Forrest-Goldfarb paper for algorithm


</member>
        <member name="F:ClpPrimalColumnPivot.looksOptimal_">
Says if looks optimal (normally computed)
</member>
        <member name="F:ClpPrimalColumnPivot.type_">
Type of column pivot algorithm
</member>
        <member name="F:ClpPrimalColumnPivot.model_">
@name Protected member data
Pointer to model
</member>
        <member name="M:ClpPrimalColumnPivot.maximumPivotsChanged">
Called when maximum pivots changes
</member>
        <member name="M:ClpPrimalColumnPivot.switchOffSprint">
Switch off sprint idea
</member>
        <member name="M:ClpPrimalColumnPivot.numberSprintColumns(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns number of extra columns for sprint algorithm - 0 means off.
         Also number of iterations before recompute

</member>
        <member name="M:ClpPrimalColumnPivot.type">
Returns type (above 63 is extra information)
</member>
        <member name="M:ClpPrimalColumnPivot.setModel(ClpSimplex*)">
Sets model
</member>
        <member name="M:ClpPrimalColumnPivot.model">
@name Other
Returns model
</member>
        <member name="M:ClpPrimalColumnPivot.clone(System.Boolean)">
Clone
</member>
        <member name="M:ClpPrimalColumnPivot.Dispose">
Destructor
</member>
        <member name="M:ClpPrimalColumnPivot.op_Assign(ClpPrimalColumnPivot!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:ClpPrimalColumnPivot.#ctor(ClpPrimalColumnPivot!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:ClpPrimalColumnPivot.#ctor">
@name Constructors and destructors
Default Constructor
</member>
        <member name="M:ClpPrimalColumnPivot.setLooksOptimal(System.Boolean)">
Sets optimality flag (for advanced use)
</member>
        <member name="M:ClpPrimalColumnPivot.looksOptimal">
Returns true if would not find any column
</member>
        <member name="M:ClpPrimalColumnPivot.clearArrays">
Gets rid of all arrays (may be empty)
</member>
        <member name="M:ClpPrimalColumnPivot.pivotRow(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Signals pivot row choice:
         -2 (default) - use normal pivot row choice
         -1 to numberRows-1 - use this (will be checked)
         way should be -1 to go to lower bound, +1 to upper bound

</member>
        <member name="M:ClpPrimalColumnPivot.saveWeights(ClpSimplex*,System.Int32)">
Saves any weights round factorization as pivot rows may change
         Will be empty unless steepest edge (will save model)
         May also recompute infeasibility stuff
         1) before factorization
         2) after good factorization (if weights empty may initialize)
         3) after something happened but no factorization
            (e.g. check for infeasible)
         4) as 2 but restore weights from previous snapshot
         5) forces some initialization e.g. weights
         Also sets model

</member>
        <member name="M:ClpPrimalColumnPivot.updateWeights(CoinIndexedVector*)">
Updates weights - part 1 (may be empty)
</member>
        <member name="M:ClpPrimalColumnPivot.pivotColumn(CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*,CoinIndexedVector*)">
@name Algorithmic methods
Returns pivot column, -1 if none

         Normally updates reduced costs using result of last iteration
         before selecting incoming column.

         The Packed CoinIndexedVector updates has cost updates - for normal LP
         that is just +-weight where a feasibility changed.  It also has
         reduced cost from last iteration in pivot row

         Inside pivotColumn the pivotRow_ and reduced cost from last iteration
         are also used.

         So in the simplest case i.e. feasible we compute the row of the
         tableau corresponding to last pivot and add a multiple of this
         to current reduced costs.

         We can use other arrays to help updates

</member>
        <member name="T:ClpPrimalColumnPivot">
Primal Column Pivot Abstract Base Class

Abstract Base Class for describing an interface to an algorithm
to choose column pivot in primal simplex algorithm.  For some algorithms
e.g. Dantzig choice then some functions may be null.  For Dantzig
the only one of any importance is pivotColumn.

If  you wish to inherit from this look at ClpPrimalColumnDantzig.cpp
as that is simplest version.

</member>
        <member name="F:ClpMatrixBase.skipDualCheck_">
whether to skip dual checks most of time
</member>
        <member name="F:ClpMatrixBase.trueSequenceOut_">
True sequence out (i.e. from larger problem)
</member>
        <member name="F:ClpMatrixBase.trueSequenceIn_">
True sequence in (i.e. from larger problem)
</member>
        <member name="F:ClpMatrixBase.minimumGoodReducedCosts_">
Partial pricing tuning parameter - minimum number of negative reduced costs to get
</member>
        <member name="F:ClpMatrixBase.minimumObjectsScan_">
Partial pricing tuning parameter - minimum number of "objects" to scan
</member>
        <member name="F:ClpMatrixBase.refreshFrequency_">
If rhsOffset used this is refresh frequency (0==off)
</member>
        <member name="F:ClpMatrixBase.lastRefresh_">
If rhsOffset used this is iteration last refreshed
</member>
        <member name="F:ClpMatrixBase.type_">
type (may be useful)
</member>
        <member name="F:ClpMatrixBase.savedBestSequence_">
Saved best sequence in pricing
</member>
        <member name="F:ClpMatrixBase.currentWanted_">
Current number of negative reduced costs which we still need
</member>
        <member name="F:ClpMatrixBase.originalWanted_">
Initial number of negative reduced costs wanted
</member>
        <member name="F:ClpMatrixBase.savedBestDj_">
Best reduced cost so far
</member>
        <member name="F:ClpMatrixBase.endFraction_">
Current end of search space in matrix (as fraction)
</member>
        <member name="F:ClpMatrixBase.startFraction_">
Current start of search space in matrix (as fraction)
</member>
        <member name="F:ClpMatrixBase.rhsOffset_">
@name Data members
        The data members are protected to allow access for derived classes. 
Effective RHS offset if it is being used.  This is used for long problems
         or big gub or anywhere where going through full columns is
         expensive 
</member>
        <member name="M:ClpMatrixBase.Dispose">
Destructor (has to be public) 
</member>
        <member name="M:ClpMatrixBase.savedBestSequence">
Current best sequence
</member>
        <member name="M:ClpMatrixBase.currentWanted">
Current number of negative reduced costs which we still need
</member>
        <member name="M:ClpMatrixBase.originalWanted">
Initial number of negative reduced costs wanted
</member>
        <member name="M:ClpMatrixBase.savedBestDj">
Current best reduced cost
</member>
        <member name="M:ClpMatrixBase.endFraction">
Current end of search space in matrix (as fraction)
</member>
        <member name="M:ClpMatrixBase.startFraction">
Current start of search space in matrix (as fraction)
</member>
        <member name="M:ClpMatrixBase.minimumGoodReducedCosts">
Partial pricing tuning parameter - minimum number of negative reduced costs to get
</member>
        <member name="M:ClpMatrixBase.minimumObjectsScan">
Partial pricing tuning parameter - minimum number of "objects" to scan.
         e.g. number of Gub sets but could be number of variables 
</member>
        <member name="M:ClpMatrixBase.skipDualCheck">
whether to skip dual checks most of time
</member>
        <member name="M:ClpMatrixBase.refreshFrequency">
If rhsOffset used this is refresh frequency (0==off)
</member>
        <member name="M:ClpMatrixBase.lastRefresh">
If rhsOffset used this is iteration last refreshed
</member>
        <member name="M:ClpMatrixBase.rhsOffset(ClpSimplex*,System.Boolean,System.Boolean)">
Returns effective RHS offset if it is being used.  This is used for long problems
         or big gub or anywhere where going through full columns is
         expensive.  This may re-compute 
</member>
        <member name="M:ClpMatrixBase.useEffectiveRhs(ClpSimplex*)">
Sets up an effective RHS
</member>
        <member name="M:ClpMatrixBase.setType(System.Int32)">
Sets type
</member>
        <member name="M:ClpMatrixBase.type">
Returns type.
         The types which code may need to know about are:
         1  - ClpPackedMatrix
         11 - ClpNetworkMatrix
         12 - ClpPlusMinusOneMatrix

</member>
        <member name="M:ClpMatrixBase.backToBasics">
Gets rid of any mutable by products
</member>
        <member name="M:ClpMatrixBase.subsetClone(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset clone (without gaps).  Duplicates are allowed
         and order is as given.
         Derived classes need not provide this as it may not always make
         sense 
</member>
        <member name="M:ClpMatrixBase.clone">
@name Other
Clone
</member>
        <member name="M:ClpMatrixBase.listTransposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Int32*,System.Int32,System.Double*)">
Return <code>x *A</code> in <code>z</code> but
         just for number indices in y.
         Default cheats with fake CoinIndexedVector and
         then calls subsetTransposeTimes 
</member>
        <member name="M:ClpMatrixBase.subsetTimes2(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Double,System.Double,System.UInt32*,System.Double*,System.Double)">
Updates second array for steepest and does devex weights (need not be coded)
</member>
        <member name="M:ClpMatrixBase.transposeTimes2(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Double*,System.Double*,System.Double,System.Double,System.UInt32*,System.Double*,System.Double)">
Updates two arrays for steepest and does devex weights 
	 (need not be coded)
	 Returns nonzero if updates reduced cost and infeas -
	 new infeas in dj1 
</member>
        <member name="M:ClpMatrixBase.canCombine(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*)">
Returns true if can combine transposeTimes and subsetTransposeTimes
         and if it would be faster 
</member>
        <member name="M:ClpMatrixBase.subsetTransposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)">
Return <code>x *A</code> in <code>z</code> but
         just for indices in y.
         This is only needed for primal steepest edge.
         Note - z always packed mode 
</member>
        <member name="M:ClpMatrixBase.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)">
Return <code>x * scalar *A + y</code> in <code>z</code>.
         Can use y as temporary array (will be empty at end)
         Note - If x packed mode - then z packed mode
         Squashes small elements and knows about ClpSimplex 
</member>
        <member name="M:ClpMatrixBase.transposeTimes(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
And for scaling - default aborts for when scaling not supported
         (unless pointers NULL when as normal)

</member>
        <member name="M:ClpMatrixBase.transposeTimes(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
Return <code>y + x * scalar * A</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numRows()</code>
         @pre <code>y</code> must be of size <code>numColumns()</code></member>
        <member name="M:ClpMatrixBase.times(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
And for scaling - default aborts for when scaling not supported
         (unless pointers NULL when as normal)

</member>
        <member name="M:ClpMatrixBase.times(System.Double,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
@name Matrix times vector methods
        They can be faster if scalar is +- 1
        Also for simplex I am not using basic/non-basic split 
Return <code>y + A * x * scalar</code> in <code>y</code>.
         @pre <code>x</code> must be of size <code>numColumns()</code>
         @pre <code>y</code> must be of size <code>numRows()</code></member>
        <member name="M:ClpMatrixBase.correctSequence(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Correct sequence in and out to give true value (if both -1 maybe do whole matrix)
</member>
        <member name="M:ClpMatrixBase.reducedCost(ClpSimplex*,System.Int32)">
Returns reduced cost of a variable
</member>
        <member name="M:ClpMatrixBase.checkFeasible(ClpSimplex*,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Just for debug if odd type matrix.
         Returns number of primal infeasibilities. 
</member>
        <member name="M:ClpMatrixBase.createVariable(ClpSimplex*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a variable.  This is called after partial pricing and may modify matrix.
         May update bestSequence.

</member>
        <member name="M:ClpMatrixBase.updatePivot(ClpSimplex*,System.Double,System.Double)">
update information for a pivot (and effective rhs)

</member>
        <member name="M:ClpMatrixBase.generalExpanded(ClpSimplex*,System.Int32,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
         general utility function for dealing with dynamic constraints
         mode=0  - Create list of non-key basics in pivotVariable_ using
                   number as numberBasic in and out
         mode=1  - Set all key variables as basic
         mode=2  - return number extra rows needed, number gives maximum number basic
         mode=3  - before replaceColumn
         mode=4  - return 1 if can do primal, 2 if dual, 3 if both
         mode=5  - save any status stuff (when in good state)
         mode=6  - restore status stuff
         mode=7  - flag given variable (normally sequenceIn)
         mode=8  - unflag all variables
         mode=9  - synchronize costs and bounds
         mode=10  - return 1 if there may be changing bounds on variable (column generation)
         mode=11  - make sure set is clean (used when a variable rejected - but not flagged)
         mode=12  - after factorize but before permute stuff
         mode=13  - at end of simplex to delete stuff


</member>
        <member name="M:ClpMatrixBase.dualExpanded(ClpSimplex*,CoinIndexedVector*,System.Double*,System.Int32)">
utility dual function for dealing with dynamic constraints
mode=0  - Set up before "updateTranspose" and "transposeTimes" for duals using extended
          updates array (and may use other if dual values pass)
mode=1  - Update dual solution after "transposeTimes" using extended rows.
mode=2  - Compute all djs and compute key dual infeasibilities
mode=3  - Report on key dual infeasibilities
mode=4  - Modify before updateTranspose in partial pricing

</member>
        <member name="M:ClpMatrixBase.primalExpanded(ClpSimplex*,System.Int32)">
utility primal function for dealing with dynamic constraints
mode=0  - Set up before "update" and "times" for primal solution using extended rows
mode=1  - Cleanup primal solution after "times" using extended rows.
mode=2  - Check (or report on) primal infeasibilities

</member>
        <member name="M:ClpMatrixBase.extendUpdated(ClpSimplex*,CoinIndexedVector*,System.Int32)">
expands an updated column to allow for extra rows which the main
         solver does not know about and returns number added.

         This will normally be a no-op - it is in for GUB but may get extended to
         general non-overlapping and embedded networks.

         mode 0 - extend
         mode 1 - delete etc

</member>
        <member name="M:ClpMatrixBase.partialPricing(ClpSimplex*,System.Double,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Partial pricing
</member>
        <member name="M:ClpMatrixBase.hiddenRows">
Returns number of hidden rows e.g. gub
</member>
        <member name="M:ClpMatrixBase.canDoPartialPricing">
Says whether it can do partial pricing
</member>
        <member name="M:ClpMatrixBase.releasePackedMatrix">
Allow any parts of a created CoinPackedMatrix to be deleted
</member>
        <member name="M:ClpMatrixBase.add(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double*,System.Int32,System.Double)">
Adds multiple of a column into an array 
</member>
        <member name="M:ClpMatrixBase.add(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Int32,System.Double)">
Adds multiple of a column into an CoinIndexedvector
         You can use quickAdd to add to vector 
</member>
        <member name="M:ClpMatrixBase.dubiousWeights(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Int32*)">
Given positive integer weights for each row fills in sum of weights
         for each column (and slack).
         Returns weights vector
         Default returns vector of ones

</member>
        <member name="M:ClpMatrixBase.refresh(ClpSimplex*)">
Purely for column generation and similar ideas.  Allows
         matrix and any bounds or costs to be updated (sensibly).
         Returns non-zero if any changes.

</member>
        <member name="M:ClpMatrixBase.unpackPacked(ClpSimplex*,CoinIndexedVector*,System.Int32)">
Unpacks a column into an CoinIndexedvector
      ** in packed format
      Note that model is NOT const.  Bounds and objective could
      be modified if doing column generation (just for this variable) 
</member>
        <member name="M:ClpMatrixBase.unpack(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,System.Int32)">
Unpacks a column into an CoinIndexedvector

</member>
        <member name="M:ClpMatrixBase.rangeOfElements(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns largest and smallest elements of both signs.
         Largest refers to largest absolute value.
         If returns zeros then can't tell anything 
</member>
        <member name="M:ClpMatrixBase.setDimensions(System.Int32,System.Int32)">
Set the dimensions of the matrix. In effect, append new empty
         columns/rows to the matrix. A negative number for either dimension
         means that that dimension doesn't change. Otherwise the new dimensions
         MUST be at least as large as the current ones otherwise an exception
         is thrown. 
</member>
        <member name="M:ClpMatrixBase.allElementsInRange(ClpModel*,System.Double,System.Double,System.Int32)">
Checks if all elements are in valid range.  Can just
         return true if you are not paranoid.  For Clp I will
         probably expect no zeros.  Code can modify matrix to get rid of
         small elements.
         check bits (can be turned off to save time) :
         1 - check if matrix has gaps
         2 - check if zero elements
         4 - check and compress duplicates
         8 - report on large and small

</member>
        <member name="M:ClpMatrixBase.scaledColumnCopy(ClpModel*)">
Realy really scales column copy
         Only called if scales already exist.
         Up to user to delete 
</member>
        <member name="M:ClpMatrixBase.canGetRowCopy">
Returns true if can create row copy
</member>
        <member name="M:ClpMatrixBase.scaleRowCopy(ClpModel*)">
Scales rowCopy if column copy scaled
         Only called if scales already exist 
</member>
        <member name="M:ClpMatrixBase.scale(ClpModel*,ClpSimplex*)">
Creates scales for column copy (rowCopy in model may be modified)
         default does not allow scaling
         returns non-zero if no scaling done 
</member>
        <member name="M:ClpMatrixBase.fillBasis(ClpSimplex*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Int32*,System.Int32*,System.Int32*,System.Double*)">
Fills in column part of basis
</member>
        <member name="M:ClpMatrixBase.countBasis(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Returns number of elements in column part of basis
</member>
        <member name="M:ClpMatrixBase.reverseOrderedCopy">
Returns a new matrix in reverse order without gaps
         Is allowed to return NULL if doesn't want to have row copy 
</member>
        <member name="M:ClpMatrixBase.appendMatrix(System.Int32,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Append a set of rows/columns to the end of the matrix. Returns number of errors
         i.e. if any of the new rows/columns contain an index that's larger than the
         number of columns-1/rows-1 (if numberOther&gt;0) or duplicates
         If 0 then rows, 1 if columns 
</member>
        <member name="M:ClpMatrixBase.modifyCoefficient(System.Int32,System.Int32,System.Double,System.Boolean)">
Modify one element of packed matrix.  An element may be added.
         This works for either ordering If the new element is zero it will be
         deleted unless keepZero true 
</member>
        <member name="M:ClpMatrixBase.appendRows(System.Int32,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append Rows
</member>
        <member name="M:ClpMatrixBase.appendCols(System.Int32,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append Columns
</member>
        <member name="M:ClpMatrixBase.deleteRows(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the rows whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:ClpMatrixBase.deleteCols(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the columns whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:ClpMatrixBase.getVectorLength(System.Int32)">
The length of a single major-dimension vector. 
</member>
        <member name="M:ClpMatrixBase.getVectorLengths">
The lengths of the major-dimension vectors. 
</member>
        <member name="M:ClpMatrixBase.getIndices">
A vector containing the minor indices of the elements in the packed
         matrix. Note that there might be gaps in this list, entries that do not
         belong to any major-dimension vector. To get the actual elements one
         should look at this vector together with vectorStarts and
         vectorLengths. 
</member>
        <member name="M:ClpMatrixBase.getElements">
A vector containing the elements in the packed matrix. Note that there
         might be gaps in this list, entries that do not belong to any
         major-dimension vector. To get the actual elements one should look at
         this vector together with vectorStarts and vectorLengths. 
</member>
        <member name="M:ClpMatrixBase.getNumRows">
Number of rows. 
</member>
        <member name="M:ClpMatrixBase.getNumCols">
Number of columns. 
</member>
        <member name="M:ClpMatrixBase.getNumElements">
Number of entries in the packed matrix. 
</member>
        <member name="M:ClpMatrixBase.isColOrdered">
Whether the packed matrix is column major ordered or not. 
</member>
        <member name="M:ClpMatrixBase.getPackedMatrix">
@name Virtual methods that the derived classes must provide 
Return a complete CoinPackedMatrix
</member>
        <member name="T:ClpMatrixBase">
Abstract base class for Clp Matrices

Since this class is abstract, no object of this type can be created.

If a derived class provides all methods then all Clp algorithms
should work.  Some can be very inefficient e.g. getElements etc is
only used for tightening bounds for dual and the copies are
deleted.  Many methods can just be dummy i.e. abort(); if not
all features are being used.  So if column generation was being done
then it makes no sense to do steepest edge so there would be
no point providing subsetTransposeTimes.

</member>
        <member name="M:COIN.OsiSolverInterface.getObjSense">
Get objective function sense (1 for min (default), -1 for max)
</member>
        <member name="M:COIN.OsiSolverInterface.isInteger(System.Int32)">
Return true if column is integer.
		Note: This function returns true if the the column
		is binary or a general integer.

</member>
        <member name="M:COIN.OsiSolverInterface.isContinuous(System.Int32)">
Return true if variable is continuous
</member>
        <member name="T:COIN.OsiSolverInterface">
            <summary>
Abstract Base Class for describing an interface to a solver.
The .NET OsiSolverInterface class.
</summary>
        </member>
        <member name="D:OsiVectorCutPtr">
Vector of OsiCut pointers
</member>
        <member name="D:OsiVectorRowCutPtr">
Vector of OsiRowCut pointers
</member>
        <member name="D:OsiVectorColCutPtr">
Vector of OsiColCut pointers
</member>
        <member name="D:OsiVectorDouble">
Vector of double
</member>
        <member name="D:OsiVectorInt">
@name Typedefs for Standard Template Library collections of Osi Objects. 
Vector of int
</member>
        <member name="M:CoinIsnan(System.Double)">
checks if a double value is not a number 
</member>
        <member name="M:CoinFinite(System.Double)">
checks if a double value is finite (not infinity and not NaN) 
</member>
        <member name="F:CoinPackedMatrix.maxSize_">
max space allocated for entries
</member>
        <member name="F:CoinPackedMatrix.maxMajorDim_">
max space allocated for major-dimension
</member>
        <member name="F:CoinPackedMatrix.size_">
the number of nonzero entries
</member>
        <member name="F:CoinPackedMatrix.minorDim_">
size of other dimension
</member>
        <member name="F:CoinPackedMatrix.majorDim_">
number of vectors in matrix
</member>
        <member name="F:CoinPackedMatrix.length_">
Lengths of major-dimension vectors. 
</member>
        <member name="F:CoinPackedMatrix.start_">
Starting positions of major-dimension vectors. 
</member>
        <member name="F:CoinPackedMatrix.index_">
List of nonzero element minor-dimension indices. The entries in the gaps
       between major-dimension vectors are undefined. 
</member>
        <member name="F:CoinPackedMatrix.element_">
List of nonzero element values. The entries in the gaps between
       major-dimension vectors are undefined. 
</member>
        <member name="F:CoinPackedMatrix.extraMajor_">
his much times more space should be allocated for major-dimension
       vectors when the matrix is resized. The purpose of these gaps is to
       allow fast addition of new major-dimension vectors. 
</member>
        <member name="F:CoinPackedMatrix.extraGap_">
This much times more space should be allocated for each major-dimension
       vector (with respect to the number of entries in the vector) when the
       matrix is resized. The purpose of these gaps is to allow fast insertion
       of new minor-dimension vectors. 
</member>
        <member name="F:CoinPackedMatrix.colOrdered_">
@name Data members
      The data members are protected to allow access for derived classes. 
A flag indicating whether the matrix is column or row major ordered. 
</member>
        <member name="M:CoinPackedMatrix.gutsOfCopyOfNoGaps(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)">
When no gaps we can do faster
</member>
        <member name="M:CoinPackedMatrix.Dispose">
Destructor
</member>
        <member name="M:CoinPackedMatrix.#ctor(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Subset constructor (without gaps).  Duplicates are allowed
      and order is as given 
</member>
        <member name="M:CoinPackedMatrix.#ctor(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
A constructor where the ordering and the gaps are specified
</member>
        <member name="M:CoinPackedMatrix.#ctor">
Default Constructor creates an empty column ordered packed matrix
</member>
        <member name="M:CoinPackedMatrix.setNumElements(System.Int32)">
Change the size of the bulk store after modifying - be careful
</member>
        <member name="M:CoinPackedMatrix.getMutableVectorLengths">
The lengths of the major-dimension vectors. 
</member>
        <member name="M:CoinPackedMatrix.getMutableVectorStarts">
The positions where the major-dimension vectors start in #element_ and
        #index_. 
</member>
        <member name="M:CoinPackedMatrix.getMutableIndices">
A vector containing the minor indices of the elements in the packed
        matrix. Note that there might be gaps in this list, entries that do not
        belong to any major-dimension vector. To get the actual elements one
        should look at this vector together with #start_ and
        #length_. 
</member>
        <member name="M:CoinPackedMatrix.getMutableElements">
A vector containing the elements in the packed matrix. Note that there
	might be gaps in this list, entries that do not belong to any
	major-dimension vector. To get the actual elements one should look at
	this vector together with #start_ and #length_. 
</member>
        <member name="M:CoinPackedMatrix.timesMinor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*)">
Return <code>A * x</code> (multiplied from the "right" direction) in
	  <code>y</code>. Same as the previous method, just <code>x</code> is
	  given in the form of a packed vector. 
</member>
        <member name="M:CoinPackedMatrix.timesMinor(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
Return <code>A * x</code> (multiplied from the "right" direction) in
	  <code>y</code>.
	  @pre <code>x</code> must be of size <code>minorDim()</code>
	  @pre <code>y</code> must be of size <code>majorDim()</code></member>
        <member name="M:CoinPackedMatrix.timesMajor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*)">
Return <code>A * x</code> (multiplied from the "right" direction) in
	  <code>y</code>. Same as the previous method, just <code>x</code> is
	  given in the form of a packed vector. 
</member>
        <member name="M:CoinPackedMatrix.timesMajor(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
@name Various dot products. 
Return <code>A * x</code> (multiplied from the "right" direction) in
	  <code>y</code>.
	  @pre <code>x</code> must be of size <code>majorDim()</code>
	  @pre <code>y</code> must be of size <code>minorDim()</code></member>
        <member name="M:CoinPackedMatrix.deleteMinorVectors(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the minor-dimension vectors whose indices are listed in
	  <code>indDel</code>. 
</member>
        <member name="M:CoinPackedMatrix.deleteMajorVectors(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
@name Delete vectors 
Delete the major-dimension vectors whose indices are listed in
	  <code>indDel</code>. 
</member>
        <member name="M:CoinPackedMatrix.appendMinorVectors(System.Int32!System.Runtime.CompilerServices.IsConst,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append several minor-dimension vectors to the end of the matrix 
</member>
        <member name="M:CoinPackedMatrix.appendMinorVector(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Append a minor-dimension vector to the end of the matrix. 
</member>
        <member name="M:CoinPackedMatrix.appendMinorVector(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Append a minor-dimension vector to the end of the matrix. 
</member>
        <member name="M:CoinPackedMatrix.appendMajorVectors(System.Int32!System.Runtime.CompilerServices.IsConst,CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst*)">
Append several major-dimensonvectors to the end of the matrix 
</member>
        <member name="M:CoinPackedMatrix.appendMajorVector(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)">
Append a major-dimension vector to the end of the matrix. 
</member>
        <member name="M:CoinPackedMatrix.appendMajorVector(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Append a major-dimension vector to the end of the matrix. 
</member>
        <member name="M:CoinPackedMatrix.printMatrixElement(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)">
Print a single matrix element.
</member>
        <member name="M:CoinPackedMatrix.dumpMatrix(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Dump the matrix on stdout. When in dire straits this method can
	  help. 
</member>
        <member name="M:CoinPackedMatrix.getMaxMajorDim">
Current maximum for major dimension. For row ordered matrix this many
          rows can be added without reallocating the vector related to the
	  major dimension (<code>start_</code> and <code>length_</code>). 
</member>
        <member name="M:CoinPackedMatrix.setMinorDim(System.Int32)">
Set minor dimension. For row ordered matrix this would be the number of
          columns. Use with great care.
</member>
        <member name="M:CoinPackedMatrix.getMinorDim">
Minor dimension. For row ordered matrix this would be the number of
	  columns. 
</member>
        <member name="M:CoinPackedMatrix.setMajorDim(System.Int32)">
Set major dimension. For row ordered matrix this would be the number of
          rows. Use with great care.
</member>
        <member name="M:CoinPackedMatrix.getMajorDim">
Major dimension. For row ordered matrix this would be the number of
          rows. 
</member>
        <member name="M:CoinPackedMatrix.countOrthoLength(System.Int32*)">
Count the number of entries in every minor-dimension vector and
	  fill in an array containing these lengths.  
</member>
        <member name="M:CoinPackedMatrix.countOrthoLength">
@name Helper functions used internally, but maybe useful externally.

     These methods do not worry about testing whether the packed matrix is
     row or column major ordered; they operate under the assumption that the
     correct version is invoked. In fact, a number of other methods simply
     just call one of these after testing the ordering of the matrix. 
@name Queries 
Count the number of entries in every minor-dimension vector and
	  return an array containing these lengths. The returned array is
	  allocated with <code>new int[]</code>, free it with
	  <code>delete[]</code>. 
</member>
        <member name="M:CoinPackedMatrix.transposeTimes(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*)">
Return <code>x * A</code> in <code>y</code>. Same as the previous
        method, just <code>x</code> is given in the form of a packed vector. 
</member>
        <member name="M:CoinPackedMatrix.transposeTimes(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
Return <code>x * A</code> in <code>y</code>.
        @pre <code>x</code> must be of size <code>numRows()</code>
        @pre <code>y</code> must be of size <code>numColumns()</code></member>
        <member name="M:CoinPackedMatrix.times(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*)">
Return <code>A * x</code> in <code>y</code>. Same as the previous
        method, just <code>x</code> is given in the form of a packed vector. 
</member>
        <member name="M:CoinPackedMatrix.times(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*)">
@name Matrix times vector methods 
Return <code>A * x</code> in <code>y</code>.
        @pre <code>x</code> must be of size <code>numColumns()</code>
        @pre <code>y</code> must be of size <code>numRows()</code></member>
        <member name="M:CoinPackedMatrix.op_Assign(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. This copies out the data, but uses the current
        matrix's extra space parameters. 
</member>
        <member name="M:CoinPackedMatrix.copyReuseArrays(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy method. This method makes an exact replica of the argument,
        including the extra space parameters. 
	If there is room it will re-use arrays 
</member>
        <member name="M:CoinPackedMatrix.copyOf(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Copy the arguments to the matrix. If <code>len</code> is a NULL pointer
        then the matrix is assumed to have no gaps in it and <code>len</code>
        will be created accordingly. 
</member>
        <member name="M:CoinPackedMatrix.copyOf(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy method. This method makes an exact replica of the argument,
        including the extra space parameters. 
</member>
        <member name="M:CoinPackedMatrix.submatrixOfWithDuplicates(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Extract a submatrix from matrix. Those major-dimension vectors of
	the matrix comprise the submatrix whose indices are given in the
	arguments. Allows duplicates and keeps order. 
</member>
        <member name="M:CoinPackedMatrix.submatrixOf(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Extract a submatrix from matrix. Those major-dimension vectors of
	the matrix comprise the submatrix whose indices are given in the
	arguments. Does not allow duplicates. 
</member>
        <member name="M:CoinPackedMatrix.cleanMatrix(System.Double)">
Really clean up matrix.
	a) eliminate all duplicate AND small elements in matrix 
	b) remove all gaps and set extraGap_ and extraMajor_ to 0.0
	c) reallocate arrays and make max lengths equal to lengths
	d) orders elements
	returns number of elements eliminated

</member>
        <member name="M:CoinPackedMatrix.orderMatrix">
Sort all columns so indices are increasing.in each column 
</member>
        <member name="M:CoinPackedMatrix.eliminateDuplicates(System.Double)">
Eliminate all duplicate AND small elements in matrix 
	The column starts are not affected.  Returns number of elements
	eliminated.  

</member>
        <member name="M:CoinPackedMatrix.compress(System.Double)">
Eliminate all elements in matrix whose 
	absolute value is less than threshold.
	The column starts are not affected.  Returns number of elements
	eliminated.  Elements eliminated are at end of each vector

</member>
        <member name="M:CoinPackedMatrix.getCoefficient(System.Int32,System.Int32)">
Return one element of packed matrix.
        This works for either ordering
	If it is not present will return 0.0 
</member>
        <member name="M:CoinPackedMatrix.modifyCoefficient(System.Int32,System.Int32,System.Double,System.Boolean)">
Modify one element of packed matrix.  An element may be added.
        This works for either ordering
	If the new element is zero it will be deleted unless
	keepZero true 
</member>
        <member name="M:CoinPackedMatrix.replaceVector(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst*)">
Replace the elements of a vector.  The indices remain the same.
	At most the number specified will be replaced.
        The index is between 0 and major dimension of matrix 
</member>
        <member name="M:CoinPackedMatrix.deleteRows(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the rows whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:CoinPackedMatrix.deleteCols(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*)">
Delete the columns whose indices are listed in <code>indDel</code>. 
</member>
        <member name="M:CoinPackedMatrix.bottomAppendPackedMatrix(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Append the argument to the "bottom" of the current matrix. Imagine this
        as adding new rows (don't worry about how the matrices are ordered,
        that is taken care of). An exception is thrown if the number of columns
        is different in the matrices. 
</member>
        <member name="M:CoinPackedMatrix.rightAppendPackedMatrix(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Append the argument to the "right" of the current matrix. Imagine this
        as adding new columns (don't worry about how the matrices are ordered,
        that is taken care of). An exception is thrown if the number of rows
        is different in the matrices. 
</member>
        <member name="M:CoinPackedMatrix.setExtraMajor(System.Double!System.Runtime.CompilerServices.IsConst)">
Set the extra major to be allocated to the specified value. 
</member>
        <member name="M:CoinPackedMatrix.setExtraGap(System.Double!System.Runtime.CompilerServices.IsConst)">
Set the extra gap to be allocated to the specified value. 
</member>
        <member name="M:CoinPackedMatrix.setDimensions(System.Int32,System.Int32)">
@name Modifying members 
</member>
        <member name="M:CoinPackedMatrix.getMajorIndices">
Returns an array containing major indices.  The array is
	  getNumElements long and if getVectorStarts() is 0,2,5 then
	  the array would start 0,0,1,1,1,2...
	  This method is provided to go back from a packed format
	  to a triple format.  It returns NULL if there are gaps in
	  matrix so user should use removeGaps() if there are any gaps.
	  It does this as this array has to match getElements() and 
	  getIndices() and because it makes no sense otherwise.
	  The returned array is allocated with <code>new int[]</code>,
	  free it with  <code>delete[]</code>. 
</member>
        <member name="M:CoinPackedMatrix.getVector(System.Int32)">
Return the i'th vector in matrix. 
</member>
        <member name="M:CoinPackedMatrix.getVectorSize(System.Int32!System.Runtime.CompilerServices.IsConst)">
The length of i'th vector. 
</member>
        <member name="M:CoinPackedMatrix.getVectorLast(System.Int32!System.Runtime.CompilerServices.IsConst)">
The position of the last element (well, one entry <em>past</em> the
        last) in the i'th major-dimension vector. 
</member>
        <member name="M:CoinPackedMatrix.getVectorFirst(System.Int32!System.Runtime.CompilerServices.IsConst)">
The position of the first element in the i'th major-dimension vector.

</member>
        <member name="M:CoinPackedMatrix.getNumRows">
Number of rows. 
</member>
        <member name="M:CoinPackedMatrix.getNumCols">
Number of columns. 
</member>
        <member name="M:CoinPackedMatrix.getNumElements">
Number of entries in the packed matrix. 
</member>
        <member name="M:CoinPackedMatrix.hasGaps">
Whether the packed matrix has gaps or not. 
</member>
        <member name="M:CoinPackedMatrix.isColOrdered">
Whether the packed matrix is column major ordered or not. 
</member>
        <member name="M:CoinPackedMatrix.clear">
Clear the data, but do not free any arrays 
</member>
        <member name="M:CoinPackedMatrix.reserve(System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Boolean)">
Reserve sufficient space for appending major-ordered vectors. 
	If create is true, empty columns are created (for column generation) 
</member>
        <member name="M:CoinPackedMatrix.getExtraMajor">
Return the current setting of the extra major. 
</member>
        <member name="M:CoinPackedMatrix.getExtraGap">
@name Query members 
Return the current setting of the extra gap. 
</member>
        <member name="T:CoinPackedMatrix">
Sparse Matrix Base Class

  This class is intended to represent sparse matrices using row-major
  or column-major ordering. The representation is very efficient for
  adding, deleting, or retrieving major-dimension vectors. Adding
  a minor-dimension vector is less efficient, but can be helped by
  providing "extra" space as described in the next paragraph. Deleting
  a minor-dimension vector requires inspecting all coefficients in the
  matrix. Retrieving a minor-dimension vector would incur the same cost
  and is not supported (except in the sense that you can write a loop to
  retrieve all coefficients one at a time). Consider physically transposing
  the matrix, or keeping a second copy with the other major-vector ordering.

  The sparse represention can be completely compact or it can have "extra"
  space available at the end of each major vector.  Incorporating extra
  space into the sparse matrix representation can improve performance in
  cases where new data needs to be inserted into the packed matrix against
  the major-vector orientation (e.g, inserting a row into a matrix stored
  in column-major order).

  For example if the matrix:
  @verbatim
     3  1  0   -2   -1  0  0   -1                 
     0  2  1.1  0    0  0  0    0                       
     0  0  1    0    0  1  0    0         
     0  0  0    2.8  0  0 -1.2  0   
   5.6  0  0    0    1  0  0    1.9

  was stored by rows (with no extra space) in 
  CoinPackedMatrix r then: 
    r.getElements() returns a vector containing: 
      3 1 -2 -1 -1 2 1.1 1 1 2.8 -1.2 5.6 1 1.9 
    r.getIndices() returns a vector containing: 
      0 1  3  4  7 1 2   2 5 3    6   0   4 7 
    r.getVectorStarts() returns a vector containing: 
      0 5 7 9 11 14 
    r.getNumElements() returns 14. 
    r.getMajorDim() returns 5. 
    r.getVectorSize(0) returns 5. 
    r.getVectorSize(1) returns 2. 
    r.getVectorSize(2) returns 2. 
    r.getVectorSize(3) returns 2. 
    r.getVectorSize(4) returns 3. 
 
  If stored by columns (with no extra space) then: 
    c.getElements() returns a vector containing: 
      3 5.6 1 2 1.1 1 -2 2.8 -1 1 1 -1.2 -1 1.9 
    c.getIndices() returns a vector containing: 
      0  4  0 1 1   2  0 3    0 4 2  3    0 4 
    c.getVectorStarts() returns a vector containing: 
      0 2 4 6 8 10 11 12 14 
    c.getNumElements() returns 14. 
    c.getMajorDim() returns 8. 
  @endverbatim

  Compiling this class with CLP_NO_VECTOR defined will excise all methods
  which use CoinPackedVectorBase, CoinPackedVector, or CoinShallowPackedVector
  as parameters or return types.

  Compiling this class with COIN_FAST_CODE defined removes index range checks.

</member>
        <member name="M:CoinShallowPackedVectorUnitTest">
A function that tests the methods in the CoinShallowPackedVector class. The
    only reason for it not to be a member method is that this way it doesn't
    have to be compiled into the library. And that's a gain, because the
    library should be compiled with optimization on, but this method should be
    compiled with debugging. 
</member>
        <member name="F:CoinShallowPackedVector.nElements_">
Size of indices and elements vectors
</member>
        <member name="F:CoinShallowPackedVector.elements_">
Vector elements
</member>
        <member name="F:CoinShallowPackedVector.indices_">
@name Private member data 
Vector indices
</member>
        <member name="M:CoinShallowPackedVector.print">
Print vector information.
</member>
        <member name="M:CoinShallowPackedVector.Dispose">
Destructor. 
</member>
        <member name="M:CoinShallowPackedVector.#ctor(CoinShallowPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor. 
</member>
        <member name="M:CoinShallowPackedVector.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor from the base class. 
</member>
        <member name="M:CoinShallowPackedVector.#ctor(System.Boolean)">
@name Methods to create, set and destroy 
Default constructor. 
</member>
        <member name="M:CoinShallowPackedVector.setVector(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
just like the explicit constructor 
</member>
        <member name="M:CoinShallowPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator from a CoinPackedVectorBase. 
</member>
        <member name="M:CoinShallowPackedVector.op_Assign(CoinShallowPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinShallowPackedVector.clear">
@name Set methods 
Reset the vector (as if were just created an empty vector)
</member>
        <member name="M:CoinShallowPackedVector.getElements">
Get element values
</member>
        <member name="M:CoinShallowPackedVector.getIndices">
Get indices of elements
</member>
        <member name="M:CoinShallowPackedVector.getNumElements">
@name Get methods 
Get length of indices and elements vectors
</member>
        <member name="T:CoinShallowPackedVector">
Shallow Sparse Vector
 
This class is for sparse vectors where the indices and 
elements are stored elsewhere.  This class only maintains
pointers to the indices and elements.  Since this class
does not own the index and element data it provides
read only access to to the data.  An CoinSparsePackedVector
must be used when the sparse vector's data will be altered.

This class stores pointers to the vectors.
It does not actually contain the vectors.

Here is a sample usage:
@verbatim
   const int ne = 4; 
   int inx[ne] =   {  1,   4,  0,   2 }; 
   double el[ne] = { 10., 40., 1., 50. }; 
 
   // Create vector and set its value 
   CoinShallowPackedVector r(ne,inx,el); 
 
   // access each index and element 
   assert( r.indices ()[0]== 1  ); 
   assert( r.elements()[0]==10. ); 
   assert( r.indices ()[1]== 4  ); 
   assert( r.elements()[1]==40. ); 
   assert( r.indices ()[2]== 0  ); 
   assert( r.elements()[2]== 1. ); 
   assert( r.indices ()[3]== 2  ); 
   assert( r.elements()[3]==50. ); 
 
   // access as a full storage vector 
   assert( r[ 0]==1. ); 
   assert( r[ 1]==10.); 
   assert( r[ 2]==50.); 
   assert( r[ 3]==0. ); 
   assert( r[ 4]==40.); 
 
   // Tests for equality and equivalence
   CoinShallowPackedVector r1; 
   r1=r; 
   assert( r==r1 ); 
   r.sort(CoinIncrElementOrdered()); 
   assert( r!=r1 ); 
 
   // Add packed vectors. 
   // Similarly for subtraction, multiplication, 
   // and division. 
   CoinPackedVector add = r + r1; 
   assert( add[0] ==  1.+ 1. ); 
   assert( add[1] == 10.+10. ); 
   assert( add[2] == 50.+50. ); 
   assert( add[3] ==  0.+ 0. ); 
   assert( add[4] == 40.+40. ); 
   assert( r.sum() == 10.+40.+1.+50. ); 
@endverbatim

</member>
        <member name="F:COIN.OsiHintStrength.OsiForceDo">
And this means throw an exception if not possible 
</member>
        <member name="F:COIN.OsiHintStrength.OsiHintDo">
This means do hint if at all possible 
</member>
        <member name="F:COIN.OsiHintStrength.OsiHintTry">
This means it is only a hint 
</member>
        <member name="F:COIN.OsiHintStrength.OsiHintIgnore">
Ignore hint (default) 
</member>
        <member name="F:COIN.OsiHintParam.OsiLastHintParam">
Just a marker, so that OsiSolverInterface can allocate a static sized
		array to store parameters. 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoInBranchAndCut">
Whether we are in branch and cut - so can modify behavior 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoReducePrint">
Whether to reduce amount of printout, e.g., for branch and cut 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoCrash">
Whether to create a non-slack basis (only in initialSolve) 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoScale">
Whether to scale problem 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoDualInResolve">
Whether to use a dual algorithm in resolve.
		The reverse is to use a primal algorithm 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoPresolveInResolve">
Whether to do a presolve in resolve 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoDualInInitial">
Whether to use a dual algorithm in initialSolve.
		The reverse is to use a primal algorithm 
</member>
        <member name="F:COIN.OsiHintParam.OsiDoPresolveInInitial">
Whether to do a presolve in initialSolve 
</member>
        <member name="F:COIN.OsiStrParam.OsiLastStrParam">
Just a marker, so that OsiSolverInterface can allocate a static sized
		array to store parameters. 
</member>
        <member name="F:COIN.OsiStrParam.OsiSolverName">
Name of the solver. This parameter is not settable. 
</member>
        <member name="F:COIN.OsiStrParam.OsiProbName">
Name of the problem. This is the found on the Name card of
		an mps file. 
</member>
        <member name="F:COIN.OsiDblParam.OsiLastDblParam">
Just a marker, so that OsiSolverInterface can allocate a static sized
		array to store parameters. 
</member>
        <member name="F:COIN.OsiDblParam.OsiObjOffset">
The value of any constant term in the objective function. 
</member>
        <member name="F:COIN.OsiDblParam.OsiPrimalTolerance">
The maximum amount the primal constraints can be violated and still be
		considered feasible. 
</member>
        <member name="F:COIN.OsiDblParam.OsiDualTolerance">
The maximum amount the dual constraints can be violated and still be
		considered feasible. 
</member>
        <member name="F:COIN.OsiDblParam.OsiPrimalObjectiveLimit">
Primal objective limit. This is to be used as a termination
		criteria in methods where the primal objective monotonically changes
		(e.g., primal simplex) 
</member>
        <member name="F:COIN.OsiDblParam.OsiDualObjectiveLimit">
Dual objective limit. This is to be used as a termination
		criteria in methods where the dual objective monotonically changes
		(e.g., dual simplex, the volume algorithm) 
</member>
        <member name="F:COIN.OsiIntParam.OsiLastIntParam">
Just a marker, so that OsiSolverInterface can allocate a static sized
		array to store parameters. 
</member>
        <member name="F:COIN.OsiIntParam.OsiNameDiscipline">
The name discipline; specifies how the solver will handle row and
		column names.
		- 0: Auto names: Names cannot be set by the client. Names of the form
		Rnnnnnnn or Cnnnnnnn are generated on demand when a name for a
		specific row or column is requested; nnnnnnn is derived from the row
		or column index. Requests for a vector of names return a vector with
		zero entries.
		- 1: Lazy names: Names supplied by the client are retained. Names of the
		form Rnnnnnnn or Cnnnnnnn are generated on demand if no name has been
		supplied by the client. Requests for a vector of names return a
		vector sized to the largest index of a name supplied by the client;
		some entries in the vector may be null strings.
		- 2: Full names: Names supplied by the client are retained. Names of the
		form Rnnnnnnn or Cnnnnnnn are generated on demand if no name has been
		supplied by the client. Requests for a vector of names return a
		vector sized to match the constraint system, and all entries will
		contain either the name specified by the client or a generated name.

</member>
        <member name="F:COIN.OsiIntParam.OsiMaxNumIterationHotStart">
The maximum number of iterations (whatever that means for the given
		solver) the solver can execute in the
		OsiSolverinterface::solveFromHotStart() method before terminating. 
</member>
        <member name="F:COIN.OsiIntParam.OsiMaxNumIteration">
The maximum number of iterations (whatever that means for the given
		solver) the solver can execute in the OsiSolverinterface::initialSolve()
		and the OsiSolverinterface::resolve() methods before terminating. 
</member>
        <member name="M:COIN.CoinMpsIO.passInMessageHandler(COIN.CoinMessageHandler)">
Pass in Message handler
  
			Supply a custom message handler. It will not be destroyed when the
			CoinMpsIO object is destroyed.

</member>
        <member name="M:COIN.CoinMpsIO.columnName(System.Int32)">
Returns the column name for the specified index.

		Returns 0 if the index is out of range.


Returns the column name for the specified index.
	Returns 0 if the index is out of range.

</member>
        <member name="M:COIN.CoinMpsIO.rowName(System.Int32)">
Returns the row name for the specified index.

		Returns 0 if the index is out of range.


Returns the row name for the specified index.
	Returns 0 if the index is out of range.

</member>
        <member name="M:COIN.CoinMpsIO.isInteger(System.Int32)">
Return true if a column is an integer variable

		Note: This function returns true if the the column
		is a binary or general integer variable.


Return true if a column is an integer variable

	Note: This function returns true if the the column
	is a binary or general integer variable.

</member>
        <member name="M:COIN.CoinMpsIO.isContinuous(System.Int32)">
Return true if column is a continuous variable

Return true if column is a continuous variable
</member>
        <member name="M:COIN.CoinMpsIO.getColUpper">
Get pointer to array[getNumCols()] of column upper bounds

Get pointer to array[getNumCols()] of column upper bounds
</member>
        <member name="M:COIN.CoinMpsIO.getColLower">
Get pointer to array[getNumCols()] of column lower bounds

Get pointer to array[getNumCols()] of column lower bounds
</member>
        <member name="M:COIN.CoinMpsIO.getNumElements">
Get number of nonzero elements

Get number of nonzero elements
</member>
        <member name="M:COIN.CoinMpsIO.getNumRows">
Get number of rows

Get number of rows
</member>
        <member name="M:COIN.CoinMpsIO.getNumCols">
Get number of columns

Get number of columns
</member>
        <member name="M:COIN.CoinMpsIO.getObjectiveName">
Return the objective name

Return the objective name
</member>
        <member name="M:COIN.CoinMpsIO.getProblemName">
Return the problem name

Return the problem name
</member>
        <member name="M:COIN.CoinMpsIO.getObjCoefficients">
Get pointer to array[getNumCols()] of objective function coefficients

Get pointer to array[getNumCols()] of objective function coefficients
</member>
        <member name="M:COIN.CoinMpsIO.getRowUpper">
Get pointer to array[getNumRows()] of row upper bounds

Get pointer to array[getNumRows()] of row upper bounds
</member>
        <member name="M:COIN.CoinMpsIO.getRowLower">
Get pointer to array[getNumRows()] of row lower bounds

Get pointer to array[getNumRows()] of row lower bounds
</member>
        <member name="M:COIN.CoinMpsIO.readMps(System.String)">
Read a problem in MPS format from the given filename.

Read a problem in MPS format from the given filename.

	Use "stdin" or "-" to read from stdin.

</member>
        <member name="M:COIN.CoinMpsIO.getInfinity">
Get infinity

Get infinity
</member>
        <member name="M:COIN.CoinMpsIO.setInfinity(System.Double)">
Set infinity

Set infinity
</member>
        <member name="M:COIN.CoinMessageHandler.logLevel(System.Int32)">
Get alternative log level. 
</member>
        <member name="M:COIN.CoinMessageHandlerProxy.clone">
Clone
</member>
        <member name="M:COIN.CoinMessageHandlerProxy.op_Assign(COIN.CoinMessageHandlerProxy!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:COIN.CoinMessageHandlerProxy.#ctor(COIN.CoinMessageHandlerProxy!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The copy constructor 
</member>
        <member name="M:COIN.CoinMessages.#ctor">
Constructor with number of messages. 
</member>
        <member name="M:CoinFileOutput.puts(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Convenience method: just a 'puts(s.c_str())'.
</member>
        <member name="M:CoinFileOutput.puts(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Write a string to the file (like fputs).
Just as with fputs no trailing newline is inserted!
The terminating '\0' is not written to the file.
The default implementation determines the length of the string
and calls write on it.
@param s The zero terminated string to be written.
@return true on success, false on error.
</member>
        <member name="M:CoinFileOutput.write(System.Void!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Write a block of data to the file, similar to fwrite.
@param buffer Address of a buffer containing the data to be written.
@param size Number of bytes to write.
@return Number of bytes written.
</member>
        <member name="M:CoinFileOutput.Dispose">
Destructor.
</member>
        <member name="M:CoinFileOutput.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor (don't use this, use the create method instead).
@param fileName The name of the file used by this object.
</member>
        <member name="M:CoinFileOutput.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CoinFileOutput.Compression)">
Factory method, that creates a CoinFileOutput (more precisely
a subclass of it) for the file specified. If the compression method
is not supported an exception is thrown (so use compressionSupported
first, if this is a problem). The reason for not providing direct
access to the subclasses (and using such a method instead) is that
depending on the build configuration some of the classes are not
available (or functional). This way we can handle all required ifdefs
here instead of polluting other files.
@param fileName The file that should be read.
@param compression Compression method used.
</member>
        <member name="M:CoinFileOutput.compressionSupported(CoinFileOutput.Compression)">
Returns whether the specified compression method is supported
(i.e. was compiled into COIN).
</member>
        <member name="T:CoinFileOutput.Compression">
The compression method.
</member>
        <member name="T:CoinFileOutput">
Abstract base class for file output classes.
</member>
        <member name="M:CoinPlainFileInput.#ctor(_iobuf*)">
When already opened
</member>
        <member name="T:CoinPlainFileInput">
This reads plain text files
</member>
        <member name="M:CoinFileInput.gets(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Int32)">
Reads up to (size-1) characters an stores them into the buffer,
similar to fgets.
Reading ends, when EOF or a newline occurs or (size-1) characters have
been read. The resulting string is terminated with '\0'. If reading
ends due to an encoutered newline, the '\n' is put into the buffer,
before the '\0' is appended.
@param buffer The buffer to put the string into.
@param size The size of the buffer in characters.
@return buffer on success, or 0 if no characters have been read.
</member>
        <member name="M:CoinFileInput.read(System.Void*,System.Int32)">
Read a block of data from the file, similar to fread.
@param buffer Address of a buffer to store the data into.
@param size Number of bytes to read (buffer should be large enough).
@return Number of bytes read.
</member>
        <member name="M:CoinFileInput.Dispose">
Destructor.
</member>
        <member name="M:CoinFileInput.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor (don't use this, use the create method instead).
@param fileName The name of the file used by this object.
</member>
        <member name="M:CoinFileInput.create(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Factory method, that creates a CoinFileInput (more precisely
a subclass of it) for the file specified. This method reads the
first few bytes of the file and determines if this is a compressed
or a plain file and returns the correct subclass to handle it.
If the file does not exist or uses a compression not compiled in
an exception is thrown.
@param fileName The file that should be read.
</member>
        <member name="M:CoinFileInput.haveBzip2Support">
indicates whether CoinFileInput supports bzip2'ed files
</member>
        <member name="M:CoinFileInput.haveGzipSupport">
indicates whether CoinFileInput supports gzip'ed files
</member>
        <member name="T:CoinFileInput">
Abstract base class for file input classes.
</member>
        <member name="M:CoinFileIOBase.getReadType">
Return the method of reading being used
</member>
        <member name="M:CoinFileIOBase.getFileName">
Return the name of the file used by this object.
</member>
        <member name="M:CoinFileIOBase.Dispose">
Destructor.
</member>
        <member name="M:CoinFileIOBase.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Constructor.
@param fileName The name of the file used by this object.
</member>
        <member name="T:CoinFileIOBase">
Base class for FileIO classes.
</member>
        <member name="M:CoinMessageHandlerUnitTest">
A function that tests the methods in the CoinMessageHandler class. The
    only reason for it not to be a member method is that this way it doesn't
    have to be compiled into the library. And that's a gain, because the
    library should be compiled with optimization on, but this method should be
    compiled with debugging. 
</member>
        <member name="M:CoinMessageHandler.calcPrintStatus(System.Int32,System.Int32)">
Decide if this message should print.
</member>
        <member name="M:CoinMessageHandler.gutsOfCopy(CoinMessageHandler!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The body of the copy constructor and the assignment operator 
</member>
        <member name="F:CoinMessageHandler.g_precision_">
Current number of significant digits for floating point numbers
</member>
        <member name="F:CoinMessageHandler.g_format_">
Current format for floating point numbers
</member>
        <member name="F:CoinMessageHandler.fp_">
File pointer
</member>
        <member name="F:CoinMessageHandler.highestNumber_">
Highest message number (indicates any errors)
</member>
        <member name="F:CoinMessageHandler.source_">
Current source of message
</member>
        <member name="F:CoinMessageHandler.messageOut_">
Position in output buffer
</member>
        <member name="F:CoinMessageHandler.messageBuffer_">
Output buffer
</member>
        <member name="F:CoinMessageHandler.format_">
Format string for message (remainder)
</member>
        <member name="F:CoinMessageHandler.internalNumber_">
Internal number for use with enums
</member>
        <member name="F:CoinMessageHandler.currentMessage_">
Current message
</member>
        <member name="F:CoinMessageHandler.prefix_">
Whether we want prefix (may get more subtle so is int)
</member>
        <member name="F:CoinMessageHandler.logLevels_">
Log levels
</member>
        <member name="F:CoinMessageHandler.logLevel_">
Log level
</member>
        <member name="F:CoinMessageHandler.doubleValue_">
Log levels will be by type and will then use type
      given in CoinMessage::class_

    - 0 - Branch and bound code or similar
    - 1 - Solver
    - 2 - Stuff in Coin directory
    - 3 - Cut generators

Maximum length of constructed message (characters)
@name Protected member data 
values in message
</member>
        <member name="M:CoinMessageHandler.finish">
Finish (and print) the message.
  
    Equivalent to using the CoinMessageEol marker.

</member>
        <member name="M:CoinMessageHandler.message(System.Int32,CoinMessages!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Actions to create a message  
</member>
        <member name="M:CoinMessageHandler.setFilePointer(_iobuf*)">
Set new file pointer
</member>
        <member name="M:CoinMessageHandler.filePointer">
Get current file pointer
</member>
        <member name="M:CoinMessageHandler.highestNumber">
Highest message number (indicates any errors)
</member>
        <member name="M:CoinMessageHandler.messageBuffer">
Output buffer
</member>
        <member name="M:CoinMessageHandler.currentSource">
Source of current message
</member>
        <member name="M:CoinMessageHandler.currentMessage">
Current message
</member>
        <member name="M:CoinMessageHandler.prefix">
Current setting for printing message prefix.
</member>
        <member name="M:CoinMessageHandler.setPrefix(System.Boolean)">
Switch message prefix on or off.
</member>
        <member name="M:CoinMessageHandler.precision">
Current number of significant digits for printing floating point numbers
</member>
        <member name="M:CoinMessageHandler.setPrecision(System.UInt32)">
Set the number of significant digits for printing floating point numbers
</member>
        <member name="M:CoinMessageHandler.logLevel(System.Int32)">
Get alternative log level. 
</member>
        <member name="M:CoinMessageHandler.setLogLevel(System.Int32)">
\brief Set current log (detail) level.

    If the log level is equal or greater than the detail level of a message,
    the message will be printed. A rough convention for the amount of output
    expected is
    - 0 - none
    - 1 - minimal
    - 2 - normal low
    - 3 - normal high
    - 4 - verbose

    Please assign log levels to messages accordingly. Log levels of 8 and
    above (8,16,32, <i>etc</i>.) are intended for selective debugging.
    The logical AND of the log level specified in the message and the current
    log level is used to determine if the message is printed. (In other words,
    you're using individual bits to determine which messages are printed.)

</member>
        <member name="M:CoinMessageHandler.logLevel">
Get current log (detail) level. 
</member>
        <member name="M:CoinMessageHandler.detail(System.Int32,CoinMessages!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Get and set methods 
Get detail level of a message.
</member>
        <member name="M:CoinMessageHandler.clone">
Clone
</member>
        <member name="M:CoinMessageHandler.op_Assign(CoinMessageHandler!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator. 
</member>
        <member name="M:CoinMessageHandler.#ctor(CoinMessageHandler!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The copy constructor 
</member>
        <member name="M:CoinMessageHandler.Dispose">
Destructor 
</member>
        <member name="M:CoinMessageHandler.#ctor(_iobuf*)">
Constructor to put to file pointer (won't be closed)
</member>
        <member name="M:CoinMessageHandler.#ctor">
@name Constructors etc 
Constructor
</member>
        <member name="M:CoinMessageHandler.checkSeverity">
Check message severity - if too bad then abort

</member>
        <member name="M:CoinMessageHandler.print">
@name Virtual methods that the derived classes may provide 
Print message, return 0 normally.

</member>
        <member name="F:CoinMessages.message_">
Messages
</member>
        <member name="F:CoinMessages.lengthMessages_">
Length of fake CoinOneMessage array.
      First you get numberMessages_ pointers which point to stuff

</member>
        <member name="F:CoinMessages.class_">
Class - see later on before CoinMessageHandler
</member>
        <member name="F:CoinMessages.source_">
Source (null-terminated string, maximum 4 characters).
</member>
        <member name="F:CoinMessages.language_">
Language
</member>
        <member name="F:CoinMessages.numberMessages_">
@name member data 
Number of messages
</member>
        <member name="M:CoinMessages.fromCompact">
Moves from compact format
</member>
        <member name="M:CoinMessages.toCompact">
Moves to compact format
</member>
        <member name="M:CoinMessages.getClass">
Returns class
</member>
        <member name="M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32*)">
\brief Change detail level for several messages

    messageNumbers is expected to contain the indices of the messages to be
    changed.
    If numberMessages &gt;= 10000 or messageNumbers is NULL, the detail level
    is changed on all messages.

</member>
        <member name="M:CoinMessages.setDetailMessage(System.Int32,System.Int32)">
Change detail level for one message
</member>
        <member name="M:CoinMessages.setLanguage(CoinMessages.Language)">
Set language 
</member>
        <member name="M:CoinMessages.language">
Language.  Need to think about iso codes 
</member>
        <member name="M:CoinMessages.addMessage(System.Int32,CoinOneMessage!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Useful stuff 
</member>
        <member name="M:CoinMessages.op_Assign(CoinMessages!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
assignment operator. 
</member>
        <member name="M:CoinMessages.#ctor(CoinMessages!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The copy constructor 
</member>
        <member name="M:CoinMessages.Dispose">
Destructor 
</member>
        <member name="M:CoinMessages.#ctor(System.Int32)">
@name Constructors etc 
Constructor with number of messages. 
</member>
        <member name="T:CoinMessages.Language">
\brief Supported languages
  
    These are the languages that are supported.  At present only
    us_en is serious and the rest are for testing.

</member>
        <member name="T:CoinMessages">
\brief Class to hold and manipulate an array of massaged messages.

  Note that the message index used to reference a message in the array of
  messages is completely distinct from the external ID number stored with the
  message.

</member>
        <member name="F:CoinOneMessage.message_">
Messages (in correct language) (not all 400 may exist)
</member>
        <member name="F:CoinOneMessage.severity_">
Severity
</member>
        <member name="F:CoinOneMessage.detail_">
Will only print if detail matches
</member>
        <member name="F:CoinOneMessage.externalNumber_">
@name member data 
number to print out (also determines severity)
</member>
        <member name="M:CoinOneMessage.message">
Return the message text
</member>
        <member name="M:CoinOneMessage.detail">
Get detail level
</member>
        <member name="M:CoinOneMessage.setDetail(System.Int32)">
Set detail level
</member>
        <member name="M:CoinOneMessage.severity">
Severity
</member>
        <member name="M:CoinOneMessage.setExternalNumber(System.Int32)">
\brief Set message ID number
  
    In the default CoinMessageHandler, this number is printed in the message
    prefix and is used to determine the message severity level.

</member>
        <member name="M:CoinOneMessage.externalNumber">
@name Get and set methods 
Get message ID number 
</member>
        <member name="M:CoinOneMessage.replaceMessage(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
@name Useful stuff 
Replace message text (<i>e.g.</i>, text in a different language)
</member>
        <member name="M:CoinOneMessage.op_Assign(CoinOneMessage!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
assignment operator. 
</member>
        <member name="M:CoinOneMessage.#ctor(CoinOneMessage!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
The copy constructor 
</member>
        <member name="M:CoinOneMessage.Dispose">
Destructor 
</member>
        <member name="M:CoinOneMessage.#ctor(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Normal constructor 
</member>
        <member name="M:CoinOneMessage.#ctor">
@name Constructors etc 
Default constructor. 
</member>
        <member name="T:CoinOneMessage">
\file CoinMessageHandler.hpp
    \brief This is a first attempt at a message handler.

 The COIN Project is in favo(u)r of multi-language support. This implementation
 of a message handler tries to make it as lightweight as possible in the sense
 that only a subset of messages need to be defined --- the rest default to US
 English.

 The default handler at present just prints to stdout or to a FILE pointer

 \todo
 This needs to be worked over for correct operation with ISO character codes.

\brief Class for one massaged message.

  A message consists of a text string with formatting codes (#message_),
  an integer identifier (#externalNumber_) which also determines the severity
  level (#severity_) of the message, and a detail (logging) level (#detail_).

  CoinOneMessage is just a container to hold this information. The
  interpretation is set by CoinMessageHandler, which see.

</member>
        <member name="M:COIN.CoinPackedMatrix.getVector(System.Int32)">
Return the i'th vector in matrix. 
</member>
        <member name="M:COIN.CoinShallowPackedVector.getElements">
Get element values
</member>
        <member name="M:COIN.CoinShallowPackedVector.getIndices">
Get indices of elements
</member>
        <member name="M:COIN.CoinShallowPackedVector.getNumElements">
Get length of indices and elements vectors
</member>
        <member name="F:CoinPackedVectorBase.testedDuplicateIndex_">
True if the vector has already been tested for duplicate indices. Most
       of the operations in CoinPackedVector preserves this flag. 
</member>
        <member name="F:CoinPackedVectorBase.testForDuplicateIndex_">
True if the vector should be tested for duplicate indices when they can
       occur. 
</member>
        <member name="F:CoinPackedVectorBase.indexSetPtr_">
Store the indices in a set. This set is only created if it is needed.
       Its primary use is testing for duplicate indices.

</member>
        <member name="F:CoinPackedVectorBase.minIndex_">
Contains minimum index value or infinity
</member>
        <member name="F:CoinPackedVectorBase.maxIndex_">
@name Protected member data 
Contains max index value or -infinity
</member>
        <member name="M:CoinPackedVectorBase.clearIndexSet">
Delete the indexSet
</member>
        <member name="M:CoinPackedVectorBase.indexSet(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Return indexSetPtr_ (create it if necessary).
</member>
        <member name="M:CoinPackedVectorBase.findMaxMinIndices">
@name Protected methods 
Find Maximum and Minimum Indices
</member>
        <member name="M:CoinPackedVectorBase.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This class provides <em>const</em> access to packed vectors, so there's
       no need to provide an assignment operator. 
</member>
        <member name="M:CoinPackedVectorBase.Dispose">
Destructor 
</member>
        <member name="M:CoinPackedVectorBase.#ctor">
@name Constructors, destructor
      <strong>NOTE</strong>: All constructors are protected. There's no need
      to expose them, after all, this is an abstract class. 
Default constructor. 
</member>
        <member name="M:CoinPackedVectorBase.sum">
Sum elements of vector.
</member>
        <member name="M:CoinPackedVectorBase.infNorm">
Return the infinity-norm of the vector
</member>
        <member name="M:CoinPackedVectorBase.twoNorm">
Return the 2-norm of the vector
</member>
        <member name="M:CoinPackedVectorBase.normSquare">
Return the square of the 2-norm of the vector
</member>
        <member name="M:CoinPackedVectorBase.oneNorm">
Return the 1-norm of the vector
</member>
        <member name="M:CoinPackedVectorBase.dotProduct(System.Double!System.Runtime.CompilerServices.IsConst*)">
@name Arithmetic operators. 
Create the dot product with a full vector
</member>
        <member name="M:CoinPackedVectorBase.compare(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
This method establishes an ordering on packed vectors. It is complete
       ordering, but not the same as lexicographic ordering. However, it is
       quick and dirty to compute and thus it is useful to keep packed vectors
       in a heap when all we care is to quickly check whether a particular
       vector is already in the heap or not. Returns negative/0/positive
       depending on whether \c this is smaller/equal.greater than \c rhs. 
</member>
        <member name="M:CoinPackedVectorBase.op_Inequality(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Not equal
</member>
        <member name="M:CoinPackedVectorBase.op_Equality(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
@name Comparison operators on two packed vectors 
Equal. Returns true if vectors have same length and corresponding
       element of each vector is equal. 
</member>
        <member name="M:CoinPackedVectorBase.findIndex(System.Int32)">
Return the position of the i'th element of the full storage vector.
       If index does not exist then -1 is returned  
</member>
        <member name="M:CoinPackedVectorBase.isExistingIndex(System.Int32)">
Return true if the i'th element of the full storage vector exists in
       the packed storage vector.
</member>
        <member name="M:CoinPackedVectorBase.duplicateIndex(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Throw an exception if there are duplicate indices
</member>
        <member name="M:CoinPackedVectorBase.getMinIndex">
Get value of minimum index
</member>
        <member name="M:CoinPackedVectorBase.getMaxIndex">
@name Index methods 
Get value of maximum index
</member>
        <member name="M:CoinPackedVectorBase.setTestsOff">
Just sets test stuff false without a try etc
</member>
        <member name="M:CoinPackedVectorBase.testForDuplicateIndex">
Returns true if the vector should be tested for duplicate indices when
       they can occur. 
</member>
        <member name="M:CoinPackedVectorBase.setTestForDuplicateIndexWhenTrue(System.Boolean)">
\brief Set to the argument value whether to test for duplicate indices
	      in the vector whenever they can occur BUT we know that right
	      now the vector has no duplicate indices.

       Calling this method with \p test set to true will <em>not</em> trigger
       an immediate check for duplicate indices; instead, it's assumed that
       the result of the test will be true.

</member>
        <member name="M:CoinPackedVectorBase.setTestForDuplicateIndex(System.Boolean)">
@name Methods related to whether duplicate-index checking is performed.

       If the checking for duplicate indices is turned off, then
       some CoinPackedVector methods may not work correctly if there
       are duplicate indices.
       Turning off the checking for duplicate indices may result in
       better run time performance.

\brief Set to the argument value whether to test for duplicate indices
	      in the vector whenever they can occur.
       
       Calling this method with \p test set to true will trigger an immediate
       check for duplicate indices.

</member>
        <member name="M:CoinPackedVectorBase.getElements">
Get element values
</member>
        <member name="M:CoinPackedVectorBase.getIndices">
Get indices of elements
</member>
        <member name="M:CoinPackedVectorBase.getNumElements">
@name Virtual methods that the derived classes must provide 
Get length of indices and elements vectors
</member>
        <member name="T:CoinPackedVectorBase">
Abstract base class for various sparse vectors.

    Since this class is abstract, no object of this type can be created. The
    sole purpose of this class is to provide access to a <em>constant</em>
    packed vector. All members of this class are const methods, they can't
    change the object. 
</member>
        <member name="M:CoinErrorUnitTest">
A function that tests the methods in the CoinError class. The
    only reason for it not to be a member method is that this way it doesn't
    have to be compiled into the library. And that's a gain, because the
    library should be compiled with optimization on, but this method should be
    compiled with debugging. 
</member>
        <member name="F:CoinError.printErrors_">
Whether to print every error
</member>
        <member name="F:CoinError.lineNumber_">
Line number
</member>
        <member name="F:CoinError.file_">
file name
</member>
        <member name="F:CoinError.class_">
class name or hint
</member>
        <member name="F:CoinError.method_">
method name
</member>
        <member name="F:CoinError.message_">
@name Private member data 
message test
</member>
        <member name="M:CoinError.Dispose">
Destructor
</member>
        <member name="M:CoinError.op_Assign(CoinError!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Assignment operator
</member>
        <member name="M:CoinError.#ctor(CoinError!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Copy constructor
</member>
        <member name="M:CoinError.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.ba">
@name Constructors and destructors 
Alternate Constructor
</member>
        <member name="M:CoinError.print(System.Boolean)">
Just print (for asserts)
</member>
        <member name="M:CoinError.lineNumber">
get line number of assert (-1 if not assert)
</member>
        <member name="M:CoinError.fileName">
get name of file for assert
</member>
        <member name="M:CoinError.className">
get name of class instantiating error (or hint for assert)
</member>
        <member name="M:CoinError.methodName">
get name of method instantiating error
</member>
        <member name="M:CoinError.message">
@name Get error attributes 
get message text
</member>
        <member name="M:WindowsErrorPopupBlocker">
A function to block the popup windows that windows creates when the code
    crashes 
</member>
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:COIN.CoinMpsIO.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'M:COIN.CoinMpsIO.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpMatrixBase.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByColumn(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByRow(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix2.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix3.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.writeMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.specialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.clean(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Addition(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.setCapacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.#ctor(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPartitionedVector.print'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.miniPresolve(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Void**)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.writeBasis(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.crash(System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.scaleObjective(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setValuesPassAction(System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.moreSpecialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setMoreSpecialOptions(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.primalToleranceToGetOptimal_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.algorithm_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.incomingInfeasibility_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.#ctor(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.assignBasisStatus(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpEventHandler.event(ClpEventHandler.Event)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiLotsizeBranchingObject.#ctor(OsiSolverInterface*,OsiLotsize!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNodeInfo.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcFullNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.createInfo(CbcModel*,CbcNode*,CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseBranch(CbcModel*,CbcNode*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseDynamicBranch(CbcModel*,CbcNode*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseOsiBranch(CbcModel*,CbcNode*,OsiBranchingInformation*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseClpBranch(CbcModel*,CbcNode*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCountRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcCountRowCut.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcModel'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.branchAndBound(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.tightenVubs(System.Int32,System.Boolean,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setHotstartSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setProblemType(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setPrintFrequency(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getNodeCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getExtraNodeCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getFathomCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRightHandSide'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRowRange'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setMoreSpecialOptions2(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.moreSpecialOptions2_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.problemType_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.strongStrategy_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:COIN.ClpModel.writeMps(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiLotsizeBranchingObject.#ctor(OsiSolverInterface*,OsiLotsize!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.#ctor(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.assignBasisStatus(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNodeInfo.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcFullNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.createInfo(CbcModel*,CbcNode*,CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseBranch(CbcModel*,CbcNode*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseDynamicBranch(CbcModel*,CbcNode*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseOsiBranch(CbcModel*,CbcNode*,OsiBranchingInformation*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseClpBranch(CbcModel*,CbcNode*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCountRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcCountRowCut.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CglCutGenerator.generateCpp(_iobuf*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpMatrixBase.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByColumn(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByRow(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix2.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix3.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpMatrixBase.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByColumn(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByRow(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix2.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix3.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.clean(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Addition(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.setCapacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.#ctor(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPartitionedVector.print'. -->
        <!-- Discarding badly formed XML document comment for member 'M:COIN.ClpModel.writeMps(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiLotsizeBranchingObject.#ctor(OsiSolverInterface*,OsiLotsize!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.#ctor(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.assignBasisStatus(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNodeInfo.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcFullNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.createInfo(CbcModel*,CbcNode*,CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseBranch(CbcModel*,CbcNode*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseDynamicBranch(CbcModel*,CbcNode*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseOsiBranch(CbcModel*,CbcNode*,OsiBranchingInformation*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseClpBranch(CbcModel*,CbcNode*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCountRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcCountRowCut.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcModel'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.branchAndBound(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.tightenVubs(System.Int32,System.Boolean,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setHotstartSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setProblemType(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setPrintFrequency(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getNodeCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getExtraNodeCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getFathomCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRightHandSide'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRowRange'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setMoreSpecialOptions2(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.moreSpecialOptions2_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.problemType_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.strongStrategy_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpMatrixBase.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByColumn(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByRow(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix2.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix3.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.writeMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.specialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.clean(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Addition(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.setCapacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.#ctor(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPartitionedVector.print'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.miniPresolve(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Void**)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.writeBasis(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.crash(System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.scaleObjective(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setValuesPassAction(System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.moreSpecialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setMoreSpecialOptions(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.primalToleranceToGetOptimal_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.algorithm_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.incomingInfeasibility_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpEventHandler.event(ClpEventHandler.Event)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.getBasisStatus(System.Int32*,System.Int32*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setBasisStatus(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.getRightHandSide'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.getRowRange'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.getDualRays(System.Int32,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.getPrimalRays(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setRowType(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setRowSetTypes(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.addCol(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.loadProblem(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.assignProblem(CoinPackedMatrix**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.loadProblem(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.assignProblem(CoinPackedMatrix**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.smallestChangeInCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setSmallestChangeInCut(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.getBasis(ClpSimplex*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiClpSolverInterface.setBasis(CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ClpSimplex*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:OsiClpSolverInterface.smallestChangeInCut_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcClique'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcClique.cliqueType'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcClique.cliqueType_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcClique.slack_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCliqueBranchingObject'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcIntegerBranchingObject.#ctor(CbcModel*,System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcIntegerBranchingObject.#ctor(CbcModel*,System.Int32,System.Int32,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcLotsizeBranchingObject.#ctor(CbcModel*,System.Int32,System.Int32,System.Double,CbcLotsize!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcLotsizeBranchingObject.#ctor(CbcModel*,System.Int32,System.Int32,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.getRightHandSide'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.getRowRange'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.getDualRays(System.Int32,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.getPrimalRays(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setRowType(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.setRowSetTypes(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.addCol(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.loadProblem(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.assignProblem(CoinPackedMatrix**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.loadProblem(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCbcSolverInterface.assignProblem(CoinPackedMatrix**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinModel.deleteElement(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinModel.writeMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Int32,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinFactorization.factorSparse'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinFactorization.factorSparseSmall'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinFactorization.factorSparseLarge'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinFactorization.factorDense'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpFactorization.goOslThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpFactorization.setGoOslThreshold(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpFactorization.goDenseThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpFactorization.setGoDenseThreshold(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpFactorization.goSmallThreshold'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpFactorization.setGoSmallThreshold(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpFactorization.goOslThreshold_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpFactorization.goSmallThreshold_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpFactorization.goDenseThreshold_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiLotsizeBranchingObject.#ctor(OsiSolverInterface*,OsiLotsize!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.#ctor(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.assignBasisStatus(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNodeInfo.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcFullNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.createInfo(CbcModel*,CbcNode*,CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseBranch(CbcModel*,CbcNode*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseDynamicBranch(CbcModel*,CbcNode*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseOsiBranch(CbcModel*,CbcNode*,OsiBranchingInformation*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseClpBranch(CbcModel*,CbcNode*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCountRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcCountRowCut.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiLotsizeBranchingObject.#ctor(OsiSolverInterface*,OsiLotsize!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.#ctor(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.assignBasisStatus(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNodeInfo.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcFullNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.createInfo(CbcModel*,CbcNode*,CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseBranch(CbcModel*,CbcNode*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseDynamicBranch(CbcModel*,CbcNode*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseOsiBranch(CbcModel*,CbcNode*,OsiBranchingInformation*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseClpBranch(CbcModel*,CbcNode*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCountRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcCountRowCut.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CglCutGenerator.generateCpp(_iobuf*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:COIN.CoinLpIO.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiLotsizeBranchingObject.#ctor(OsiSolverInterface*,OsiLotsize!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.#ctor(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.assignBasisStatus(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNodeInfo.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcFullNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.createInfo(CbcModel*,CbcNode*,CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseBranch(CbcModel*,CbcNode*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseDynamicBranch(CbcModel*,CbcNode*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseOsiBranch(CbcModel*,CbcNode*,OsiBranchingInformation*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseClpBranch(CbcModel*,CbcNode*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCountRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcCountRowCut.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpMatrixBase.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByColumn(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByRow(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix2.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix3.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.writeMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.specialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.clean(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Addition(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.setCapacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.#ctor(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPartitionedVector.print'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.miniPresolve(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Void**)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.writeBasis(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.crash(System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.scaleObjective(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setValuesPassAction(System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.moreSpecialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setMoreSpecialOptions(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.primalToleranceToGetOptimal_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.algorithm_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.incomingInfeasibility_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpEventHandler.event(ClpEventHandler.Event)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:COIN.ClpModel.writeMps(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinShallowPackedVector.#ctor(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.removeGaps(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.assignMatrix(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendSameOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.majorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.minorAppendOrthoOrdered(CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedMatrix.#ctor(System.Boolean!System.Runtime.CompilerServices.IsConst,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpMatrixBase.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByColumn(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix.transposeTimesByRow(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix2.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,CoinPackedMatrix!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpPackedMatrix3.transposeTimes(ClpSimplex!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,CoinIndexedVector*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinMessages.setDetailMessages(System.Int32,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinMessageHandler'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CoinMessageHandler.printStatus_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.writeMps(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpModel.specialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.clean(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.scan(System.Int32,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinIndexedVector.op_Addition(CoinIndexedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.setCapacity'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinArrayWithLength.#ctor(System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPartitionedVector.print'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.loadProblem(ClpMatrixBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.miniPresolve(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte*,System.Void**)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.writeBasis(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.crash(System.Double,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.scaleObjective(System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setValuesPassAction(System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.moreSpecialOptions'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setMoreSpecialOptions(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColumnSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setColSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowLower(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowUpper(System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpSimplex.setRowSetBounds(System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.primalToleranceToGetOptimal_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.algorithm_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:ClpSimplex.incomingInfeasibility_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.setIntParam(OsiIntParam,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.markHotStart'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.applyCuts(OsiCuts!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiSolverInterface.writeLp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32,System.Int32,System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.#ctor(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinWarmStartBasis.assignBasisStatus(System.Int32,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte**!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:ClpEventHandler.event(ClpEventHandler.Event)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiIntegerBranchingObject.#ctor(OsiSolverInterface*,OsiSimpleInteger!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,System.Double,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiLotsizeBranchingObject.#ctor(OsiSolverInterface*,OsiLotsize!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVector!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVector.op_Assign(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:op_Addition(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.op_LessThan(OsiCut!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiRowCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:OsiColCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.consistent(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:OsiColCut.infeasible(OsiSolverInterface!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNodeInfo.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcFullNodeInfo'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.createInfo(CbcModel*,CbcNode*,CoinWarmStartBasis!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseBranch(CbcModel*,CbcNode*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseDynamicBranch(CbcModel*,CbcNode*,OsiSolverBranch**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseOsiBranch(CbcModel*,CbcNode*,OsiBranchingInformation*,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcNode.chooseClpBranch(CbcModel*,CbcNode*)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcCountRowCut'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcCountRowCut.#ctor'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CbcModel'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.branchAndBound(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.tightenVubs(System.Int32,System.Boolean,System.Double)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setHotstartSolution(System.Double!System.Runtime.CompilerServices.IsConst*,System.Int32!System.Runtime.CompilerServices.IsConst*)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setProblemType(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setPrintFrequency(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getNodeCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getExtraNodeCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getFathomCount'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRowSense'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRightHandSide'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.getRowRange'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CbcModel.setMoreSpecialOptions2(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.moreSpecialOptions2_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.problemType_'. -->
        <!-- Discarding badly formed XML document comment for member 'F:CbcModel.strongStrategy_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:COIN.ClpModel.writeMps(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:CoinError'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.denseVector(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.op_Subscript(System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:CoinPackedVectorBase.#ctor(CoinPackedVectorBase!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
    </members>
</doc>